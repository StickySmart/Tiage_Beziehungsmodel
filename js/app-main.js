/**
 * TIAGE App - Main Application Logic
 * Extracted from archetype-interaction.html for modularization
 *
 * Contents:
 * - Modal Management
 * - UI Interactions
 * - Core Application Logic
 *
 * (c) 2025 Ti-age.de - All rights reserved
 */

        // ========================================
        // MAIN APPLICATION
        // ========================================

        let data = null;
        let currentArchetype = 'single';
        let selectedPartner = 'duo';

        // Modal-Kontext fÃ¼r Profile Review (muss vor openProfileReviewModal() definiert sein)
        var currentProfileReviewContext = { archetypeKey: null, person: null };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GEWICHTUNGEN - siehe js/components/GewichtungCard.js
        // Legacy-KompatibilitÃ¤t: Alle Funktionen sind Ã¼ber window.* verfÃ¼gbar
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1: PROXY-LAYER MIGRATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // personDimensions ist jetzt ein Proxy zu TiageState (definiert in state.js)
        // Diese lokale Referenz ermÃ¶glicht weiterhin den Zugriff ohne 'window.' Prefix
        // Alle Ã„nderungen werden automatisch an TiageState weitergeleitet.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const personDimensions = window.personDimensions;

        // Dimension tooltip content
        const dimensionTooltips = {
            geschlecht: {
                title: "Geschlecht",
                text: "Dein Geschlecht. Dies beeinflusst die kÃ¶rperliche Anziehung zusammen mit der sexuellen Orientierung."
            },
            dominanz: {
                title: "Dominanz-PrÃ¤ferenz",
                text: "Welche Rolle bevorzugst du in der emotionalen und praktischen Beziehungsdynamik?\n\nâ€¢ <span style=\"color: #e74c3c; font-weight: bold;\">Dominant</span>: Du Ã¼bernimmst gerne FÃ¼hrung und Verantwortung\nâ€¢ <span style=\"color: #e74c3c; font-weight: bold;\">Submissiv</span>: Du lÃ¤sst dich gerne fÃ¼hren und vertraust auf deinen Partner\nâ€¢ <span style=\"color: #e74c3c; font-weight: bold;\">Switch</span>: Du genieÃŸt beide Rollen je nach Situation\nâ€¢ <span style=\"color: #e74c3c; font-weight: bold;\">Ausgeglichen</span>: Du bevorzugst eine gleichberechtigte Dynamik ohne feste Rollen\n\nDie Dominanz-Harmonie beeinflusst die energetische Dynamik einer Beziehung. KomplementÃ¤re PrÃ¤ferenzen (z.B. dominant + submissiv) kÃ¶nnen starke Anziehung erzeugen."
            },
            orientierung: {
                title: "Sexuelle Orientierung",
                text: "Zu welchem Geschlecht fÃ¼hlst du dich romantisch und/oder sexuell hingezogen?\n\nâ€¢ Heterosexuell: Anziehung zum anderen Geschlecht\nâ€¢ Homosexuell: Anziehung zum gleichen Geschlecht\nâ€¢ Bi-/Pansexuell: Anziehung zu mehreren oder allen Geschlechtern\n\nDie sexuelle Orientierung beeinflusst, ob eine kÃ¶rperliche/romantische Anziehung zwischen zwei Personen mÃ¶glich ist. Bei inkompatiblen Orientierungen zeigt das Modell dies als Blocker an."
            },
            orientierungKO: {
                title: "KO-Kriterien fÃ¼r Orientierung (v4.1.1 - PrimÃ¤r/SekundÃ¤r)",
                text: "<strong>ğŸ“Œ PRIMÃ„R / SEKUNDÃ„R System:</strong>\n\nâ€¢ <span style=\"color: #3498db; font-weight: bold;\">Erste Auswahl = PRIMÃ„R</span> (Hauptorientierung)\nâ€¢ <span style=\"color: #9b59b6; font-weight: bold;\">Weitere Auswahlen = SEKUNDÃ„R</span> (Exploration, Offenheit)\n\n<strong>ğŸš« Nur EINE Regel:</strong>\n\nâ€¢ <span style=\"color: #e74c3c; font-weight: bold;\">Hetero + Gay/Lesbisch</span> sind inkompatibel (logischer Widerspruch)\n\n<strong>âœ… ERLAUBTE Kombinationen:</strong>\n\nâ€¢ <span style=\"color: #2ecc71;\">Hetero (primÃ¤r) + Pan (sekundÃ¤r)</span>\nâ€¢ <span style=\"color: #2ecc71;\">Hetero (primÃ¤r) + Queer (sekundÃ¤r)</span>\nâ€¢ <span style=\"color: #2ecc71;\">Gay (primÃ¤r) + Pan (sekundÃ¤r)</span>\nâ€¢ <span style=\"color: #2ecc71;\">Gay (primÃ¤r) + Bi (sekundÃ¤r)</span>\nâ€¢ <span style=\"color: #2ecc71;\">Bi + Pan + Queer</span> (alle Kombinationen)\n\n<strong>âŒ NICHT erlaubt:</strong>\n\nâ€¢ <span style=\"color: #e74c3c;\">Hetero + Gay</span> (Widerspruch)\nâ€¢ <span style=\"color: #e74c3c;\">Gay + Hetero</span> (Widerspruch)\n\n<strong>ğŸ’¡ Beispiel:</strong>\n\"Ich bin hauptsÃ¤chlich heterosexuell (primÃ¤r), aber offen fÃ¼r pansexuelle Erfahrungen (sekundÃ¤r)\" â†’ âœ… Hetero + Pan\n\n<em>Warum?</em> Orientierung ist nicht binÃ¤r. Viele Menschen haben eine primÃ¤re PrÃ¤ferenz mit sekundÃ¤rer Offenheit."
            },
            status: {
                title: "Orientierungs-Status",
                text: "Gelebt: Du lebst diese Orientierung und bist dir sicher.\n\nInteressiert: Du bist neugierig oder in einer Explorationsphase. Die tatsÃ¤chliche Anziehung ist noch unklar."
            },
            dominanzStatus: {
                title: "Dominanz-Status",
                text: "Gelebt: Du kennst deine Dominanz-PrÃ¤ferenz und lebst sie aktiv. Die Werte des psychologischen Profils treffen mit hoher Wahrscheinlichkeit zu.\n\nInteressiert: Du bist noch am Erkunden oder unsicher Ã¼ber deine PrÃ¤ferenz. Die Konfidenz der Profilaussagen ist reduziert (hÃ¶here Varianz in deinem Verhalten).\n\nWissenschaftliche Basis: Big Five Forschung zeigt, dass Menschen in Explorationsphasen konsistent hÃ¶here Verhaltensvarianzen aufweisen (McCrae & Costa, 1997)."
            },
            // Einzelne Dominanz-Typen
            dominant: {
                title: "Dominant",
                text: "<strong>Der FÃ¼hrende</strong>\n\nDu Ã¼bernimmst gerne FÃ¼hrung und Verantwortung in Beziehungen.\n\n<strong>Merkmale:</strong> Assertiv, fÃ¼hrend, selbstsicher, bestimmend, proaktiv, entschlossen\n\n<strong>Kommunikation:</strong> Direkt und unverblÃ¼mt. Konflikte werden aktiv angegangen, nicht vermieden.\n\n<strong>Energie:</strong> Hoch, spontan, leidenschaftlich. Erholt sich schnell von Konflikten.\n\n<em>Pirsig:</em> Dominanz als dynamische Kraft, die statische Muster durchbricht.\n<em>OSHO:</em> Yang-Energie â€“ natÃ¼rlich wenn sie aus Bewusstsein kommt, nicht aus Ego."
            },
            submissiv: {
                title: "Submissiv",
                text: "<strong>Der Folgende</strong>\n\nDu lÃ¤sst dich gerne fÃ¼hren und vertraust auf deinen Partner.\n\n<strong>Merkmale:</strong> AnpassungsfÃ¤hig, folgend, empathisch, dienend, harmonieorientiert, geduldig\n\n<strong>Kommunikation:</strong> Indirekt und diplomatisch. Konflikte werden eher vermieden oder sanft angesprochen.\n\n<strong>Energie:</strong> Mittel, prÃ¤feriert Planung. Braucht Zeit zur Erholung nach Konflikten.\n\n<em>Pirsig:</em> SubmissivitÃ¤t als statisches Muster, das StabilitÃ¤t schafft.\n<em>OSHO:</em> Yin-Energie â€“ Empfangen ist genauso wertvoll wie Geben."
            },
            switch: {
                title: "Switch",
                text: "<strong>Der Flexible</strong>\n\nDu genieÃŸt beide Rollen je nach Situation und Partner.\n\n<strong>Merkmale:</strong> Flexibel, wandelbar, vielseitig, situativ, kommunikativ, experimentierfreudig\n\n<strong>Kommunikation:</strong> Situativ angepasst â€“ kann sowohl direkt als auch diplomatisch sein.\n\n<strong>Energie:</strong> Hoch und flexibel. Kann sich schnell an verschiedene Situationen anpassen.\n\n<em>Pirsig:</em> Balance zwischen statisch und dynamisch â€“ hÃ¶chste AdaptivitÃ¤t.\n<em>OSHO:</em> Die Vereinigung von Yin und Yang. Der erleuchtete Mensch trÃ¤gt beide PolaritÃ¤ten."
            },
            ausgeglichen: {
                title: "Ausgeglichen",
                text: "<strong>Der Zentrierte</strong>\n\nDu bevorzugst eine gleichberechtigte Dynamik ohne feste Rollen.\n\n<strong>Merkmale:</strong> Balanciert, harmonisch, stabil, ruhig, besonnen, gemÃ¤ÃŸigt\n\n<strong>Kommunikation:</strong> Ruhig und konstruktiv. Feedback ist ausgewogen zwischen direkt und diplomatisch.\n\n<strong>Energie:</strong> Mittel und stabil â€“ weder Ã¼bermÃ¤ÃŸig spontan noch Ã¼bermÃ¤ÃŸig planend.\n\n<em>Pirsig:</em> Wahre Balance zwischen statisch und dynamisch.\n<em>OSHO:</em> Jenseits von Yin und Yang â€“ die transzendierte Mitte."
            },
            // GFK (Gewaltfreie Kommunikation)
            gfk: {
                title: "GFK-Kompetenz",
                text: "<strong>Gewaltfreie Kommunikation nach Marshall Rosenberg</strong>\n\nWie gut beherrschst du die Prinzipien der Gewaltfreien Kommunikation?\n\nâ€¢ <strong>Niedrig:</strong> Tendenz zu VorwÃ¼rfen, Urteilen, Schuldzuweisungen. Schwierigkeiten, BedÃ¼rfnisse klar zu benennen.\n\nâ€¢ <strong>Mittel:</strong> Grundkenntnisse vorhanden. Kann in ruhigen Momenten GFK anwenden, fÃ¤llt unter Stress in alte Muster zurÃ¼ck.\n\nâ€¢ <strong>Hoch:</strong> Konsequente Anwendung der 4 Schritte: Beobachtung, GefÃ¼hl, BedÃ¼rfnis, Bitte. Empathisches ZuhÃ¶ren auch in Konflikten.\n\n<em>Pirsig:</em> GFK als dynamische QualitÃ¤t â€“ die FÃ¤higkeit, im Moment prÃ¤sent zu kommunizieren.\n<em>OSHO:</em> Wahre Kommunikation entsteht ohne Ego â€“ GFK ist ein Werkzeug dafÃ¼r."
            },
            gfk_niedrig: {
                title: "GFK: Niedrig",
                text: "<strong>Geringe GFK-Kompetenz</strong>\n\nKommunikation basiert oft auf:\nâ€¢ VorwÃ¼rfen und Schuldzuweisungen\nâ€¢ Urteilen und Bewertungen\nâ€¢ Forderungen statt Bitten\nâ€¢ Schwierigkeiten, eigene BedÃ¼rfnisse zu erkennen\n\n<strong>In Beziehungen:</strong> Konflikte eskalieren hÃ¤ufiger. MissverstÃ¤ndnisse sind alltÃ¤glich. Verletzungen entstehen unbeabsichtigt.\n\n<strong>Potenzial:</strong> GFK kann gelernt werden. Bewusstsein ist der erste Schritt."
            },
            gfk_mittel: {
                title: "GFK: Mittel",
                text: "<strong>Mittlere GFK-Kompetenz</strong>\n\nKommunikation zeigt:\nâ€¢ GrundverstÃ¤ndnis der 4 Schritte (Beobachtung, GefÃ¼hl, BedÃ¼rfnis, Bitte)\nâ€¢ FÃ¤higkeit zur Selbstreflexion\nâ€¢ In ruhigen Momenten empathisches ZuhÃ¶ren\nâ€¢ Unter Stress RÃ¼ckfall in alte Muster\n\n<strong>In Beziehungen:</strong> Gute Basis fÃ¼r konstruktive GesprÃ¤che. Konflikte kÃ¶nnen gelÃ¶st werden, wenn beide bereit sind.\n\n<strong>Wachstum:</strong> Ãœbung unter Druck vertieft die Kompetenz."
            },
            gfk_hoch: {
                title: "GFK: Hoch",
                text: "<strong>Hohe GFK-Kompetenz</strong>\n\nKommunikation geprÃ¤gt von:\nâ€¢ Konsequente Anwendung der 4 Schritte\nâ€¢ Empathisches ZuhÃ¶ren auch in Konflikten\nâ€¢ FÃ¤higkeit, hinter VorwÃ¼rfe zu hÃ¶ren\nâ€¢ Klare Unterscheidung: Beobachtung vs. Bewertung\nâ€¢ Verbindung zu eigenen und fremden BedÃ¼rfnissen\n\n<strong>In Beziehungen:</strong> Tiefe Verbindung durch echtes Verstehen. Konflikte werden zu Wachstumschancen.\n\n<em>OSHO:</em> Kommunikation ohne Ego ist Meditation in Aktion."
            },
            // Einzelne Orientierungen
            heterosexuell: {
                title: "Heterosexuell",
                text: "<strong>Anziehung zum anderen Geschlecht</strong>\n\nDu fÃ¼hlst dich romantisch und/oder sexuell zu Menschen des anderen Geschlechts hingezogen.\n\n<strong>Forschung:</strong> Die hÃ¤ufigste sexuelle Orientierung. Studien zeigen tendentiell traditionellere Wertorientierung."
            },
            homosexuell: {
                title: "Homosexuell",
                text: "<strong>Anziehung zum gleichen Geschlecht</strong>\n\nDu fÃ¼hlst dich romantisch und/oder sexuell zu Menschen des gleichen Geschlechts hingezogen.\n\n<strong>Forschung:</strong> HÃ¶here Offenheit fÃ¼r neue Erfahrungen (Allen et al., 2020). Tendentiell weniger traditionelle Wertorientierung."
            },
            bisexuell: {
                title: "Bisexuell",
                text: "<strong>Anziehung zu beiden Geschlechtern</strong>\n\nDu fÃ¼hlst dich romantisch und/oder sexuell zu Menschen beider Geschlechter hingezogen.\n\n<strong>Forschung:</strong> HÃ¶chste Offenheit aller Orientierungen (Allen et al., 2020). Am experimentierfreudigsten und am wenigsten traditionell."
            }
        };

        const icons = {
            single: 'â˜…',
            duo: 'â™¡',
            duo_flex: 'âš¡',
            solopoly: 'â—†',
            polyamor: 'â™¥',
            ra: 'âˆ',
            lat: 'âŒ‚',
            aromantisch: 'â—‡'
        };

        const categoryNames = {
            A: 'Beziehungsphilosophie',
            B: 'Werte-Alignment',
            C: 'NÃ¤he-Distanz',
            D: 'Autonomie',
            E: 'Kommunikation',
            F: 'Soziale KompatibilitÃ¤t'
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MICRO-STATEMENTS DATABASE REFERENCES
        // Philosophische Grundlage: Pirsig (MOQ) + OSHO
        //
        // Alle Micro-Statements werden aus externen Dateien geladen:
        // - statements/archetypeStatements.js (Archetyp-Kombinationen DE)
        // - statements/archetypeStatements_EN.js (Archetyp-Kombinationen EN)
        // - statements/dominanceStatements.js (Dominanz-Kombinationen)
        // - statements/orientationStatements.js (Orientierungs-Kombinationen)
        // - statements/statusStatements.js (Status-Kombinationen)
        // - statements/gfkStatements.js (GFK-Kombinationen)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Fallback-Definitionen falls externe Dateien nicht geladen wurden
        if (typeof window.archetypeStatements === 'undefined') {
            console.warn('archetypeStatements nicht geladen - verwende leeres Objekt');
            window.archetypeStatements = {};
        }
        if (typeof window.dominanceStatements === 'undefined') {
            console.warn('dominanceStatements nicht geladen - verwende leeres Objekt');
            window.dominanceStatements = {};
        }
        if (typeof window.orientationStatements === 'undefined') {
            console.warn('orientationStatements nicht geladen - verwende leeres Objekt');
            window.orientationStatements = {};
        }
        if (typeof window.statusStatements === 'undefined') {
            console.warn('statusStatements nicht geladen - verwende leeres Objekt');
            window.statusStatements = {};
        }
        if (typeof window.gfkStatements === 'undefined') {
            console.warn('gfkStatements nicht geladen - verwende leeres Objekt');
            window.gfkStatements = {};
        }

        // Legacy-Referenzen fÃ¼r RÃ¼ckwÃ¤rtskompatibilitÃ¤t mit altem Code
        // Die Statements sind jetzt globale Objekte aus den externen Dateien
        const orientierungStatements = window.orientationStatements;

        // Hilfsfunktion: Hole Statements fÃ¼r Archetyp-Kombination
        // Verwendet je nach Sprache die deutsche oder englische Version
        function getArchetypeStatements(type1, type2) {
            const key = `${type1}_${type2}`;
            const lang = typeof TiageI18n !== 'undefined' ? TiageI18n.getLanguage() : 'de';

            // WÃ¤hle die richtige Statement-Quelle basierend auf der Sprache
            if (lang === 'en' && typeof archetypeStatements_EN !== 'undefined') {
                return archetypeStatements_EN[key] || archetypeStatements[key] || null;
            }
            return archetypeStatements[key] || null;
        }

        // Hilfsfunktion: Hole Statements fÃ¼r Dominanz-Kombination
        function getDominanceStatements(dom1, dom2) {
            // Extrahiere primÃ¤re Dominanz aus Multi-Select-Objekt
            const getPrimaryDominance = (dom) => {
                if (typeof dom === 'string') return dom;
                if (typeof dom === 'object' && dom !== null) {
                    // New format: { primary: 'dominant', secondary: 'submissiv' }
                    if ('primary' in dom) {
                        return dom.primary || null;
                    }
                    // Old format: { dominant: 'gelebt', submissiv: 'interessiert' }
                    // PrioritÃ¤t: gelebt > interessiert
                    for (const key of ['dominant', 'submissiv', 'switch', 'ausgeglichen']) {
                        if (dom[key] === 'gelebt') return key;
                    }
                    for (const key of ['dominant', 'submissiv', 'switch', 'ausgeglichen']) {
                        if (dom[key] === 'interessiert') return key;
                    }
                }
                return null;
            };

            const d1 = getPrimaryDominance(dom1);
            const d2 = getPrimaryDominance(dom2);

            if (!d1 || !d2) return dominanceStatements.default;
            const key = `${d1}_${d2}`;
            return dominanceStatements[key] || dominanceStatements.default;
        }

        // Hilfsfunktion: Hole Statements fÃ¼r Orientierungs-Kombination
        // BerÃ¼cksichtigt Orientierung UND Geschlecht fÃ¼r korrekte KompatibilitÃ¤tsbewertung
        function getOrientierungStatements(orient1, orient2, geschlecht1, geschlecht2) {
            // Default wenn Daten fehlen
            if (!orient1 || !orient2 || !geschlecht1 || !geschlecht2) {
                return orientierungStatements.default;
            }

            // Extract effective gender identity (handles Trans transformation)
            const extractEffectiveGender = (geschlecht) => {
                if (!geschlecht) return null;
                if (typeof geschlecht === 'object' && 'primary' in geschlecht) {
                    const primary = geschlecht.primary;
                    const secondary = geschlecht.secondary;
                    if (secondary) {
                        if (secondary === 'cis') return primary;
                        if (secondary === 'trans') {
                            if (primary === 'mann') return 'frau';
                            if (primary === 'frau') return 'mann';
                            return primary;
                        }
                        if (['nonbinaer', 'fluid', 'suchend'].includes(secondary)) return secondary;
                        return secondary;
                    }
                    return primary || null;
                }
                if (typeof geschlecht === 'string') return geschlecht;
                return null;
            };

            let g1 = extractEffectiveGender(geschlecht1);
            let g2 = extractEffectiveGender(geschlecht2);

            // Extrahiere primÃ¤re Orientierung aus Multi-Select-Objekt
            const getPrimaryOrientation = (orient) => {
                if (typeof orient === 'string') return orient;
                if (typeof orient === 'object') {
                    // New format: { primary: 'homosexuell', secondary: 'heterosexuell' }
                    if ('primary' in orient) {
                        return orient.primary;
                    }
                    // Old format: { heterosexuell: 'gelebt', homosexuell: 'interessiert' }
                    // PrioritÃ¤t: gelebt > interessiert
                    for (const key of ['heterosexuell', 'homosexuell', 'bisexuell']) {
                        if (orient[key] === 'gelebt') return key;
                    }
                    for (const key of ['heterosexuell', 'homosexuell', 'bisexuell']) {
                        if (orient[key] === 'interessiert') return key;
                    }
                }
                return null;
            };

            const o1 = getPrimaryOrientation(orient1);
            const o2 = getPrimaryOrientation(orient2);

            if (!o1 || !o2) return orientierungStatements.default;

            // Use category comparison instead of direct string comparison
            // cis_mann and trans_mann are both male, cis_frau and trans_frau are both female
            const isMaleG = (g) => {
                if (!g) return false;
                const gl = g.toLowerCase();
                return gl === 'mÃ¤nnlich' || gl === 'cis_mann' || gl === 'trans_mann' || gl === 'mann' || gl === 'male' || gl === 'm';
            };
            const isFemaleG = (g) => {
                if (!g) return false;
                const gl = g.toLowerCase();
                return gl === 'weiblich' || gl === 'cis_frau' || gl === 'trans_frau' || gl === 'frau' || gl === 'female' || gl === 'w' || gl === 'f';
            };
            const gleichesGeschlecht = (isMaleG(g1) && isMaleG(g2)) || (isFemaleG(g1) && isFemaleG(g2)) || (g1 === g2);

            // Bisexuell ist immer grundsÃ¤tzlich kompatibel
            if (o1 === 'bisexuell' && o2 === 'bisexuell') {
                return orientierungStatements.kompatibel_bi_bi;
            }
            if (o1 === 'bisexuell' || o2 === 'bisexuell') {
                const andereOrient = o1 === 'bisexuell' ? o2 : o1;
                // PrÃ¼fe ob der andere zur bi-Person passt
                if (andereOrient === 'heterosexuell') {
                    // Hetero + Bi: kompatibel wenn unterschiedliche Geschlechter
                    if (!gleichesGeschlecht) {
                        return orientierungStatements.kompatibel_bi_hetero;
                    } else {
                        return orientierungStatements.teilweise_bi_inkompatibel;
                    }
                }
                if (andereOrient === 'homosexuell') {
                    // Homo + Bi: kompatibel wenn gleiche Geschlechter
                    if (gleichesGeschlecht) {
                        return orientierungStatements.kompatibel_bi_homo;
                    } else {
                        return orientierungStatements.teilweise_bi_inkompatibel;
                    }
                }
            }

            // Beide heterosexuell
            if (o1 === 'heterosexuell' && o2 === 'heterosexuell') {
                if (!gleichesGeschlecht) {
                    return orientierungStatements.kompatibel_hetero_hetero;
                } else {
                    return orientierungStatements.inkompatibel_hetero_hetero;
                }
            }

            // Beide homosexuell
            if (o1 === 'homosexuell' && o2 === 'homosexuell') {
                if (gleichesGeschlecht) {
                    return orientierungStatements.kompatibel_homo_homo;
                } else {
                    return orientierungStatements.inkompatibel_homo_homo;
                }
            }

            // Hetero + Homo
            if ((o1 === 'heterosexuell' && o2 === 'homosexuell') ||
                (o1 === 'homosexuell' && o2 === 'heterosexuell')) {
                return orientierungStatements.inkompatibel_hetero_homo;
            }

            return orientierungStatements.default;
        }

        // Hilfsfunktion: Hole Statements fÃ¼r Status-Kombination (fakt/interessiert)
        // Bewertet den kombinierten Sicherheitsgrad beider Personen Ã¼ber alle Dimensionen
        function getStatusStatements(personDims1, personDims2) {
            if (!personDims1 || !personDims2) {
                return statusStatements.default;
            }

            // Ermittle den dominanten Status fÃ¼r jede Person
            // Eine Person gilt als "fakt" wenn mindestens eine Dimension als fakt markiert ist
            // und keine als interessiert
            const getPersonStatus = (dims) => {
                let hasFakt = false;
                let hasInteressiert = false;

                // PrÃ¼fe Dominanz
                if (dims.dominanz && typeof dims.dominanz === 'object') {
                    // New format: { primary: 'dominant', secondary: 'submissiv' }
                    if ('primary' in dims.dominanz) {
                        if (dims.dominanz.primary) hasFakt = true;
                        if (dims.dominanz.secondary) hasInteressiert = true;
                    } else {
                        // Old format: { dominant: 'gelebt', submissiv: 'interessiert' }
                        for (const key of Object.keys(dims.dominanz)) {
                            if (dims.dominanz[key] === 'gelebt') hasFakt = true;
                            if (dims.dominanz[key] === 'interessiert') hasInteressiert = true;
                        }
                    }
                }

                // PrÃ¼fe Orientierung
                if (dims.orientierung && typeof dims.orientierung === 'object') {
                    // New format: { primary: 'homosexuell', secondary: 'heterosexuell' }
                    if ('primary' in dims.orientierung) {
                        if (dims.orientierung.primary) hasFakt = true;
                        if (dims.orientierung.secondary) hasInteressiert = true;
                    } else {
                        // Old format: { heterosexuell: 'gelebt', homosexuell: 'interessiert' }
                        for (const key of Object.keys(dims.orientierung)) {
                            if (dims.orientierung[key] === 'gelebt') hasFakt = true;
                            if (dims.orientierung[key] === 'interessiert') hasInteressiert = true;
                        }
                    }
                }

                // Wenn sowohl gelebt als auch interessiert: interessiert dominiert (Unsicherheit)
                if (hasInteressiert) return 'interessiert';
                if (hasFakt) return 'gelebt';
                return null;
            };

            const status1 = getPersonStatus(personDims1);
            const status2 = getPersonStatus(personDims2);

            if (!status1 || !status2) return statusStatements.default;

            // Symmetrische Kombinationen
            if (status1 === 'gelebt' && status2 === 'gelebt') {
                return statusStatements.gelebt_gelebt;
            }
            if (status1 === 'interessiert' && status2 === 'interessiert') {
                return statusStatements.interessiert_interessiert;
            }
            // Asymmetrische Kombination (egal welche Reihenfolge)
            return statusStatements.gelebt_interessiert;
        }

        // Archetype UI descriptions (separate from profiles/archetyp-definitions.js)
        const archetypeDescriptions = {
            single: {
                name: "Single",
                shortDef: "Bewusste Entscheidung fÃ¼r ein autonomes Leben ohne PrimÃ¤rbeziehung als dauerhafte Lebensform.",
                longDef: "Single-orientierte Menschen haben sich aktiv fÃ¼r ein Leben ohne dauerhafte romantische Partnerschaft entschieden. Dies ist keine Ãœbergangsphase ('zwischen Beziehungen'), sondern eine bewusste Lebensform, die SelbstgenÃ¼gsamkeit und persÃ¶nliche Autonomie als zentrale Werte sieht. Soziale Kontakte, Freundschaften und gelegentliche romantische/sexuelle Begegnungen sind mÃ¶glich, aber keine feste Partnerschaft wird angestrebt.",
                keyPrinciples: [
                    "SelbstgenÃ¼gsamkeit als Wert, nicht als Mangel",
                    "PersÃ¶nliche Autonomie Ã¼ber Verbindlichkeit",
                    "Beziehungen als Option, nicht als Notwendigkeit",
                    "ErfÃ¼llung durch Selbst, Freunde, Projekte"
                ],
                notTheSameAs: [
                    "'Zwischen Beziehungen' sein",
                    "'Noch nicht den Richtigen gefunden'",
                    "BeziehungsunfÃ¤hig oder bindungsÃ¤ngstlich",
                    "Einsam oder unglÃ¼cklich"
                ],
                variants: [
                    "Aromantisch-Single: Keine romantischen GefÃ¼hle, kein BedÃ¼rfnis danach",
                    "Bewusst-autonom: Positive Entscheidung fÃ¼r Freiheit",
                    "Beziehungs-kritisch: Bevorzugt UnabhÃ¤ngigkeit"
                ]
            },
            duo: {
                name: "Duo",
                shortDef: "Traditionelle monogame Zweierbeziehung mit ExklusivitÃ¤t und gemeinsamer Lebensgestaltung als Kernprinzip.",
                longDef: "Duo-orientierte Menschen leben in oder suchen eine klassische Zweierbeziehung mit romantischer und sexueller ExklusivitÃ¤t. Die Partnerschaft steht im Zentrum der Lebensgestaltung und wird als primÃ¤re emotionale und soziale Einheit verstanden. Gemeinsame Ziele, Alltag und Zukunftsplanung werden als Paar gestaltet.",
                keyPrinciples: [
                    "ExklusivitÃ¤t als Ausdruck von Verbindlichkeit",
                    "'Wir' als zentrale Einheit Ã¼ber 'Ich'",
                    "Tiefe durch Fokussierung auf eine Person",
                    "Gemeinsame Lebensgestaltung und Zukunftsplanung",
                    "Treue als emotionale und sexuelle ExklusivitÃ¤t"
                ],
                notTheSameAs: [
                    "Besitzdenken oder Kontrolle",
                    "Verlust der eigenen IdentitÃ¤t",
                    "'Alte' oder 'Ã¼berholte' Beziehungsform",
                    "Langweilig oder unerfÃ¼llt"
                ],
                variants: [
                    "Traditionell-Duo: Klassisches Ehe-Modell",
                    "Modern-Duo: Ohne Trauschein, flexiblere Rollen",
                    "Intensiv-Duo: Sehr enge emotionale Verschmelzung"
                ]
            },
            duo_flex: {
                name: "Duo-Flex",
                shortDef: "PrimÃ¤re Zweierbeziehung mit vereinbarten Ã–ffnungen fÃ¼r zusÃ¤tzliche Kontakte unter klaren Regeln.",
                longDef: "Duo-Flex-orientierte Menschen leben in einer Hauptbeziehung mit einem PrimÃ¤rpartner, Ã¶ffnen diese aber bewusst und einvernehmlich fÃ¼r weitere Kontakte. Die PrimÃ¤rbeziehung bleibt zentral und privilegiert. Alle Ã–ffnungen erfolgen transparent und nach gemeinsam vereinbarten Regeln.",
                keyPrinciples: [
                    "PrimÃ¤rbeziehung als Anker und PrioritÃ¤t",
                    "Sexuelle/romantische Vielfalt ohne Hierarchie-Aufgabe",
                    "Ehrlichkeit und Transparenz Ã¼ber alle Kontakte",
                    "Regeln schÃ¼tzen die Hauptbeziehung",
                    "Freiheit innerhalb vereinbarter Grenzen"
                ],
                notTheSameAs: [
                    "Untreue oder Betrug (alles ist abgesprochen!)",
                    "'Beziehung retten' durch Ã–ffnung",
                    "Fehlende Verbindlichkeit",
                    "Ãœbergangsphase zu Polyamorie"
                ],
                variants: [
                    "Swinging/Lifestyle: Gemeinsame sexuelle Erlebnisse",
                    "Open Relationship: Individuelle sexuelle Freiheit",
                    "Hierarchisches Poly: PrimÃ¤rpartner + Nebenbeziehungen"
                ]
            },
            solopoly: {
                name: "Solopoly",
                shortDef: "Mehrere gleichwertige Beziehungen bei bewusster Bewahrung der eigenen Autonomie - keine PrimÃ¤rpartner.",
                longDef: "Solopoly-orientierte Menschen fÃ¼hren mehrere romantische und/oder sexuelle Beziehungen parallel, ohne eine davon als 'Hauptbeziehung' zu priorisieren. Die persÃ¶nliche Autonomie steht im Zentrum: Kein Zusammenziehen, keine gemeinsame HaushaltsfÃ¼hrung. 'Ich bin mein eigener PrimÃ¤rpartner'.",
                keyPrinciples: [
                    "Autonomie als hÃ¶chster Wert - auch in Beziehungen",
                    "Mehrere gleichwertige Beziehungen ohne Hierarchie",
                    "Keine Verschmelzung oder gemeinsame Haushalte",
                    "'Ich bin mein eigener PrimÃ¤rpartner'",
                    "Liebe ohne Aufgabe der UnabhÃ¤ngigkeit"
                ],
                notTheSameAs: [
                    "Bindungsangst oder Commitment-Probleme",
                    "'Light-Version' von Polyamorie",
                    "Egoistisch oder beziehungsunfÃ¤hig",
                    "Zwischenstufe zu 'richtiger' Partnerschaft"
                ],
                variants: [
                    "Stark-autonom: Sehr klare Grenzen",
                    "Beziehungs-balanciert: Tiefe Beziehungen, getrennte Wohnungen",
                    "Netzwerk-orientiert: Viele gleichwertige Connections"
                ]
            },
            ra: {
                name: "RA",
                shortDef: "VollstÃ¤ndige Ablehnung von Beziehungshierarchien und gesellschaftlichen Normen.",
                longDef: "RAs hinterfragen alle gesellschaftlichen Beziehungsnormen radikal. Keine Beziehung ist 'hÃ¶her' als eine andere - Freundschaften kÃ¶nnen genauso wichtig sein wie romantische Beziehungen. Jede Verbindung wird individuell definiert, ohne externe Vorlagen.",
                keyPrinciples: [
                    "Keine Hierarchien zwischen Beziehungstypen",
                    "Jede Beziehung wird individuell definiert",
                    "Ablehnung gesellschaftlicher Beziehungsnormen",
                    "Autonomie als hÃ¶chster Wert",
                    "Keine BesitzansprÃ¼che an andere Menschen"
                ],
                notTheSameAs: [
                    "BeziehungsunfÃ¤hig oder bindungsscheu",
                    "Chaotisch oder regellos",
                    "Verantwortungslos",
                    "Gegen Commitment generell"
                ],
                variants: [
                    "Anarchisch-vernetzt: Viele gleichwertige Verbindungen",
                    "Philosophisch-RA: Tiefe Reflexion Ã¼ber Normen",
                    "Pragmatisch-RA: Flexible Anwendung der Prinzipien"
                ]
            },
            lat: {
                name: "LAT (Living Apart Together)",
                shortDef: "Feste Partnerschaft mit bewusst getrennten Wohnungen und Alltagsleben.",
                longDef: "LAT-orientierte Menschen wÃ¼nschen sich tiefe, verbindliche Beziehungen, aber mit klarer rÃ¤umlicher und alltÃ¤glicher Autonomie. Die eigenen vier WÃ¤nde sind kein Zeichen von Distanz, sondern von gesunder SelbstfÃ¼rsorge.",
                keyPrinciples: [
                    "Liebe braucht kein gemeinsames Dach",
                    "Eigener RÃ¼ckzugsraum ist essentiell",
                    "QualitÃ¤tszeit Ã¼ber QuantitÃ¤t",
                    "Autonomie im Alltag",
                    "Bewusste Entscheidung fÃ¼r NÃ¤he"
                ],
                notTheSameAs: [
                    "Bindungsangst oder Commitment-Phobie",
                    "Fernbeziehung aus Zwang",
                    "Halbe Beziehung oder weniger ernst",
                    "Ãœbergangsphase zum Zusammenziehen"
                ],
                variants: [
                    "Nachbarschafts-LAT: Getrennte Wohnungen in der NÃ¤he",
                    "Wochenend-LAT: Intensives Zeit-teilen am Wochenende",
                    "Flexibel-LAT: Situative Anpassung der NÃ¤he"
                ]
            },
            aromantisch: {
                name: "Aromantisch",
                shortDef: "Wenig oder keine romantische Anziehung, aber tiefe Verbindungen auf anderen Ebenen.",
                longDef: "Aromantische Menschen erleben wenig bis keine romantische Anziehung zu anderen. Das bedeutet nicht, dass sie keine tiefen Verbindungen haben kÃ¶nnen - Freundschaften, queerplatonische Beziehungen und andere Formen von NÃ¤he sind mÃ¶glich und wertvoll.",
                keyPrinciples: [
                    "Romantische Liebe ist nicht die einzige Tiefe",
                    "Freundschaften kÃ¶nnen primÃ¤re Beziehungen sein",
                    "Ehrlichkeit Ã¼ber eigene Grenzen",
                    "Keine Verpflichtung zu romantischen GefÃ¼hlen",
                    "Alternative Beziehungsformen werden wertgeschÃ¤tzt"
                ],
                notTheSameAs: [
                    "Kalt oder gefÃ¼hllos",
                    "Antisozial oder einsam",
                    "Noch nicht die richtige Person gefunden",
                    "Psychische StÃ¶rung oder Defizit"
                ],
                variants: [
                    "Greyromantisch: Seltene romantische Anziehung",
                    "Demiromantisch: Romantik nur nach tiefer Bindung",
                    "Queerplatonisch: Tiefe nicht-romantische PrimÃ¤rbeziehungen"
                ]
            },
            polyamor: {
                name: "Polyamor",
                shortDef: "Mehrere gleichzeitige, ethisch gefÃ¼hrte Liebesbeziehungen mit Transparenz und emotionalem Commitment.",
                longDef: "Polyamor-orientierte Menschen fÃ¼hren mehrere romantische Beziehungen parallel, die alle auf Ehrlichkeit, Einvernehmlichkeit und Transparenz basieren. Tiefe Verschmelzung, Zusammenleben und gemeinsame Zukunftsplanung mit mehreren Partnern sind mÃ¶glich und erwÃ¼nscht. Alle Beteiligten wissen voneinander.",
                keyPrinciples: [
                    "Liebe ist nicht begrenzt oder exklusiv",
                    "Ehrlichkeit und Transparenz gegenÃ¼ber allen",
                    "Konsens und Einvernehmlichkeit als Basis",
                    "Emotionale Tiefe zu mehreren Menschen",
                    "Kommunikation als zentrale Kompetenz"
                ],
                notTheSameAs: [
                    "Untreue oder Betrug (alle wissen Bescheid!)",
                    "BindungsunfÃ¤higkeit",
                    "Nur Sex ohne GefÃ¼hle",
                    "Chaotisch oder unkontrolliert"
                ],
                variants: [
                    "Hierarchisches Poly: PrimÃ¤r-, SekundÃ¤rpartner",
                    "Nicht-hierarchisches Poly: Alle gleichwertig",
                    "Kitchen-Table-Poly: Alle Partner verstehen sich",
                    "Parallel-Poly: Partner kennen sich, wenig Kontakt"
                ]
            }
        };

        // Tag tooltip content for type combinations
        // Keys: "type1-type2" (alphabetically sorted), categories: A-F, tags: normalized tag names
        const tagTooltipContent = {
            // Single Ã— Polyamor (niedrige KompatibilitÃ¤t - PrioritÃ¤t)
            "polyamor-single": {
                "A": {
                    "exklusivitaets-erwartung": {
                        type1Perspective: "Singles haben keine aktive ExklusivitÃ¤ts-Erwartung, da sie bewusst ohne PrimÃ¤rbeziehung leben.",
                        type2Perspective: "Polyamor-Menschen lehnen ExklusivitÃ¤t als Grundprinzip ab - Liebe wird als nicht-begrenzt verstanden.",
                        dynamic: "Beide lehnen ExklusivitÃ¤t ab, aber aus vÃ¶llig verschiedenen GrÃ¼nden: Single will keine Beziehung, Polyamor will mehrere gleichzeitig."
                    },
                    "offenheit-fuer-alternative-modelle": {
                        type1Perspective: "Singles sind theoretisch offen, haben aber keine aktive Beziehungspraxis.",
                        type2Perspective: "Polyamor lebt alternative Modelle aktiv mit mehreren gleichzeitigen Liebesbeziehungen.",
                        dynamic: "Potenzielle BrÃ¼cke: Ein Single kÃ¶nnte Polyamorie entdecken, wenn die Autonomie gewahrt bleibt."
                    },
                    "beziehung-als-lebensinhalt-vs-lebensbereich": {
                        type1Perspective: "FÃ¼r Singles ist Beziehung kein zentraler Lebensinhalt - SelbstgenÃ¼gsamkeit steht im Vordergrund.",
                        type2Perspective: "FÃ¼r Polyamor sind Beziehungen sehr zentral, aber als Netzwerk statt als einzelne Partnerschaft.",
                        dynamic: "Grundlegend verschiedene LebensentwÃ¼rfe: Beziehungsfreiheit vs. Beziehungsvielfalt als Ideal."
                    }
                },
                "B": {
                    "definition-von-treue": {
                        type1Perspective: "Treue ist fÃ¼r Singles kein relevantes Konzept, da keine Beziehungsverpflichtungen bestehen.",
                        type2Perspective: "Treue bedeutet fÃ¼r Polyamor Ehrlichkeit und Transparenz, nicht ExklusivitÃ¤t.",
                        dynamic: "Verschiedene Bedeutungen: FÃ¼r Single irrelevant, fÃ¼r Polyamor transformiert - aber nicht abwesend."
                    },
                    "ethische-grundhaltung": {
                        type1Perspective: "Singles praktizieren Selbstverantwortung ohne Rechenschaftspflicht gegenÃ¼ber Partnern.",
                        type2Perspective: "Polyamor betont ethische Verantwortung gegenÃ¼ber allen Beziehungspartnern.",
                        dynamic: "Single lebt fÃ¼r sich, Polyamor fÃ¼r ein Netzwerk - unterschiedliche ethische Bezugsrahmen."
                    },
                    "verantwortungsbewusstsein": {
                        type1Perspective: "Verantwortung liegt primÃ¤r bei sich selbst und eigenen Lebensentscheidungen.",
                        type2Perspective: "Verantwortung erstreckt sich auf mehrere Partner und deren emotionale BedÃ¼rfnisse.",
                        dynamic: "Einzelverantwortung vs. Netzwerkverantwortung - fundamental verschiedene KomplexitÃ¤tsgrade."
                    }
                },
                "C": {
                    "emotionale-verschmelzungs-tendenz": {
                        type1Perspective: "Singles meiden emotionale Verschmelzung zugunsten von SelbstgenÃ¼gsamkeit.",
                        type2Perspective: "Polyamor sucht emotionale Tiefe mit mehreren Menschen gleichzeitig.",
                        dynamic: "Singles wahren Distanz, Polyamor sucht NÃ¤he - aber verteilt auf mehrere Personen."
                    },
                    "physische-naehe-beduerfnisse": {
                        type1Perspective: "Physische NÃ¤he ist fÃ¼r Singles optional und situativ, nicht strukturell verankert.",
                        type2Perspective: "Polyamor hat oft hohe physische NÃ¤he-BedÃ¼rfnisse zu mehreren Partnern.",
                        dynamic: "Singles regulieren NÃ¤he selbst, Polyamor jongliert NÃ¤he-BedÃ¼rfnisse im Netzwerk."
                    },
                    "faehigkeit-raum-zu-geben": {
                        type1Perspective: "Singles brauchen viel Raum und sind geÃ¼bt darin, diesen zu verteidigen.",
                        type2Perspective: "Polyamor gibt Raum durch verteilte Aufmerksamkeit auf mehrere Partner.",
                        dynamic: "Beide kÃ¶nnen Raum geben - Single durch Abwesenheit, Polyamor durch Verteilung."
                    }
                },
                "D": {
                    "individuelle-freiheit": {
                        type1Perspective: "Maximale Freiheit ohne Kompromisse - Singles gestalten ihr Leben vollstÃ¤ndig selbst.",
                        type2Perspective: "Freiheit innerhalb eines ethischen Beziehungsnetzwerks mit Absprachen.",
                        dynamic: "Absolute vs. verhandelte Freiheit - Singles haben mehr, mÃ¼ssen aber auf Beziehungstiefe verzichten."
                    },
                    "entscheidungsautonomie": {
                        type1Perspective: "Volle Entscheidungsautonomie ohne RÃ¼cksprache oder Kompromisse.",
                        type2Perspective: "Entscheidungsautonomie mit Transparenzpflicht gegenÃ¼ber allen Partnern.",
                        dynamic: "Singles entscheiden allein, Polyamor kommuniziert - verschiedene Autonomie-Definitionen."
                    },
                    "akzeptanz-der-autonomie-des-anderen": {
                        type1Perspective: "Singles respektieren Autonomie anderer, da sie selbst maximale Autonomie leben.",
                        type2Perspective: "Polyamor fÃ¶rdert aktiv die Autonomie aller Partner im Netzwerk.",
                        dynamic: "Passives Respektieren vs. aktives FÃ¶rdern von Autonomie."
                    }
                },
                "E": {
                    "kommunikationstiefe": {
                        type1Perspective: "Singles kommunizieren situativ und bei Bedarf, ohne dauerhafte Verpflichtung.",
                        type2Perspective: "Polyamor erfordert tiefe, kontinuierliche Kommunikation mit allen Partnern.",
                        dynamic: "Verschiedene Kommunikationskulturen: Bedarfsorientiert vs. strukturell verankert."
                    },
                    "konfliktfaehigkeit": {
                        type1Perspective: "Singles kÃ¶nnen Konflikte durch RÃ¼ckzug vermeiden - keine Beziehungspflicht.",
                        type2Perspective: "Polyamor muss Konflikte aktiv lÃ¶sen, um das Netzwerk zu erhalten.",
                        dynamic: "Exit-Option vs. KonfliktlÃ¶sung als Notwendigkeit - sehr verschiedene Strategien."
                    },
                    "emotionale-transparenz": {
                        type1Perspective: "Emotionale Transparenz ist optional, da keine festen Beziehungspflichten bestehen.",
                        type2Perspective: "Maximale emotionale Transparenz als ethische Grundlage aller Beziehungen.",
                        dynamic: "Freiwillige vs. verpflichtende Transparenz - unterschiedliche Grundhaltungen."
                    }
                },
                "F": {
                    "gesellschaftliche-akzeptanz": {
                        type1Perspective: "Singles sind gesellschaftlich akzeptiert, wenn auch manchmal bedauert.",
                        type2Perspective: "Polyamor erfÃ¤hrt oft Stigmatisierung und UnverstÃ¤ndnis.",
                        dynamic: "Single ist 'normal', Polyamor muss sich erklÃ¤ren - verschiedene gesellschaftliche Positionen."
                    },
                    "integration-in-soziale-kreise": {
                        type1Perspective: "Singles integrieren sich individuell und flexibel in soziale Kreise.",
                        type2Perspective: "Polyamor bringt komplexe Beziehungsstrukturen in soziale Kontexte ein.",
                        dynamic: "Einfache vs. komplexe soziale Integration - Singles haben es leichter."
                    },
                    "umgang-mit-stigma": {
                        type1Perspective: "Singles erleben mildes Stigma ('Wann heiratest du?'), aber keine starke Ablehnung.",
                        type2Perspective: "Polyamor muss aktiv mit Vorurteilen und Abwertung umgehen.",
                        dynamic: "Leichtes vs. starkes Stigma - Polyamor braucht mehr Resilienz."
                    }
                }
            },
            // Duo Ã— Polyamor (maximaler Konflikt - PrioritÃ¤t)
            "duo-polyamor": {
                "A": {
                    "exklusivitaets-erwartung": {
                        type1Perspective: "Duo sieht ExklusivitÃ¤t als fundamentalen Ausdruck von Liebe und Verbindlichkeit.",
                        type2Perspective: "Polyamor versteht Liebe als nicht-begrenzte Ressource, die sich auf mehrere Menschen erstrecken kann.",
                        dynamic: "Fundamentaler Konflikt: Was fÃ¼r Duo Treue bedeutet, ist fÃ¼r Polyamor eine kÃ¼nstliche BeschrÃ¤nkung."
                    },
                    "offenheit-fuer-alternative-modelle": {
                        type1Perspective: "Duo bevorzugt das bewÃ¤hrte Zweiermodell und sieht wenig Grund zur Ã–ffnung.",
                        type2Perspective: "Polyamor lebt aktiv ein alternatives Modell und hinterfragt Monogamie-Normen.",
                        dynamic: "Tradition vs. Alternative: Duo fragt 'Warum Ã¤ndern?', Polyamor fragt 'Warum beschrÃ¤nken?'"
                    },
                    "beziehung-als-lebensinhalt-vs-lebensbereich": {
                        type1Perspective: "FÃ¼r Duo ist DIE Beziehung zentraler Lebensinhalt - 'Wir' als Einheit.",
                        type2Perspective: "FÃ¼r Polyamor sind Beziehungen plural - mehrere gleichwertige 'Wirs'.",
                        dynamic: "SingulÃ¤res 'Wir' vs. plurales 'Wir' - grundverschiedene Beziehungsarchitekturen."
                    }
                },
                "B": {
                    "definition-von-treue": {
                        type1Perspective: "Treue bedeutet exklusive emotionale und sexuelle Bindung an eine Person.",
                        type2Perspective: "Treue bedeutet Ehrlichkeit, Transparenz und Einhalten von Absprachen - nicht ExklusivitÃ¤t.",
                        dynamic: "Maximaler Definitionskonflikt: Duo sieht Untreue, wo Polyamor Transparenz sieht."
                    },
                    "ethische-grundhaltung": {
                        type1Perspective: "Ethik basiert auf Versprechen, Verbindlichkeit und Fokussierung auf einen Partner.",
                        type2Perspective: "Ethik basiert auf Ehrlichkeit, Konsens und Verantwortung gegenÃ¼ber allen Beteiligten.",
                        dynamic: "Verschiedene ethische Fundamente: ExklusivitÃ¤tsethik vs. Transparenzethik."
                    },
                    "verantwortungsbewusstsein": {
                        type1Perspective: "Verantwortung konzentriert sich auf einen Partner und die gemeinsame Zukunft.",
                        type2Perspective: "Verantwortung verteilt sich auf mehrere Partner und komplexe Beziehungsdynamiken.",
                        dynamic: "Fokussierte vs. verteilte Verantwortung - unterschiedliche KapazitÃ¤tsanforderungen."
                    }
                },
                "C": {
                    "emotionale-verschmelzungs-tendenz": {
                        type1Perspective: "Duo strebt tiefe emotionale Verschmelzung mit einem Partner an.",
                        type2Perspective: "Polyamor erlebt emotionale Tiefe mit mehreren Menschen, aber weniger Verschmelzung pro Person.",
                        dynamic: "Intensive Tiefe zu einem vs. verteilte Tiefe zu mehreren - verschiedene emotionale Ã–konomien."
                    },
                    "physische-naehe-beduerfnisse": {
                        type1Perspective: "Physische NÃ¤he fokussiert sich exklusiv auf den Partner.",
                        type2Perspective: "Physische NÃ¤he verteilt sich auf mehrere Partner nach Bedarf und Absprache.",
                        dynamic: "Exklusive vs. geteilte IntimitÃ¤t - kann fÃ¼r Duo als Verlust erlebt werden."
                    },
                    "faehigkeit-raum-zu-geben": {
                        type1Perspective: "Duo gibt Raum innerhalb der Partnerschaft, aber nicht fÃ¼r andere Beziehungen.",
                        type2Perspective: "Polyamor muss Raum fÃ¼r alle Partner schaffen und ausbalancieren.",
                        dynamic: "Raum fÃ¼r Individuum vs. Raum fÃ¼r andere Beziehungen - verschiedene Raumkonzepte."
                    }
                },
                "D": {
                    "individuelle-freiheit": {
                        type1Perspective: "Freiheit wird gemeinsam als Paar definiert und gelebt.",
                        type2Perspective: "Individuelle Freiheit schlieÃŸt Freiheit fÃ¼r mehrere Liebesbeziehungen ein.",
                        dynamic: "Paar-Freiheit vs. individuelle Beziehungsfreiheit - verschiedene Freiheitsbegriffe."
                    },
                    "entscheidungsautonomie": {
                        type1Perspective: "Wichtige Entscheidungen werden als Paar getroffen.",
                        type2Perspective: "Individuelle Autonomie auch bei Beziehungsentscheidungen, mit Transparenz.",
                        dynamic: "Gemeinsame vs. individuelle Entscheidungsmacht - kann zu Konflikten fÃ¼hren."
                    },
                    "akzeptanz-der-autonomie-des-anderen": {
                        type1Perspective: "Autonomie des Partners wird anerkannt, aber nicht fÃ¼r andere Beziehungen.",
                        type2Perspective: "Autonomie schlieÃŸt explizit die Freiheit fÃ¼r weitere Liebesbeziehungen ein.",
                        dynamic: "Begrenzte vs. unbegrenzte Autonomie-Akzeptanz - Kernkonflikt dieser Kombination."
                    }
                },
                "E": {
                    "kommunikationstiefe": {
                        type1Perspective: "Tiefe Kommunikation mit einem Partner Ã¼ber alle Lebensaspekte.",
                        type2Perspective: "Tiefe Kommunikation mit mehreren Partnern, plus Meta-Kommunikation Ã¼ber Beziehungen.",
                        dynamic: "Verschiedene Kommunikationsanforderungen: Duo ist intensiv, Polyamor ist extensiv."
                    },
                    "konfliktfaehigkeit": {
                        type1Perspective: "Konflikte werden zu zweit gelÃ¶st, ohne externe Beziehungen.",
                        type2Perspective: "Konflikte kÃ¶nnen mehrere Partner betreffen und erfordern komplexe LÃ¶sungen.",
                        dynamic: "Bilaterale vs. multilaterale KonfliktlÃ¶sung - verschiedene KomplexitÃ¤tsgrade."
                    },
                    "emotionale-transparenz": {
                        type1Perspective: "Emotionale Transparenz primÃ¤r gegenÃ¼ber dem einen Partner.",
                        type2Perspective: "Emotionale Transparenz gegenÃ¼ber allen Partnern als ethische Basis.",
                        dynamic: "Duo kann Transparenz gegenÃ¼ber 'Dritten' als Verrat empfinden - Polyamor als Grundlage."
                    }
                },
                "F": {
                    "gesellschaftliche-akzeptanz": {
                        type1Perspective: "Duo entspricht der gesellschaftlichen Norm und genieÃŸt volle Akzeptanz.",
                        type2Perspective: "Polyamor muss gegen Vorurteile und mangelndes VerstÃ¤ndnis kÃ¤mpfen.",
                        dynamic: "Norm vs. Abweichung - Duo hat soziale Vorteile, Polyamor soziale HÃ¼rden."
                    },
                    "integration-in-soziale-kreise": {
                        type1Perspective: "Duo wird als 'normales' Paar problemlos in alle Kontexte integriert.",
                        type2Perspective: "Polyamor muss erklÃ¤ren, verbergen oder mit UnverstÃ¤ndnis umgehen.",
                        dynamic: "Reibungslose vs. erklÃ¤rungsbedÃ¼rftige Integration - verschiedene soziale Belastungen."
                    },
                    "umgang-mit-stigma": {
                        type1Perspective: "Duo erfÃ¤hrt kein Stigma, sondern gesellschaftliche UnterstÃ¼tzung.",
                        type2Perspective: "Polyamor muss aktiv mit Stigmatisierung und Diskriminierung umgehen.",
                        dynamic: "Privilegierte vs. marginalisierte Position - kann zu UnverstÃ¤ndnis fÃ¼hren."
                    }
                }
            },
            // Duo-Flex Ã— Solopoly (interessante Balance - PrioritÃ¤t)
            "duo_flex-solopoly": {
                "A": {
                    "exklusivitaets-erwartung": {
                        type1Perspective: "Duo-Flex hÃ¤lt an einer PrimÃ¤rbeziehung fest, Ã¶ffnet aber fÃ¼r Zusatzkontakte.",
                        type2Perspective: "Solopoly lehnt jede Form von PrimÃ¤rhierarchie ab - alle Beziehungen sind gleichwertig.",
                        dynamic: "Hierarchie vs. Gleichwertigkeit: Duo-Flex braucht einen Anker, Solopoly will keinen."
                    },
                    "offenheit-fuer-alternative-modelle": {
                        type1Perspective: "Duo-Flex ist offen, aber innerhalb eines strukturierten Rahmens mit PrimÃ¤rpartner.",
                        type2Perspective: "Solopoly lebt maximale Offenheit ohne Verpflichtung zu einer Hauptbeziehung.",
                        dynamic: "Gerahmte vs. ungerahmte Offenheit - beide alternativ, aber verschieden strukturiert."
                    },
                    "beziehung-als-lebensinhalt-vs-lebensbereich": {
                        type1Perspective: "Die PrimÃ¤rbeziehung ist Lebensinhalt, andere Kontakte sind Bereicherung.",
                        type2Perspective: "Alle Beziehungen sind Lebensbereiche, keiner ist zentraler Lebensinhalt.",
                        dynamic: "Zentrale vs. dezentrale Beziehungsarchitektur - verschiedene Lebensmodelle."
                    }
                },
                "B": {
                    "definition-von-treue": {
                        type1Perspective: "Treue bedeutet Ehrlichkeit und Prioririsierung des Hauptpartners.",
                        type2Perspective: "Treue bedeutet Ehrlichkeit gegenÃ¼ber allen, ohne Hierarchie der Wichtigkeit.",
                        dynamic: "Hierarchische vs. egalitÃ¤re Treue-Definition - beide ehrlich, anders strukturiert."
                    },
                    "ethische-grundhaltung": {
                        type1Perspective: "Ethik schÃ¼tzt die PrimÃ¤rbeziehung, Ã–ffnungen erfolgen im Rahmen.",
                        type2Perspective: "Ethik behandelt alle Partner gleich, ohne Vorrang einer Beziehung.",
                        dynamic: "Schutzethik vs. Gleichheitsethik - verschiedene ethische PrioritÃ¤ten."
                    },
                    "verantwortungsbewusstsein": {
                        type1Perspective: "HÃ¶chste Verantwortung gegenÃ¼ber dem PrimÃ¤rpartner, dann anderen.",
                        type2Perspective: "Gleiche Verantwortung gegenÃ¼ber allen Partnern, kein 'mehr' oder 'weniger'.",
                        dynamic: "Gestufte vs. gleiche Verantwortung - kann zu MissverstÃ¤ndnissen fÃ¼hren."
                    }
                },
                "C": {
                    "emotionale-verschmelzungs-tendenz": {
                        type1Perspective: "Emotionale Verschmelzung primÃ¤r mit dem Hauptpartner.",
                        type2Perspective: "Solopoly meidet Verschmelzung bewusst, um Autonomie zu bewahren.",
                        dynamic: "Selektive Verschmelzung vs. generelle Distanz - verschiedene NÃ¤he-Strategien."
                    },
                    "physische-naehe-beduerfnisse": {
                        type1Perspective: "Physische NÃ¤he hauptsÃ¤chlich mit PrimÃ¤rpartner, situativ mit anderen.",
                        type2Perspective: "Physische NÃ¤he gleichmÃ¤ÃŸig verteilt, kein 'Zuhause' bei einem Partner.",
                        dynamic: "Zentrierte vs. verteilte IntimitÃ¤t - verschiedene NÃ¤he-Modelle."
                    },
                    "faehigkeit-raum-zu-geben": {
                        type1Perspective: "Raum wird innerhalb der PrimÃ¤rbeziehung verhandelt.",
                        type2Perspective: "Raum ist strukturell gegeben durch separate LebensrÃ¤ume.",
                        dynamic: "Verhandelter vs. struktureller Raum - Solopoly hat mehr eingebaute Distanz."
                    }
                },
                "D": {
                    "individuelle-freiheit": {
                        type1Perspective: "Freiheit innerhalb der PrimÃ¤rbeziehungs-Struktur.",
                        type2Perspective: "Maximale individuelle Freiheit als Grundprinzip des Lebens.",
                        dynamic: "Gerahmte vs. maximale Freiheit - verschiedene Autonomie-Level."
                    },
                    "entscheidungsautonomie": {
                        type1Perspective: "Wichtige Entscheidungen mit PrimÃ¤rpartner, aber mehr Freiraum als Duo.",
                        type2Perspective: "Volle Entscheidungsautonomie, Transparenz statt Absprache.",
                        dynamic: "Abgestimmte vs. informierte Autonomie - verschiedene Entscheidungsprozesse."
                    },
                    "akzeptanz-der-autonomie-des-anderen": {
                        type1Perspective: "Autonomie wird akzeptiert, solange die PrimÃ¤rbeziehung PrioritÃ¤t bleibt.",
                        type2Perspective: "Autonomie wird bedingungslos akzeptiert - keine Hierarchie-Erwartung.",
                        dynamic: "Bedingte vs. bedingungslose Autonomie-Akzeptanz."
                    }
                },
                "E": {
                    "kommunikationstiefe": {
                        type1Perspective: "Tiefe Kommunikation mit PrimÃ¤rpartner Ã¼ber alle Aspekte.",
                        type2Perspective: "Situative Kommunikationstiefe je nach Beziehung und Bedarf.",
                        dynamic: "Zentrierte vs. verteilte Kommunikationstiefe."
                    },
                    "konfliktfaehigkeit": {
                        type1Perspective: "Konflikte primÃ¤r im Kontext der Hauptbeziehung lÃ¶sen.",
                        type2Perspective: "Konflikte individuell mit jedem Partner, ohne zentrale Instanz.",
                        dynamic: "Zentralisierte vs. dezentralisierte KonfliktlÃ¶sung."
                    },
                    "emotionale-transparenz": {
                        type1Perspective: "Volle Transparenz gegenÃ¼ber PrimÃ¤rpartner, selektiv gegenÃ¼ber anderen.",
                        type2Perspective: "GleichmÃ¤ÃŸige Transparenz gegenÃ¼ber allen Partnern.",
                        dynamic: "Gestufte vs. gleiche Transparenz - verschiedene InformationsflÃ¼sse."
                    }
                },
                "F": {
                    "gesellschaftliche-akzeptanz": {
                        type1Perspective: "Duo-Flex kann als 'offene Ehe' noch relativ akzeptiert werden.",
                        type2Perspective: "Solopoly ist schwer zu erklÃ¤ren und wird oft missverstanden.",
                        dynamic: "Relativ akzeptiert vs. erklÃ¤rungsbedÃ¼rftig - verschiedene soziale Positionen."
                    },
                    "integration-in-soziale-kreise": {
                        type1Perspective: "PrimÃ¤rpaar wird integriert, Zusatzkontakte bleiben oft privat.",
                        type2Perspective: "Alle Beziehungen gleichwertig in soziale Kreise integrieren ist komplex.",
                        dynamic: "Einfachere vs. komplexere soziale Integration."
                    },
                    "umgang-mit-stigma": {
                        type1Perspective: "Mildes Stigma, wenn Ã–ffnung bekannt wird.",
                        type2Perspective: "StÃ¤rkeres Stigma durch unkonventionelle Lebensform ohne 'Hauptpartner'.",
                        dynamic: "Verschiedene Stigma-Level - Solopoly ist gesellschaftlich unbekannter."
                    }
                }
            },
            // Polyamor Ã— Polyamor (hohe KompatibilitÃ¤t - Test)
            "polyamor-polyamor": {
                "A": {
                    "exklusivitaets-erwartung": {
                        type1Perspective: "Keine ExklusivitÃ¤ts-Erwartung, Liebe wird als nicht-begrenzt verstanden.",
                        type2Perspective: "Gleiche Grundhaltung: Liebe zu mehreren Menschen ist mÃ¶glich und ethisch.",
                        dynamic: "Volle Ãœbereinstimmung: Beide verstehen und leben nicht-exklusive Liebe."
                    },
                    "offenheit-fuer-alternative-modelle": {
                        type1Perspective: "Lebt aktiv ein alternatives Beziehungsmodell.",
                        type2Perspective: "Teilt diese LebensrealitÃ¤t und die damit verbundenen Werte.",
                        dynamic: "Maximale Synergie: Beide haben den gleichen Referenzrahmen fÃ¼r Beziehungen."
                    },
                    "beziehung-als-lebensinhalt-vs-lebensbereich": {
                        type1Perspective: "Beziehungen sind zentraler Lebensinhalt, aber als Netzwerk.",
                        type2Perspective: "Versteht und teilt diese Beziehungsarchitektur vollstÃ¤ndig.",
                        dynamic: "Geteiltes VerstÃ¤ndnis: Beziehungsnetzwerk als gemeinsamer Lebensraum."
                    }
                },
                "B": {
                    "definition-von-treue": {
                        type1Perspective: "Treue = Ehrlichkeit, Transparenz, Einhalten von Agreements.",
                        type2Perspective: "Gleiche Definition von Treue, ohne ExklusivitÃ¤tskomponente.",
                        dynamic: "Ãœbereinstimmung bei einem der kritischsten Beziehungskonzepte."
                    },
                    "ethische-grundhaltung": {
                        type1Perspective: "Ethik basiert auf Konsens, Kommunikation und Respekt.",
                        type2Perspective: "Teilt diese ethischen Grundlagen und praktiziert sie aktiv.",
                        dynamic: "Gemeinsame ethische Basis erleichtert Verhandlungen und Absprachen."
                    },
                    "verantwortungsbewusstsein": {
                        type1Perspective: "Verantwortung fÃ¼r ein Netzwerk von Beziehungen und GefÃ¼hlen.",
                        type2Perspective: "Versteht diese KomplexitÃ¤t und trÃ¤gt sie mit.",
                        dynamic: "Geteilte Erfahrung mit der KomplexitÃ¤t polyamorer Verantwortung."
                    }
                },
                "C": {
                    "emotionale-verschmelzungs-tendenz": {
                        type1Perspective: "Emotionale Tiefe mit mehreren Menschen, bewusst dosiert.",
                        type2Perspective: "Gleiche Erfahrung und Kompetenz im Umgang mit verteilter IntimitÃ¤t.",
                        dynamic: "Beide verstehen, wie Tiefe in einem Poly-Kontext funktioniert."
                    },
                    "physische-naehe-beduerfnisse": {
                        type1Perspective: "Physische NÃ¤he verteilt sich auf mehrere Partner.",
                        type2Perspective: "Akzeptiert und praktiziert geteilte IntimitÃ¤t.",
                        dynamic: "Keine Eifersucht auf physische NÃ¤he mit anderen - geteilte Norm."
                    },
                    "faehigkeit-raum-zu-geben": {
                        type1Perspective: "Raum fÃ¼r andere Beziehungen ist selbstverstÃ¤ndlich.",
                        type2Perspective: "Erwartet und gibt gleichermaÃŸen Raum fÃ¼r das Beziehungsnetzwerk.",
                        dynamic: "Strukturelle Ãœbereinstimmung: Beide brauchen und geben Beziehungs-Raum."
                    }
                },
                "D": {
                    "individuelle-freiheit": {
                        type1Perspective: "Freiheit fÃ¼r mehrere Liebesbeziehungen als Grundrecht.",
                        type2Perspective: "Teilt dieses FreiheitsverstÃ¤ndnis vollstÃ¤ndig.",
                        dynamic: "Keine EinschrÃ¤nkung der romantischen Freiheit - beidseitiges VerstÃ¤ndnis."
                    },
                    "entscheidungsautonomie": {
                        type1Perspective: "Autonomie bei Beziehungsentscheidungen, mit Transparenzpflicht.",
                        type2Perspective: "Gleiche Balance zwischen Autonomie und Verantwortung.",
                        dynamic: "Geteilte Entscheidungskultur: Autonom, aber transparent."
                    },
                    "akzeptanz-der-autonomie-des-anderen": {
                        type1Perspective: "Volle Akzeptanz der Beziehungsfreiheit des Partners.",
                        type2Perspective: "Erwartet und praktiziert die gleiche Akzeptanz.",
                        dynamic: "Wechselseitige Autonomie-Akzeptanz als Fundament der Beziehung."
                    }
                },
                "E": {
                    "kommunikationstiefe": {
                        type1Perspective: "Tiefe Kommunikation als Kernkompetenz polyanorer Beziehungen.",
                        type2Perspective: "Bringt gleiche KommunikationsfÃ¤higkeiten und -erwartungen mit.",
                        dynamic: "Hohe Kommunikationskompetenz auf beiden Seiten - ideale Voraussetzung."
                    },
                    "konfliktfaehigkeit": {
                        type1Perspective: "Erfahrung mit komplexen, multilateralen Konflikten.",
                        type2Perspective: "Teilt diese Erfahrung und die entwickelten LÃ¶sungsstrategien.",
                        dynamic: "Beide sind 'Poly-geprÃ¼ft' in Konfliktsituationen - groÃŸe Resilienz."
                    },
                    "emotionale-transparenz": {
                        type1Perspective: "Maximale Transparenz als ethische Grundlage.",
                        type2Perspective: "Gleiche Transparenz-Erwartung und -Praxis.",
                        dynamic: "Keine versteckten Emotionen, keine versteckten Beziehungen - klare Basis."
                    }
                },
                "F": {
                    "gesellschaftliche-akzeptanz": {
                        type1Perspective: "Muss mit gesellschaftlicher Stigmatisierung umgehen.",
                        type2Perspective: "Teilt diese Erfahrung und die entwickelten Coping-Strategien.",
                        dynamic: "Gemeinsame AuÃŸenseiter-Position kann verbinden und stÃ¤rken."
                    },
                    "integration-in-soziale-kreise": {
                        type1Perspective: "Komplexe Beziehungsstrukturen in soziale Kontexte einbringen.",
                        type2Perspective: "Versteht und teilt diese Herausforderung.",
                        dynamic: "Gegenseitige UnterstÃ¼tzung bei sozialer Navigation."
                    },
                    "umgang-mit-stigma": {
                        type1Perspective: "Aktiver Umgang mit Vorurteilen und Diskriminierung.",
                        type2Perspective: "Teilt diese Erfahrung und die Resilienz-Strategien.",
                        dynamic: "Gemeinsame StÃ¤rke gegen gesellschaftlichen Druck."
                    }
                }
            },
            // Duo Ã— Duo (hohe KompatibilitÃ¤t - Test)
            "duo-duo": {
                "A": {
                    "exklusivitaets-erwartung": {
                        type1Perspective: "ExklusivitÃ¤t als fundamentaler Ausdruck von Liebe.",
                        type2Perspective: "Teilt dieses VerstÃ¤ndnis von ExklusivitÃ¤t vollstÃ¤ndig.",
                        dynamic: "Perfekte Ãœbereinstimmung: Beide verstehen und wÃ¼nschen ExklusivitÃ¤t."
                    },
                    "offenheit-fuer-alternative-modelle": {
                        type1Perspective: "Bevorzugt das klassische Zweiermodell.",
                        type2Perspective: "Gleiche PrÃ¤ferenz fÃ¼r monogame Partnerschaft.",
                        dynamic: "Geteilte WertschÃ¤tzung fÃ¼r traditionelles Beziehungsmodell."
                    },
                    "beziehung-als-lebensinhalt-vs-lebensbereich": {
                        type1Perspective: "Die Partnerschaft ist zentraler Lebensinhalt.",
                        type2Perspective: "Teilt diese Priorisierung der Beziehung.",
                        dynamic: "Gemeinsames 'Wir' als Lebensmittelpunkt - perfekte Synergie."
                    }
                },
                "B": {
                    "definition-von-treue": {
                        type1Perspective: "Treue = exklusive emotionale und sexuelle Bindung.",
                        type2Perspective: "Gleiche Definition, gleiche Erwartung.",
                        dynamic: "Keine Definitions-Konflikte bei diesem zentralen Thema."
                    },
                    "ethische-grundhaltung": {
                        type1Perspective: "Ethik basiert auf Versprechen und Verbindlichkeit.",
                        type2Perspective: "Teilt diese ethischen Grundwerte.",
                        dynamic: "Gemeinsame ethische Basis fÃ¼r eine stabile Partnerschaft."
                    },
                    "verantwortungsbewusstsein": {
                        type1Perspective: "Fokussierte Verantwortung fÃ¼reinander.",
                        type2Perspective: "Gleiche Verantwortungsbereitschaft.",
                        dynamic: "Gegenseitige, konzentrierte Verantwortung - klare Struktur."
                    }
                },
                "C": {
                    "emotionale-verschmelzungs-tendenz": {
                        type1Perspective: "WÃ¼nscht tiefe emotionale Verschmelzung.",
                        type2Perspective: "Teilt dieses BedÃ¼rfnis nach NÃ¤he und Verbundenheit.",
                        dynamic: "Beidseitiges Streben nach emotionaler Tiefe."
                    },
                    "physische-naehe-beduerfnisse": {
                        type1Perspective: "Physische NÃ¤he exklusiv mit dem Partner.",
                        type2Perspective: "Gleiche ExklusivitÃ¤ts-Erwartung bei IntimitÃ¤t.",
                        dynamic: "Keine Konkurrenz um NÃ¤he - ungeteilte Aufmerksamkeit."
                    },
                    "faehigkeit-raum-zu-geben": {
                        type1Perspective: "Raum innerhalb der Partnerschaft.",
                        type2Perspective: "Gleiche Balance zwischen NÃ¤he und individuellem Raum.",
                        dynamic: "Ã„hnliche Raum-BedÃ¼rfnisse erleichtern das Zusammenleben."
                    }
                },
                "D": {
                    "individuelle-freiheit": {
                        type1Perspective: "Freiheit wird gemeinsam als Paar definiert.",
                        type2Perspective: "Teilt dieses VerstÃ¤ndnis von Paar-Freiheit.",
                        dynamic: "Gemeinsame Freiheits-Definition als 'Wir'."
                    },
                    "entscheidungsautonomie": {
                        type1Perspective: "Wichtige Entscheidungen gemeinsam treffen.",
                        type2Perspective: "Gleiche Erwartung an gemeinsame Entscheidungsfindung.",
                        dynamic: "Geteilte Entscheidungsmacht ohne Autonomie-Konflikte."
                    },
                    "akzeptanz-der-autonomie-des-anderen": {
                        type1Perspective: "Autonomie innerhalb des Paar-Rahmens.",
                        type2Perspective: "Gleiche Balance zwischen IndividualitÃ¤t und Partnerschaft.",
                        dynamic: "Ã„hnliche Autonomie-Grenzen erleichtern das Zusammenleben."
                    }
                },
                "E": {
                    "kommunikationstiefe": {
                        type1Perspective: "Tiefe Kommunikation zu zweit.",
                        type2Perspective: "Gleicher Wunsch nach intensivem Austausch.",
                        dynamic: "Fokussierte, tiefe Kommunikation ohne Verteilung."
                    },
                    "konfliktfaehigkeit": {
                        type1Perspective: "Konflikte werden zu zweit gelÃ¶st.",
                        type2Perspective: "Gleiche Erwartung an bilaterale KonfliktlÃ¶sung.",
                        dynamic: "Klare Konflikt-Struktur ohne externe KomplexitÃ¤t."
                    },
                    "emotionale-transparenz": {
                        type1Perspective: "Volle Transparenz gegenÃ¼ber dem Partner.",
                        type2Perspective: "Gleiche Transparenz-Erwartung und -Bereitschaft.",
                        dynamic: "Gegenseitige Offenheit ohne konkurrierende LoyalitÃ¤ten."
                    }
                },
                "F": {
                    "gesellschaftliche-akzeptanz": {
                        type1Perspective: "Volle gesellschaftliche Akzeptanz.",
                        type2Perspective: "Teilt diese privilegierte Position.",
                        dynamic: "Keine externen HÃ¼rden durch gesellschaftliche Normen."
                    },
                    "integration-in-soziale-kreise": {
                        type1Perspective: "Als Paar problemlos integriert.",
                        type2Perspective: "Gleiche einfache soziale Integration.",
                        dynamic: "Gesellschaftliche NormalitÃ¤t als gemeinsame Basis."
                    },
                    "umgang-mit-stigma": {
                        type1Perspective: "Kein Stigma, sondern gesellschaftliche UnterstÃ¼tzung.",
                        type2Perspective: "Teilt diese Stigma-freie Erfahrung.",
                        dynamic: "Kein externer Druck - Fokus auf die Beziehung selbst."
                    }
                }
            }
        };

        // Helper function to normalize tag names for lookup
        function normalizeTagName(tag) {
            return tag.toLowerCase()
                .replace(/Ã¤/g, 'ae').replace(/Ã¶/g, 'oe').replace(/Ã¼/g, 'ue').replace(/ÃŸ/g, 'ss')
                .replace(/[^a-z0-9]/g, '-')
                .replace(/-+/g, '-')
                .replace(/^-|-$/g, '');
        }

        // Get tooltip content for a specific tag
        function getTagTooltip(type1Id, type2Id, category, tagName) {
            const normalizedTag = normalizeTagName(tagName);

            // Sort type IDs alphabetically for consistent key lookup
            const sortedTypes = [type1Id, type2Id].sort();
            const comboKey = sortedTypes.join('-');

            // Try to find specific tooltip
            const comboData = tagTooltipContent[comboKey];
            if (comboData && comboData[category] && comboData[category][normalizedTag]) {
                const tooltip = comboData[category][normalizedTag];
                const type1 = data.archetypes[type1Id];
                const type2 = data.archetypes[type2Id];

                // Swap perspectives if types were reordered
                if (sortedTypes[0] === type2Id) {
                    return {
                        type1Name: type1?.name || type1Id,
                        type2Name: type2?.name || type2Id,
                        type1Perspective: tooltip.type2Perspective,
                        type2Perspective: tooltip.type1Perspective,
                        dynamic: tooltip.dynamic
                    };
                }

                return {
                    type1Name: type1?.name || type1Id,
                    type2Name: type2?.name || type2Id,
                    type1Perspective: tooltip.type1Perspective,
                    type2Perspective: tooltip.type2Perspective,
                    dynamic: tooltip.dynamic
                };
            }

            // Fallback: Generate generic tooltip
            return generateFallbackTooltip(type1Id, type2Id, category, tagName);
        }

        // Generate fallback tooltip when no specific content exists
        function generateFallbackTooltip(type1Id, type2Id, category, tagName) {
            const type1 = data.archetypes[type1Id];
            const type2 = data.archetypes[type2Id];
            const type1Def = archetypeDescriptions[type1Id];
            const type2Def = archetypeDescriptions[type2Id];

            const interactionKey = `${type1Id}_${type2Id}`;
            const interaction = data.interactions[interactionKey] || {};
            const scores = interaction.scores || {};
            const catScore = scores[category]?.value || 50;

            // Generate context-aware fallback
            let dynamicText = '';
            if (catScore >= 85) {
                dynamicText = `Hohe Ãœbereinstimmung (${catScore}) in diesem Bereich - beide Typen haben Ã¤hnliche AnsÃ¤tze.`;
            } else if (catScore >= 70) {
                dynamicText = `Moderate Ãœbereinstimmung (${catScore}) - einige gemeinsame Grundlagen, aber auch Unterschiede.`;
            } else if (catScore >= 50) {
                dynamicText = `Mittlere BeziehungsqualitÃ¤t (${catScore}) - deutliche Unterschiede, die Kompromisse erfordern.`;
            } else {
                dynamicText = `Herausfordernde Konstellation (${catScore}) - grundlegend verschiedene AnsÃ¤tze in diesem Bereich.`;
            }

            return {
                type1Name: type1?.name || type1Id,
                type2Name: type2?.name || type2Id,
                type1Perspective: type1Def?.keyPrinciples?.[0] || `${type1?.name || type1Id} hat eigene PrÃ¤ferenzen in diesem Bereich.`,
                type2Perspective: type2Def?.keyPrinciples?.[0] || `${type2?.name || type2Id} hat eigene PrÃ¤ferenzen in diesem Bereich.`,
                dynamic: dynamicText
            };
        }

        // Category descriptions loaded from data
        let categoryDescriptions = {};

        async function loadData() {
            try {
                const response = await fetch('archetype-matrix.json');
                const rawData = await response.json();

                // Transform archetypes from #A1-#A8 keys to key names (single, duo, etc.)
                if (rawData.archetypes) {
                    const transformedArchetypes = {};
                    for (const [id, archetype] of Object.entries(rawData.archetypes)) {
                        const key = archetype.key || id;
                        // Normalize id property to match the key for consistency
                        archetype.id = key;
                        transformedArchetypes[key] = archetype;
                    }
                    rawData.archetypes = transformedArchetypes;
                }

                // Transform dimensions from #D1-#D6 keys to key names (A, B, C, etc.)
                // Also support legacy 'categories' field
                if (rawData.dimensions) {
                    const transformedDimensions = {};
                    for (const [id, dimension] of Object.entries(rawData.dimensions)) {
                        const key = dimension.key || id;
                        // Normalize id property to match the key for consistency
                        dimension.id = key;
                        transformedDimensions[key] = dimension;
                    }
                    rawData.categories = transformedDimensions;
                }

                data = rawData;

                // Load category descriptions from data
                if (data.categories) {
                    categoryDescriptions = data.categories;
                }
            } catch (error) {
                console.error('Error loading data:', error);
                data = getFallbackData();
            }
            initApp();
        }

        function getFallbackData() {
            return {
                archetypes: {
                    single: { id: "single", name: "Single", color: "#E63946", shortDescription: "Fokus auf Selbstentwicklung", pro: [], contra: [], pathos: "", logos: "" },
                    duo: { id: "duo", name: "Duo", color: "#E84393", shortDescription: "Klassische monogame Zweierbeziehung", pro: [], contra: [], pathos: "", logos: "" },
                    duo_flex: { id: "duo_flex", name: "Duo-Flex", color: "#FF6B6B", shortDescription: "PrimÃ¤r Zweierbeziehung mit situativer Ã–ffnung", pro: [], contra: [], pathos: "", logos: "" },
                    solopoly: { id: "solopoly", name: "Solopoly", color: "#2A9D8F", shortDescription: "Polyamor mit Autonomie", pro: [], contra: [], pathos: "", logos: "" },
                    polyamor: { id: "polyamor", name: "Polyamor", color: "#F4A261", shortDescription: "Strukturierte Mehrfachbeziehungen", pro: [], contra: [], pathos: "", logos: "" },
                    ra: { id: "ra", name: "RA", color: "#9B5DE5", shortDescription: "RA - Ablehnung von Labels", pro: [], contra: [], pathos: "", logos: "" },
                    lat: { id: "lat", name: "LAT", color: "#06D6A0", shortDescription: "Living Apart Together", pro: [], contra: [], pathos: "", logos: "" },
                    aromantisch: { id: "aromantisch", name: "Aromantisch", color: "#118AB2", shortDescription: "Platonische Verbindungen", pro: [], contra: [], pathos: "", logos: "" }
                },
                categories: {},
                interactions: {},
                aggregatedMatrix: { rows: [], cols: [], values: [] }
            };
        }

        function initApp() {
            const archetypeSelect = document.getElementById('archetypeSelect');
            if (archetypeSelect) {
                archetypeSelect.addEventListener('change', (e) => {
                    currentArchetype = e.target.value;
                    mobileIchArchetype = e.target.value;
                    // Sync with TiageState for save/load
                    if (typeof TiageState !== 'undefined') {
                        TiageState.setArchetype('ich', e.target.value);
                    }
                    updateAll();
                });
            }

            // Carousel scroll detection
            const carousel = document.getElementById('carousel');
            if (carousel) {
                carousel.addEventListener('scroll', updateNavDots);
            }

            // Initialize dimension info link event listeners
            initDimensionInfoLinks();

            // Initialize Philosophy Greeting Hints (0a or 0b)
            initGreetingHint();

            updateAll();
        }

        /**
         * Initialize Philosophy Greeting Hints
         * Shows Moment 0a for new users, Moment 0b for returning users
         * Displays as centered popup modal controlled by global moments toggle
         */
        function initGreetingHint() {
            // Check if PhilosophyHints is available
            if (typeof PhilosophyHints === 'undefined' || typeof PhilosophyHint === 'undefined') {
                console.warn('[PhilosophyHints] Components not loaded');
                return;
            }

            // Check if moments are globally enabled
            if (!PhilosophyHints.areMomentsEnabled()) {
                console.log('[PhilosophyHints] Moments disabled - skipping greeting hint');
                return;
            }

            // Check if user has an existing profile (locked needs indicate engagement)
            const savedState = localStorage.getItem('tiage_state');
            let hasExistingProfile = false;

            if (savedState) {
                try {
                    const state = JSON.parse(savedState);
                    // Check for locked needs or AGOD selections as indicator of profile
                    const ichLocked = state.profileReview?.ich?.lockedNeeds;
                    const hasLockedNeeds = ichLocked && Object.keys(ichLocked).length > 0;
                    const hasAGOD = state.personDimensions?.ich?.archetyp?.primary;
                    hasExistingProfile = hasLockedNeeds || hasAGOD;
                } catch (e) {
                    console.warn('[PhilosophyHints] Could not parse saved state');
                }
            }

            // Create appropriate greeting hint (without dismissable option - controlled via global toggle)
            let hintElement;
            if (hasExistingProfile) {
                // Moment 0b: Returning user
                hintElement = PhilosophyHints.createMoment0bReturning({
                    dismissable: false,
                    onExpand: function(id) {
                        if (typeof HintState !== 'undefined') {
                            HintState.trackHintEvent('expanded', id);
                        }
                    }
                });
            } else {
                // Moment 0a: New user / Landing
                hintElement = PhilosophyHints.createMoment0aLanding({
                    dismissable: false,
                    onExpand: function(id) {
                        if (typeof HintState !== 'undefined') {
                            HintState.trackHintEvent('expanded', id);
                        }
                    }
                });
            }

            // Show as centered popup modal
            PhilosophyHint.showModal(hintElement, {
                onClose: function() {
                    if (typeof HintState !== 'undefined') {
                        HintState.trackHintEvent('closed', hasExistingProfile ? 'moment-0b-returning' : 'moment-0a-landing');
                    }
                }
            });
        }

        /**
         * Initialize event listeners for dimension info links
         * Uses CSS classes instead of onclick attributes for cleaner code
         */
        function initDimensionInfoLinks() {
            // GeschlechtsidentitÃ¤t links
            document.querySelectorAll('.geschlecht-info-link').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showGeschlechtInfoModal();
                });
            });

            // Dominanz links
            document.querySelectorAll('.dominanz-info-link').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showDominanzInfoModal();
                });
            });

            // Orientierung links
            document.querySelectorAll('.orientierung-info-link').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showOrientierungInfoModal();
                });
            });

            // GFK links
            document.querySelectorAll('.gfk-info-link').forEach(el => {
                el.addEventListener('click', (e) => {
                    e.stopPropagation();
                    showDimensionTooltip('gfk');
                });
            });
        }

        function updateAll() {
            // Guard: Don't update UI if data not loaded yet
            if (!data || !data.archetypes) {
                console.warn('[TIAGE] updateAll called before data loaded - skipping');
                return;
            }
            updateTheme();
            updateMyType();
            updatePartnerSelector();
            updateTopAndChallenge();
            updatePartnerView();
            updateLegendCategories();
            updateAnalysisOverview();
            updateComparisonView(); // Trigger score calculation and UI update
            // GFK automatisch aus Archetypen-Matching ableiten
            if (typeof updateGfkFromArchetypes === 'function') {
                updateGfkFromArchetypes();
            }
        }

        function updateTheme() {
            document.body.className = `theme-${currentArchetype}`;
        }

        function updateMyType() {
            // Guard against data not being loaded yet
            if (!data || !data.archetypes) {
                console.warn('[TIAGE] updateMyType called before data loaded');
                return;
            }
            const arch = data.archetypes[currentArchetype];
            if (!arch) return;

            const myTypeIcon = document.getElementById('myTypeIcon');
            if (myTypeIcon) {
                myTypeIcon.textContent = icons[currentArchetype];
                myTypeIcon.style.background = arch.color;
            }

            const myTypeName = document.getElementById('myTypeName');
            if (myTypeName) {
                myTypeName.textContent = arch.name;
                myTypeName.style.color = arch.color;
            }

            const myTypeDesc = document.getElementById('myTypeDesc');
            if (myTypeDesc) myTypeDesc.textContent = arch.shortDescription || '';

            const myTypeTooltip = document.getElementById('myTypeTooltip');
            if (myTypeTooltip) myTypeTooltip.textContent = getShortDef(currentArchetype);

            const proList = document.getElementById('myTypePro');
            if (proList) proList.innerHTML = (arch.pro || []).slice(0, 4).map(p => `<li>${p}</li>`).join('');

            const contraList = document.getElementById('myTypeContra');
            if (contraList) contraList.innerHTML = (arch.contra || []).slice(0, 4).map(c => `<li>${c}</li>`).join('');

            const myTypePathos = document.getElementById('myTypePathos');
            if (myTypePathos) myTypePathos.textContent = arch.pathos || '';

            const myTypeLogos = document.getElementById('myTypeLogos');
            if (myTypeLogos) myTypeLogos.textContent = arch.logos || '';
        }

        // Fixed archetype order to ensure all types are shown
        const archetypeOrder = ['single', 'duo', 'duo_flex', 'solopoly', 'polyamor', 'ra', 'lat', 'aromantisch'];

        function updatePartnerSelector() {
            const container = document.getElementById('partnerSelector');
            // Show ALL archetypes as partner options (including own type for self-matching)
            const allPartners = archetypeOrder
                .map(id => data.archetypes[id])
                .filter(arch => arch); // Remove any undefined

            if (!allPartners.find(o => o.id === selectedPartner)) {
                selectedPartner = allPartners[0]?.id || 'duo';
            }

            container.innerHTML = allPartners.map(arch => `
                <button class="partner-btn ${arch.id === selectedPartner ? 'active' : ''}"
                        onclick="selectPartner('${arch.id}')"
                        data-id="${arch.id}">
                    <span class="dot" style="background: ${arch.color}"></span>
                    ${arch.name}
                </button>
            `).join('');
        }

        function selectPartner(partnerId) {
            selectedPartner = partnerId;
            mobilePartnerArchetype = partnerId;

            // Sync with TiageState for persistence
            if (typeof TiageState !== 'undefined') {
                TiageState.setArchetype('partner', partnerId);
            }

            // Sync select dropdowns
            const partnerSelect = document.getElementById('partnerSelect');
            const mobilePartnerSelect = document.getElementById('mobilePartnerSelect');
            if (partnerSelect) partnerSelect.value = partnerId;
            if (mobilePartnerSelect) mobilePartnerSelect.value = partnerId;

            // Sync archetype grid highlighting
            updateArchetypeGrid('partner', partnerId);

            document.querySelectorAll('.partner-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.id === partnerId);
            });
            updatePartnerView();
            updateAnalysisOverview();
            updateComparisonView(); // Trigger score calculation and UI update
        }

        function updateTopAndChallenge() {
            // Include all types (including self) for top match and challenge
            const others = archetypeOrder;
            let topMatch = { id: null, score: 0 };
            let challenge = { id: null, score: 100 };

            others.forEach(otherId => {
                const key = `${currentArchetype}_${otherId}`;
                const interaction = data.interactions[key];
                const score = interaction?.overall || 0;

                if (score > topMatch.score) {
                    topMatch = { id: otherId, score };
                }
                if (score < challenge.score) {
                    challenge = { id: otherId, score };
                }
            });

            // Store for modal access
            currentTopMatch = topMatch;
            currentChallenge = challenge;

            const myArch = data.archetypes[currentArchetype];

            if (topMatch.id) {
                const arch = data.archetypes[topMatch.id];
                if (arch) {
                    document.getElementById('topMatchDot').style.background = arch.color;
                    document.getElementById('topMatchName').textContent = `${myArch?.name || 'Ich'} (Ich) mit ${arch.name}`;
                    document.getElementById('topMatchScore').textContent = topMatch.score;
                }
            }

            if (challenge.id) {
                const arch = data.archetypes[challenge.id];
                if (arch) {
                    document.getElementById('challengeDot').style.background = arch.color;
                    document.getElementById('challengeName').textContent = `${myArch?.name || 'Ich'} (Ich) mit ${arch.name}`;
                    document.getElementById('challengeScore').textContent = challenge.score;
                }
            }
        }

        function updatePartnerView() {
            const myArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[selectedPartner];
            const interactionKey = `${currentArchetype}_${selectedPartner}`;
            const interaction = data.interactions[interactionKey] || {};

            // Run Pathos/Logos checks (keine Blockierung mehr - zeigt nur Warnungen)
            runCompatibilityChecks();

            // NEU: GFK-BedÃ¼rfnis-Matching mit allen Dimensionen neu berechnen
            updateGfkFromArchetypes();

            document.getElementById('myTypeNameDisplay').textContent = myArch?.name || '...';
            document.getElementById('partnerNameDisplay').textContent = partnerArch?.name || '...';
            document.getElementById('myTypeTooltipPage3').textContent = getShortDef(currentArchetype);
            document.getElementById('partnerTooltipPage3').textContent = getShortDef(selectedPartner);

            const score = interaction.overall || 0;
            const scoreEl = document.getElementById('overallScore');
            scoreEl.textContent = score;
            scoreEl.style.color = getScoreColor(score);

            drawRadarChart(interaction.scores || {}, partnerArch?.color || '#457B9D');
            updateCategoryBars(interaction.scores || {});

            const proList = document.getElementById('partnerPro');
            proList.innerHTML = (interaction.pro || []).map(p => `<li>${p}</li>`).join('') || '<li>Keine Daten</li>';

            const contraList = document.getElementById('partnerContra');
            contraList.innerHTML = (interaction.contra || []).map(c => `<li>${c}</li>`).join('') || '<li>Keine Daten</li>';
        }

        function drawRadarChart(scores, color) {
            const svg = document.getElementById('radarChart');
            const cx = 140, cy = 120, maxR = 90;
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            const n = categories.length;

            let html = '';

            for (let r = 18; r <= maxR; r += 18) {
                html += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="none" stroke="rgba(255,255,255,0.08)" stroke-width="1"/>`;
            }

            categories.forEach((cat, i) => {
                const angle = (Math.PI * 2 * i / n) - Math.PI / 2;
                const x = cx + Math.cos(angle) * maxR;
                const y = cy + Math.sin(angle) * maxR;
                const labelX = cx + Math.cos(angle) * (maxR + 18);
                const labelY = cy + Math.sin(angle) * (maxR + 18);

                html += `<line x1="${cx}" y1="${cy}" x2="${x}" y2="${y}" stroke="rgba(255,255,255,0.08)" stroke-width="1"/>`;
                html += `<text x="${labelX}" y="${labelY}" fill="var(--text-muted)" font-size="10" text-anchor="middle" dominant-baseline="middle">${cat}</text>`;
            });

            const points = categories.map((cat, i) => {
                const value = scores[cat]?.value || 0;
                const r = (value / 100) * maxR;
                const angle = (Math.PI * 2 * i / n) - Math.PI / 2;
                return `${cx + Math.cos(angle) * r},${cy + Math.sin(angle) * r}`;
            }).join(' ');

            html += `<polygon points="${points}" fill="${color}33" stroke="${color}" stroke-width="2"/>`;

            categories.forEach((cat, i) => {
                const value = scores[cat]?.value || 0;
                const r = (value / 100) * maxR;
                const angle = (Math.PI * 2 * i / n) - Math.PI / 2;
                const x = cx + Math.cos(angle) * r;
                const y = cy + Math.sin(angle) * r;
                html += `<circle cx="${x}" cy="${y}" r="4" fill="${color}"/>`;
            });

            if (svg) svg.innerHTML = html;

            // Also draw on expandRadarChart (smaller version)
            const expandSvg = document.getElementById('expandRadarChart');
            if (expandSvg) expandSvg.innerHTML = html;
        }

        function updateCategoryBars(scores) {
            const container = document.getElementById('categoryBars');
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];

            container.innerHTML = categories.map(cat => {
                const value = scores[cat]?.value || 0;
                const barClass = getBarClass(value);
                const name = categoryNames[cat] || cat;

                return `
                    <div class="category-row" onclick="openSingleCategoryModal('${cat}')">
                        <span class="category-label">${cat}</span>
                        <div class="category-bar-wrap">
                            <div class="category-bar-container">
                                <div class="category-bar ${barClass}" style="width: ${value}%">
                                    <span class="category-bar-value">${value}%</span>
                                </div>
                            </div>
                            <div class="category-name">${name}</div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function getScoreColor(score) {
            if (score >= 70) return '#457B9D';  // Blau - Gut
            if (score >= 50) return '#f39c12';  // Orange - Mittel
            return '#e74c3c';                   // Rot - Herausfordernd
        }

        // Farbverlauf fÃ¼r Score Cycle: rot (0%) â†’ gelb (50%) â†’ grÃ¼n (100%)
        function getScoreGradientColor(score) {
            // Clamp score between 0 and 100
            score = Math.max(0, Math.min(100, score));

            let r, g, b;

            if (score <= 50) {
                // Rot (0%) â†’ Gelb (50%)
                // Rot: rgb(231, 76, 60) â†’ Gelb: rgb(241, 196, 15)
                const t = score / 50;
                r = Math.round(231 + (241 - 231) * t);
                g = Math.round(76 + (196 - 76) * t);
                b = Math.round(60 + (15 - 60) * t);
            } else {
                // Gelb (50%) â†’ GrÃ¼n (100%)
                // Gelb: rgb(241, 196, 15) â†’ GrÃ¼n: rgb(46, 204, 113)
                const t = (score - 50) / 50;
                r = Math.round(241 + (46 - 241) * t);
                g = Math.round(196 + (204 - 196) * t);
                b = Math.round(15 + (113 - 15) * t);
            }

            return `rgb(${r}, ${g}, ${b})`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AGOD WEIGHT INPUTS - Gewichtung fÃ¼r Synthese Score
        // Speichert persistent in TiageState (Ã¼berlebt Reload)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Default weights (25% each = 100% total)
        const AGOD_DEFAULT_WEIGHTS = { O: 25, A: 25, D: 25, G: 25 };

        // Current weights state
        let agodWeights = { ...AGOD_DEFAULT_WEIGHTS };

        /**
         * Initialize AGOD weight inputs on page load
         * Loads from TiageState.paarung.gewichtungen (primary) or gewichtungen.ich (fallback)
         */
        function initAgodWeightInputs() {
            // Start with defaults
            agodWeights = { ...AGOD_DEFAULT_WEIGHTS };

            if (typeof TiageState !== 'undefined') {
                // Primary: Load from paarung.gewichtungen
                let stored = TiageState.get('paarung.gewichtungen');
                let source = 'paarung.gewichtungen';

                // Fallback: Load from gewichtungen.ich
                if (!stored || !stored.O) {
                    stored = TiageState.get('gewichtungen.ich');
                    source = 'gewichtungen.ich (fallback)';
                }

                console.log('[AGOD] Loading from TiageState:', source, JSON.stringify(stored));

                if (stored && stored.O && typeof stored.O === 'object' && 'value' in stored.O) {
                    const loadedWeights = {
                        O: stored.O.value ?? 25,
                        A: stored.A.value ?? 25,
                        D: stored.D.value ?? 25,
                        G: stored.G.value ?? 25
                    };

                    // Validation: Sum of 0 means invalid data
                    const sum = loadedWeights.O + loadedWeights.A + loadedWeights.D + loadedWeights.G;
                    if (sum > 0) {
                        agodWeights = loadedWeights;
                        console.log('[AGOD] Loaded valid weights:', agodWeights);
                    } else {
                        console.log('[AGOD] Invalid weights (sum=0), using defaults:', agodWeights);
                    }
                } else if (stored && typeof stored.O === 'number') {
                    // Legacy format
                    agodWeights = {
                        O: stored.O ?? 25,
                        A: stored.A ?? 25,
                        D: stored.D ?? 25,
                        G: stored.G ?? 25
                    };
                }
            }

            // Update input fields
            ['O', 'A', 'D', 'G'].forEach(factor => {
                const input = document.getElementById(`agodWeight${factor}`);
                if (input) {
                    input.value = agodWeights[factor];
                }
            });

            // Update visual bars
            updateAgodStickBars();

            // Update weight sum label
            updateAgodWeightSumLabel();

            // Also save to sessionStorage for synthesis
            saveAgodWeightsToSession();

            console.log('[AGOD] Weight inputs initialized:', agodWeights);
        }

        /**
         * Update AGOD weight when user changes input
         * Saves to paarung.gewichtungen (primary) and gewichtungen.ich/partner (backup)
         * @param {string} factor - O, A, D, or G
         * @param {string|number} value - New weight value (0-100)
         */
        function updateAgodWeight(factor, value) {
            // Parse and clamp value
            let numValue = parseInt(value) || 0;
            numValue = Math.max(0, Math.min(100, numValue));

            // Update state
            agodWeights[factor] = numValue;

            // Update input field (in case of clamping)
            const input = document.getElementById(`agodWeight${factor}`);
            if (input && parseInt(input.value) !== numValue) {
                input.value = numValue;
            }

            // Update visual bars
            updateAgodStickBars();

            // Update weight sum label
            updateAgodWeightSumLabel();

            // Save to sessionStorage (for synthesis)
            saveAgodWeightsToSession();

            // SSOT: Save to TiageState for persistence
            if (typeof TiageState !== 'undefined') {
                // Create gewichtungen object with all current values
                const gewData = {
                    O: { value: agodWeights.O, locked: false },
                    A: { value: agodWeights.A, locked: false },
                    D: { value: agodWeights.D, locked: false },
                    G: { value: agodWeights.G, locked: false },
                    summeLock: { enabled: false, target: 100 }
                };

                // Primary: Save to paarung.gewichtungen
                TiageState.set('paarung.gewichtungen', gewData);

                // Backup: Save to gewichtungen.ich and gewichtungen.partner
                TiageState.set('gewichtungen.ich', gewData);
                TiageState.set('gewichtungen.partner', gewData);

                TiageState.saveToStorage();
                console.log('[AGOD] Saved to TiageState (paarung + ich + partner):', factor, '=', numValue);
            }

            // Trigger synthesis recalculation
            if (typeof updateComparisonView === 'function') {
                updateComparisonView();
            }

            console.log('[AGOD] Weight updated:', factor, '=', numValue, '| Total:', getAgodWeightSum());
        }

        /**
         * Adjust AGOD weight by delta (for +/- buttons)
         * @param {string} factor - O, A, D, or G
         * @param {number} delta - Amount to add (positive) or subtract (negative)
         */
        function adjustAgodWeight(factor, delta) {
            const currentValue = agodWeights[factor] || 0;
            const newValue = Math.max(0, Math.min(100, currentValue + delta));
            updateAgodWeight(factor, newValue);
        }

        /**
         * Update visual height of stick bars based on weights
         */
        function updateAgodStickBars() {
            const maxHeight = 60; // Max bar height in pixels
            const maxWeight = 100;

            ['O', 'A', 'D', 'G'].forEach(factor => {
                const bar = document.getElementById(`agodStick${factor}`);
                if (bar) {
                    const weight = agodWeights[factor] || 0;
                    const height = (weight / maxWeight) * maxHeight;
                    bar.style.height = `${Math.max(4, height)}px`; // Min 4px for visibility
                    bar.style.opacity = weight > 0 ? 1 : 0.3;
                }
            });
        }

        /**
         * Get current AGOD weights as normalized decimals (sum to 1.0)
         * @returns {object} { orientierung, archetyp, dominanz, geschlecht }
         */
        function getAgodWeights() {
            const sum = getAgodWeightSum();
            const divisor = sum > 0 ? sum : 100; // Avoid division by zero

            return {
                orientierung: agodWeights.O / divisor,
                archetyp: agodWeights.A / divisor,
                dominanz: agodWeights.D / divisor,
                geschlecht: agodWeights.G / divisor
            };
        }

        /**
         * Get sum of all AGOD weights
         * @returns {number}
         */
        function getAgodWeightSum() {
            return agodWeights.O + agodWeights.A + agodWeights.D + agodWeights.G;
        }

        /**
         * Update the weight sum label in the UI
         */
        function updateAgodWeightSumLabel() {
            const sumLabel = document.getElementById('agod-weight-sum-label');
            if (sumLabel) {
                const sum = getAgodWeightSum();
                sumLabel.textContent = sum + '%';
                // Visual feedback: red if not 100%, normal otherwise
                sumLabel.style.color = sum === 100 ? '' : '#EF4444';
            }
        }

        /**
         * Save weights to TiageState (SSOT - persistent)
         * @param {string} person - 'ich' oder 'partner' (default: 'ich')
         */
        function saveAgodWeightsToSession(person) {
            person = person || 'ich';
            try {
                if (typeof TiageState !== 'undefined') {
                    const gewData = {
                        O: { value: agodWeights.O, locked: false },
                        A: { value: agodWeights.A, locked: false },
                        D: { value: agodWeights.D, locked: false },
                        G: { value: agodWeights.G, locked: false },
                        summeLock: { enabled: false, target: 100 }
                    };
                    TiageState.set(`gewichtungen.${person}`, gewData);
                    console.log(`[AGOD] Weights saved to TiageState (${person}):`, agodWeights);
                }
            } catch (e) {
                console.warn('[AGOD] Could not save to TiageState:', e);
            }
        }

        /**
         * Get weights from TiageState (SSOT - persistent)
         * @param {string} person - 'ich' oder 'partner' (default: 'ich')
         * @returns {object|null} { O, A, D, G }
         */
        function getAgodWeightsFromSession(person) {
            person = person || 'ich';
            try {
                if (typeof TiageState !== 'undefined') {
                    const stored = TiageState.get(`gewichtungen.${person}`);
                    if (stored && stored.O && typeof stored.O.value === 'number') {
                        return {
                            O: stored.O.value,
                            A: stored.A.value,
                            D: stored.D.value,
                            G: stored.G.value
                        };
                    }
                }
                return null;
            } catch (e) {
                console.warn('[AGOD] Could not read from TiageState:', e);
                return null;
            }
        }

        // Update Score Cycle im Synthese Modal und auf der Hauptseite
        function updateSyntheseScoreCycle() {
            const scoreValueEl = document.getElementById('syntheseScoreValue');
            const scoreProgressEl = document.getElementById('syntheseScoreProgress');
            const mainScoreValueEl = document.getElementById('mainScoreValue');
            const mainScoreProgressEl = document.getElementById('mainScoreProgress');

            // Get current score from resultPercentage
            const percentage = document.getElementById('resultPercentage');
            const currentScore = percentage ? parseFloat(percentage.textContent) || 0 : 0;
            const displayScore = currentScore.toFixed(1);

            console.log('[TIAGE] updateSyntheseScoreCycle - score:', currentScore, 'mainScoreValueEl:', !!mainScoreValueEl);

            // Update circle progress (circumference = 2 * PI * r = 2 * 3.14159 * 42 â‰ˆ 264)
            const circumference = 264;
            const offset = circumference - (currentScore / 100) * circumference;

            // Update color based on score (rot â†’ gelb â†’ grÃ¼n)
            const color = getScoreGradientColor(currentScore);

            // Update Modal Score Circle
            if (scoreValueEl && scoreProgressEl) {
                scoreValueEl.textContent = displayScore;
                scoreProgressEl.style.strokeDashoffset = offset;
                scoreProgressEl.style.stroke = color;
                scoreValueEl.style.color = color;
            }

            // Update Main Page Score Circle
            if (mainScoreValueEl && mainScoreProgressEl) {
                mainScoreValueEl.textContent = displayScore;
                mainScoreProgressEl.style.strokeDashoffset = offset;
                mainScoreProgressEl.style.stroke = color;
                mainScoreValueEl.style.color = color;
            }

            // Update Mobile Score Circle
            const mobileScoreEl = document.getElementById('mobileScoreCircle');
            const mobileScoreProgressEl = document.getElementById('mobileScoreProgress');

            if (mobileScoreEl) {
                mobileScoreEl.textContent = displayScore;
                mobileScoreEl.style.color = color;
            }

            if (mobileScoreProgressEl) {
                mobileScoreProgressEl.style.strokeDashoffset = offset;
                mobileScoreProgressEl.style.stroke = color;
            }

            // Update Score Summary Line in Synthese Modal
            const scoreSummaryValueEl = document.getElementById('syntheseScoreSummaryValue');
            const needsSummaryValueEl = document.getElementById('syntheseNeedsSummaryValue');

            if (scoreSummaryValueEl) {
                scoreSummaryValueEl.textContent = displayScore;
                scoreSummaryValueEl.style.color = color;
            }

            if (needsSummaryValueEl) {
                // Get BedÃ¼rfnis-Ãœbereinstimmung from lastGfkMatchingResult
                const needsScore = lastGfkMatchingResult ? lastGfkMatchingResult.score : 0;
                needsSummaryValueEl.textContent = needsScore;
                // Color based on needs score
                const needsColor = getScoreGradientColor(needsScore);
                needsSummaryValueEl.style.color = needsColor;
            }
        }

        function getBarClass(value) {
            if (value >= 70) return 'bar-good';
            if (value >= 50) return 'bar-medium';
            return 'bar-low';
        }

        function toggleCollapsible(id) {
            document.getElementById(id).classList.toggle('open');
        }

        // Toggle dimension collapse for Dominanz/Orientierung sections
        function toggleDimensionCollapse(element) {
            element.classList.toggle('collapsed');
        }

        // Track global fold/unfold state
        let allDimensionsCollapsed = false;

        // Toggle all dimensions AND desktop factors collapse/expand at once
        function toggleAllDimensionsCollapse() {
            const allDimensions = document.querySelectorAll('.collapsible-dimension');
            const allFactors = document.querySelectorAll('.desktop-factor-item');
            
            // Get both desktop and mobile buttons
            const desktopBtn = document.getElementById('foldUnfoldAllBtn');
            const mobileBtn = document.getElementById('mobileFoldUnfoldBtn');

            allDimensionsCollapsed = !allDimensionsCollapsed;

            // Toggle collapsible dimensions
            allDimensions.forEach(dim => {
                if (allDimensionsCollapsed) {
                    dim.classList.add('collapsed');
                } else {
                    dim.classList.remove('collapsed');
                }
            });

            // Toggle desktop factor items
            allFactors.forEach(factor => {
                if (allDimensionsCollapsed) {
                    factor.classList.add('collapsed');
                } else {
                    factor.classList.remove('collapsed');
                }
            });

            // Update both buttons' appearance
            const buttons = [desktopBtn, mobileBtn].filter(btn => btn !== null);
            buttons.forEach(btn => {
                const icon = btn.querySelector('.fold-unfold-icon');
                const text = btn.querySelector('.fold-unfold-text');

                if (allDimensionsCollapsed) {
                    icon.textContent = 'â–¶';
                    text.textContent = 'Unfold';
                    btn.classList.add('collapsed-state');
                } else {
                    icon.textContent = 'â–¼';
                    text.textContent = 'Fold';
                    btn.classList.remove('collapsed-state');
                }
            });

            // Update desktop factor content when expanding
            if (!allDimensionsCollapsed) {
                updateDesktopFactorContent();
            }
        }

        // Toggle single desktop factor expand/collapse
        function toggleDesktopFactor(element) {
            const wasCollapsed = element.classList.contains('collapsed');
            element.classList.toggle('collapsed');
            // Update the fold/unfold button state based on current state
            updateDesktopFactorFoldButton();
            // Update content when expanding
            if (wasCollapsed) {
                updateDesktopFactorContent();
            }
        }

        // Update fold button based on current state of all collapsible elements
        function updateDesktopFactorFoldButton() {
            const allDimensions = document.querySelectorAll('.collapsible-dimension');
            const allFactors = document.querySelectorAll('.desktop-factor-item');
            const desktopBtn = document.getElementById('foldUnfoldAllBtn');
            const mobileBtn = document.getElementById('mobileFoldUnfoldBtn');

            // Check if all are collapsed (both dimensions and factors)
            const allDimensionsCollapsedCheck = Array.from(allDimensions).every(d => d.classList.contains('collapsed'));
            const allFactorsCollapsed = Array.from(allFactors).every(f => f.classList.contains('collapsed'));
            const allCollapsed = allDimensionsCollapsedCheck && allFactorsCollapsed;

            allDimensionsCollapsed = allCollapsed;

            // Update both buttons
            const buttons = [desktopBtn, mobileBtn].filter(btn => btn !== null);
            buttons.forEach(btn => {
                const icon = btn.querySelector('.fold-unfold-icon');
                const text = btn.querySelector('.fold-unfold-text');

                if (allCollapsed) {
                    icon.textContent = 'â–¶';
                    text.textContent = 'Unfold';
                    btn.classList.add('collapsed-state');
                } else {
                    icon.textContent = 'â–¼';
                    text.textContent = 'Fold';
                    btn.classList.remove('collapsed-state');
                }
            });
        }

        // Update all desktop factor expandable content
        function updateDesktopFactorContent() {
            // Check if factorExplanations is defined (it's defined later in the file)
            if (typeof factorExplanations === 'undefined') return;

            const ich = mobileIchArchetype;
            const partner = mobilePartnerArchetype;
            const dimensions = personDimensions;

            const factorTypes = ['archetyp', 'dominanz', 'orientierung', 'geschlecht'];

            factorTypes.forEach(factorType => {
                const factor = factorExplanations[factorType];
                if (!factor) return;

                // Get score
                const prefix = 'desktopFactor';
                let score = 0;
                const scoreEl = document.getElementById(prefix + factorType.charAt(0).toUpperCase() + factorType.slice(1));
                if (scoreEl) {
                    score = parseInt(scoreEl.textContent) || 0;
                }

                // Update explanation
                const explanationId = prefix + factorType.charAt(0).toUpperCase() + factorType.slice(1) + 'Explanation';
                const explanationEl = document.getElementById(explanationId);
                if (explanationEl) {
                    explanationEl.textContent = factor.getExplanation(ich, partner, score, dimensions);
                }

                // Update meaning list
                const meaningId = prefix + factorType.charAt(0).toUpperCase() + factorType.slice(1) + 'Meaning';
                const meaningList = document.getElementById(meaningId);
                if (meaningList) {
                    meaningList.innerHTML = '';
                    factor.getMeaning(score, ich, partner).forEach(item => {
                        const li = document.createElement('li');
                        if (typeof item === 'object' && item.title) {
                            li.innerHTML = `<strong>${item.title}</strong>${item.desc ? ` â€“ ${item.desc}` : ''}`;
                        } else {
                            li.textContent = item;
                        }
                        meaningList.appendChild(li);
                    });
                }
            });
        }

        function scrollToCard(index) {
            const carousel = document.getElementById('carousel');
            const cardWidth = window.innerWidth;
            carousel.scrollTo({ left: cardWidth * index, behavior: 'smooth' });
        }

        const TOTAL_PAGES = 4;

        function updateNavDots() {
            const carousel = document.getElementById('carousel');
            const cardWidth = window.innerWidth;
            const currentCard = Math.round(carousel.scrollLeft / cardWidth);

            document.querySelectorAll('.nav-dot').forEach((dot, i) => {
                dot.classList.toggle('active', i === currentCard);
            });

            // Update arrow states
            const arrows = document.querySelectorAll('.nav-arrow');
            if (arrows.length >= 2) {
                arrows[0].disabled = currentCard === 0;
                arrows[1].disabled = currentCard === TOTAL_PAGES - 1;
            }

            // Load feedback when on page 4
            if (currentCard === 3) {
                loadFeedback();
            }
        }

        function navigatePrev() {
            const carousel = document.getElementById('carousel');
            const cardWidth = window.innerWidth;
            const currentCard = Math.round(carousel.scrollLeft / cardWidth);
            if (currentCard > 0) {
                scrollToCard(currentCard - 1);
            }
        }

        function navigateNext() {
            const carousel = document.getElementById('carousel');
            const cardWidth = window.innerWidth;
            const currentCard = Math.round(carousel.scrollLeft / cardWidth);
            if (currentCard < TOTAL_PAGES - 1) {
                scrollToCard(currentCard + 1);
            }
        }

        // Legend Categories
        function updateLegendCategories() {
            const container = document.getElementById('legendCategories');
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];

            // Get current interaction scores
            const interactionKey = `${currentArchetype}_${selectedPartner}`;
            const interaction = data.interactions[interactionKey] || {};
            const scores = interaction.scores || {};

            const myArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[selectedPartner];
            const myName = myArch?.name || currentArchetype;
            const partnerName = partnerArch?.name || selectedPartner;

            // Show which combination is displayed
            const headerText = currentArchetype === selectedPartner
                ? `${myName} (Ich) mit ${myName}`
                : `${myName} (Ich) mit ${partnerName}`;

            container.innerHTML = `
                <div style="margin-bottom: 15px; padding: 10px; background: var(--bg-dark); border-radius: 10px; text-align: center;">
                    <span style="color: var(--text-muted); font-size: var(--font-sm);">Aktuelle Auswahl:</span>
                    <div style="color: var(--primary); font-weight: 600; font-size: var(--font-base);">${headerText}</div>
                </div>
            ` + categories.map(cat => {
                const catData = categoryDescriptions[cat] || {};
                const name = catData.name || categoryNames[cat] || cat;
                const desc = catData.description || 'Beschreibung nicht verfÃ¼gbar';
                const value = scores[cat]?.value || 0;
                const scoreColor = getScoreColor(value);

                return `
                    <div class="legend-category-item" onclick="openSingleCategoryModal('${cat}')">
                        <div class="legend-category-letter">${cat}</div>
                        <div class="legend-category-content">
                            <div class="legend-category-name">${name}</div>
                            <div class="legend-category-desc">${desc}</div>
                        </div>
                        <div style="font-weight: 700; font-size: var(--font-md); color: ${scoreColor}; min-width: 50px; text-align: right;">${value}</div>
                    </div>
                `;
            }).join('');
        }

        // Modal Functions
        function openCategoryModal() {
            // Reset modal context when opening directly (uses page 2 selection)
            modalContextPartner = null;
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            document.getElementById('modalTitle').textContent = 'Alle Kategorien';
            document.getElementById('modalBody').innerHTML = categories.map(cat => getCategoryModalContent(cat)).join('');
            document.getElementById('categoryModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        let currentModalCategory = 'A'; // Track current category for navigation

        function openSingleCategoryModal(category) {
            currentModalCategory = category;
            // Don't reset modalContextPartner here - it may be set from match modal
            const catData = categoryDescriptions[category] || {};
            const name = catData.name || categoryNames[category] || category;
            document.getElementById('modalTitle').textContent = `Kategorie ${category}`;
            document.getElementById('modalBody').innerHTML = getCategoryModalContent(category);
            document.getElementById('categoryModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function navigateCategoryPrev() {
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            const currentIndex = categories.indexOf(currentModalCategory);
            const prevIndex = currentIndex > 0 ? currentIndex - 1 : categories.length - 1;
            openSingleCategoryModal(categories[prevIndex]);
        }

        function navigateCategoryNext() {
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            const currentIndex = categories.indexOf(currentModalCategory);
            const nextIndex = currentIndex < categories.length - 1 ? currentIndex + 1 : 0;
            openSingleCategoryModal(categories[nextIndex]);
        }

        function getCategoryModalContent(cat) {
            const catData = categoryDescriptions[cat] || {};
            const name = catData.name || categoryNames[cat] || cat;
            const desc = catData.description || 'Beschreibung nicht verfÃ¼gbar';
            const subDims = catData.subDimensions || [];

            // Use modalContextPartner if set (from match modal), otherwise use selectedPartner (from page 2)
            const partnerId = modalContextPartner || selectedPartner;
            const interactionKey = `${currentArchetype}_${partnerId}`;
            const interaction = data.interactions[interactionKey] || {};
            const scores = interaction.scores || {};
            const value = scores[cat]?.value || 0;
            const scoreColor = getScoreColor(value);
            const barClass = getBarClass(value);

            const myArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[partnerId];
            const comboText = `${myArch?.name || '?'} + ${partnerArch?.name || '?'}`;
            const contextText = `${comboText} | ${name}`;

            // Get category position for navigation
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            const catIndex = categories.indexOf(cat);
            const prevCat = categories[catIndex > 0 ? catIndex - 1 : categories.length - 1];
            const nextCat = categories[catIndex < categories.length - 1 ? catIndex + 1 : 0];
            const prevName = categoryNames[prevCat] || prevCat;
            const nextName = categoryNames[nextCat] || nextCat;

            return `
                <div class="category-nav-row">
                    <button class="category-nav-btn" onclick="navigateCategoryPrev()">
                        â€¹ ${prevCat}
                    </button>
                    <span class="category-nav-indicator">${catIndex + 1} / 6</span>
                    <button class="category-nav-btn" onclick="navigateCategoryNext()">
                        ${nextCat} â€º
                    </button>
                </div>

                <div class="modal-category">
                    <div class="modal-category-header">
                        <div class="modal-category-letter">${cat}</div>
                        <div class="modal-category-name">${name}</div>
                    </div>
                    <div class="match-modal-score" style="margin: 12px 0;">
                        <span class="match-modal-score-label">${comboText}</span>
                        <span class="match-modal-score-value" style="color: ${scoreColor}">${value}</span>
                    </div>
                    <div class="modal-category-desc">${desc}</div>
                    ${subDims.length > 0 ? `
                        <div class="modal-subdimensions">
                            ${subDims.map(sd => renderTagWithTooltip(sd, cat, currentArchetype, partnerId)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Render a tag with tooltip
        function renderTagWithTooltip(tagName, category, type1Id, type2Id) {
            const tooltip = getTagTooltip(type1Id, type2Id, category, tagName);
            const type1 = data.archetypes[type1Id];
            const type2 = data.archetypes[type2Id];
            const color1 = type1?.color || 'var(--primary)';
            const color2 = type2?.color || 'var(--primary)';

            // Build type switcher options
            const allTypes = archetypeOrder.map(id => {
                const arch = data.archetypes[id];
                return `
                    <button class="type-switch-btn ${id === type1Id ? 'active' : ''}"
                            style="color: ${arch?.color || 'var(--text-secondary)'}"
                            onclick="event.stopPropagation(); switchTooltipType('${id}', 'ich', '${category}')">
                        <span class="dot" style="background: ${arch?.color}"></span>
                        ${arch?.name || id}
                    </button>
                `;
            }).join('');

            const partnerTypes = archetypeOrder.map(id => {
                const arch = data.archetypes[id];
                return `
                    <button class="type-switch-btn ${id === type2Id ? 'active' : ''}"
                            style="color: ${arch?.color || 'var(--text-secondary)'}"
                            onclick="event.stopPropagation(); switchTooltipType('${id}', 'partner', '${category}')">
                        <span class="dot" style="background: ${arch?.color}"></span>
                        ${arch?.name || id}
                    </button>
                `;
            }).join('');

            return `
                <span class="tag-tooltip-container">
                    <span class="modal-subdim-tag" onclick="openTagTooltip(this.parentElement, '${category}')">${tagName}</span>
                    <div class="tag-tooltip">
                        <button class="tag-tooltip-close" onclick="closeTagTooltip()">&times;</button>
                        <div class="tag-tooltip-header">${tagName}</div>

                        <div class="tag-tooltip-type-switcher">
                            <span class="type-switch-label">Ich:</span>
                            ${allTypes}
                        </div>
                        <div class="tag-tooltip-type-switcher">
                            <span class="type-switch-label">Partner:</span>
                            ${partnerTypes}
                        </div>

                        <div class="tag-tooltip-body">
                            <div class="tag-tooltip-perspective">
                                <span class="tag-tooltip-type-name" style="color: ${color1}">${tooltip.type1Name}:</span>
                                <span class="tag-tooltip-type-text">${tooltip.type1Perspective}</span>
                            </div>
                            <div class="tag-tooltip-perspective">
                                <span class="tag-tooltip-type-name" style="color: ${color2}">${tooltip.type2Name}:</span>
                                <span class="tag-tooltip-type-text">${tooltip.type2Perspective}</span>
                            </div>
                            <div class="tag-tooltip-dynamic">${tooltip.dynamic}</div>
                        </div>
                    </div>
                </span>
            `;
        }

        // Switch type from tooltip and refresh modal
        function switchTooltipType(typeId, role, category) {
            if (role === 'ich') {
                currentArchetype = typeId;
                mobileIchArchetype = typeId;

                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('ich', typeId);
                }

                // Update main UI
                document.getElementById('archetypeSelect').value = typeId;
                const ichSelect = document.getElementById('ichSelect');
                const mobileIchSelect = document.getElementById('mobileIchSelect');
                if (ichSelect) ichSelect.value = typeId;
                if (mobileIchSelect) mobileIchSelect.value = typeId;

                // Sync archetype grid highlighting
                updateArchetypeGrid('ich', typeId);

                updateTheme();
                updateMyType();
                updatePartnerSelector();
                updateTopAndChallenge();
                updatePartnerView();
            } else {
                selectedPartner = typeId;
                mobilePartnerArchetype = typeId;
                modalContextPartner = typeId;

                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('partner', typeId);
                }

                // Sync select dropdowns
                const partnerSelect = document.getElementById('partnerSelect');
                const mobilePartnerSelect = document.getElementById('mobilePartnerSelect');
                if (partnerSelect) partnerSelect.value = typeId;
                if (mobilePartnerSelect) mobilePartnerSelect.value = typeId;

                // Sync archetype grid highlighting
                updateArchetypeGrid('partner', typeId);

                // Update partner selection buttons
                document.querySelectorAll('.partner-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.id === typeId);
                });
                updatePartnerView();
            }

            // Update score display
            updateComparisonView();

            // Refresh the category modal with new types
            openSingleCategoryModal(category);
        }

        // Active tooltip tracking
        let activeTooltipElement = null;
        let activeTagElement = null;

        // Toggle tag tooltip on click
        function openTagTooltip(container, category) {
            const tooltip = container.querySelector('.tag-tooltip');
            const tag = container.querySelector('.modal-subdim-tag');
            if (!tooltip || !tag) return;

            // If this tooltip is already open, close it
            if (activeTooltipElement === tooltip) {
                closeTagTooltip();
                return;
            }

            // Close any other open tooltip first
            closeTagTooltip();

            // Activate this tooltip and tag
            activeTooltipElement = tooltip;
            activeTagElement = tag;
            tooltip.classList.add('active');
            tag.classList.add('active');

            // Position at top of viewport so it doesn't get cut off
            const tooltipWidth = Math.min(360, window.innerWidth * 0.92);
            const left = (window.innerWidth - tooltipWidth) / 2;
            const top = 60; // Fixed position near top

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
            tooltip.style.width = tooltipWidth + 'px';
        }

        // Close tag tooltip
        function closeTagTooltip() {
            if (activeTooltipElement) {
                activeTooltipElement.classList.remove('active');
                activeTooltipElement = null;
            }
            if (activeTagElement) {
                activeTagElement.classList.remove('active');
                activeTagElement = null;
            }
            // Also close any other open tooltips and tags
            document.querySelectorAll('.tag-tooltip.active').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.modal-subdim-tag.active').forEach(t => t.classList.remove('active'));
        }

        function closeCategoryModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('categoryModal').classList.remove('active');
            document.body.style.overflow = '';
            // Reset modal context when closing
            modalContextPartner = null;
        }

        // Definition Modal Functions
        function openDefinitionModal(archetypeId) {
            const def = archetypeDescriptions[archetypeId];
            if (!def) return;

            const arch = data.archetypes[archetypeId];
            const color = arch?.color || 'var(--primary)';
            const icon = icons[archetypeId] || '?';

            document.getElementById('definitionModalTitle').innerHTML = `
                <span style="color: ${color}">${icon}</span> ${def.name}
            `;

            document.getElementById('definitionModalBody').innerHTML = `
                <div class="definition-long">${def.longDef}</div>

                <div class="definition-section">
                    <div class="definition-section-title">Kernprinzipien</div>
                    <ul class="definition-list principles">
                        ${def.keyPrinciples.map(p => `<li>${p}</li>`).join('')}
                    </ul>
                </div>

                <div class="definition-section">
                    <div class="definition-section-title">Das ist NICHT dasselbe wie</div>
                    <ul class="definition-list not-same">
                        ${def.notTheSameAs.map(n => `<li>${n}</li>`).join('')}
                    </ul>
                </div>

                <div class="definition-section">
                    <div class="definition-section-title">Varianten</div>
                    <ul class="definition-list variants">
                        ${def.variants.map(v => `<li>${v}</li>`).join('')}
                    </ul>
                </div>
            `;

            document.getElementById('definitionModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function closeDefinitionModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('definitionModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        // ========================================
        // Definition Modal Swipe Navigation
        // ========================================
        let currentDefinitionIndex = 0;
        let currentDefinitionPerson = 'ich'; // Track whether showing 'ich' or 'partner'
        let definitionTouchStartX = 0;

        function handleDefinitionTouchStart(e) {
            definitionTouchStartX = e.touches[0].clientX;
        }

        function handleDefinitionTouchEnd(e) {
            const touchEndX = e.changedTouches[0].clientX;
            const diff = definitionTouchStartX - touchEndX;
            if (Math.abs(diff) > 50) {
                navigateDefinition(diff > 0 ? 1 : -1);
            }
        }

        function navigateDefinition(direction) {
            currentDefinitionIndex += direction;
            if (currentDefinitionIndex < 0) currentDefinitionIndex = archetypeOrder.length - 1;
            if (currentDefinitionIndex >= archetypeOrder.length) currentDefinitionIndex = 0;

            const newArchetype = archetypeOrder[currentDefinitionIndex];
            showArchetypeInfoByType(newArchetype);

            // Sync dropdown and dispatch change event to trigger UI updates
            if (currentDefinitionPerson === 'ich') {
                const ichSelect = document.getElementById('ichSelect');
                if (ichSelect) {
                    ichSelect.value = newArchetype;
                    ichSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
            } else if (currentDefinitionPerson === 'partner') {
                const partnerSelect = document.getElementById('partnerSelect');
                if (partnerSelect) {
                    partnerSelect.value = newArchetype;
                    partnerSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        }

        // Alias for button onclick
        function navigateDefinitionModal(direction) {
            navigateDefinition(direction);
        }

        function showArchetypeInfoByType(archetypeId) {
            if (!data || !data.archetypes || !data.archetypes[archetypeId]) {
                console.error('Data not available for archetype:', archetypeId);
                return;
            }

            const arch = data.archetypes[archetypeId];
            const def = archetypeDescriptions[archetypeId];

            // Get localized archetype data from i18n (with fallback to hardcoded def)
            const localizedArch = {
                name: TiageI18n.t(`archetypes.${archetypeId}.name`, arch.name),
                shortDef: TiageI18n.t(`archetypes.${archetypeId}.shortDef`, def?.shortDef || ''),
                longDef: TiageI18n.t(`archetypes.${archetypeId}.longDef`, def?.longDef || ''),
                keyPrinciples: TiageI18n.t(`archetypes.${archetypeId}.keyPrinciples`, def?.keyPrinciples || []),
                notTheSameAs: TiageI18n.t(`archetypes.${archetypeId}.notTheSameAs`, def?.notTheSameAs || []),
                variants: TiageI18n.t(`archetypes.${archetypeId}.variants`, def?.variants || [])
            };

            // Top navigation dots and swipe hint
            const swipeHint = TiageI18n.t('archetypeModal.swipeHint', 'â† Wischen zum Navigieren â†’');
            let topNav = `
                <div class="definition-nav-dots" style="display: flex; justify-content: center; gap: 8px; margin-bottom: 15px; padding-bottom: 15px; border-bottom: 1px solid var(--border);">
                    ${archetypeOrder.map((id, index) => `
                        <span class="definition-dot${index === currentDefinitionIndex ? ' active' : ''}"
                              onclick="navigateDefinitionToIndex(${index})"
                              style="width: 10px; height: 10px; border-radius: 50%; background: ${index === currentDefinitionIndex ? 'var(--primary)' : 'var(--border)'}; cursor: pointer; transition: all 0.2s;"></span>
                    `).join('')}
                </div>
                <div style="text-align: center; font-size: 11px; color: var(--text-muted); margin-bottom: 15px;">${swipeHint}</div>
            `;

            let modalContent = topNav + `
                <div class="modal-category">
                    <div class="modal-category-header">
                        <div class="modal-category-letter" style="background: ${arch.color}; width: 40px; height: 40px; font-size: 20px;">${icons[archetypeId]}</div>
                        <div class="modal-category-name">${localizedArch.name}</div>
                    </div>
                    <div class="modal-category-desc">${localizedArch.shortDef || ''}</div>
            `;

            if (def || localizedArch.longDef) {
                modalContent += `
                    <div class="definition-long" style="margin-top: 15px;">${localizedArch.longDef || ''}</div>
                `;

                const keyPrinciples = localizedArch.keyPrinciples;
                if (keyPrinciples && keyPrinciples.length > 0) {
                    modalContent += `
                        <div class="definition-section">
                            <div class="definition-section-title">${TiageI18n.t('archetypeModal.keyPrinciples', 'Kernprinzipien')}</div>
                            <ul class="definition-list principles">
                                ${keyPrinciples.map(p => `<li>${p}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                const notTheSameAs = localizedArch.notTheSameAs;
                if (notTheSameAs && notTheSameAs.length > 0) {
                    modalContent += `
                        <div class="definition-section">
                            <div class="definition-section-title">${TiageI18n.t('archetypeModal.notTheSameAs', 'Das ist NICHT')}</div>
                            <ul class="definition-list not-same">
                                ${notTheSameAs.map(n => `<li>${n}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }

                const variants = localizedArch.variants;
                if (variants && variants.length > 0) {
                    modalContent += `
                        <div class="definition-section">
                            <div class="definition-section-title">${TiageI18n.t('archetypeModal.variants', 'Varianten')}</div>
                            <ul class="definition-list variants">
                                ${variants.map(v => `<li>${v}</li>`).join('')}
                            </ul>
                        </div>
                    `;
                }
            }

            // Add Pathos & Logos section
            const pathos = arch.pathos || '';
            const logos = arch.logos || '';

            if (pathos || logos) {
                modalContent += `
                    <div class="definition-section" style="margin-top: 20px; border-top: 1px solid var(--border); padding-top: 15px;">
                        <div class="definition-section-title" style="margin-bottom: 15px;">${TiageI18n.t('archetypeModal.pathosLogos', 'Pathos & Logos')}</div>
                `;

                if (pathos) {
                    modalContent += `
                        <div style="margin-bottom: 15px; padding: 12px; background: rgba(231,76,60,0.1); border-radius: 10px; border-left: 3px solid #e74c3c;">
                            <div style="color: #e74c3c; font-weight: 600; font-size: 13px; margin-bottom: 6px;">${TiageI18n.t('archetypeModal.pathosLabel', 'Pathos (Emotionale Ebene)')}</div>
                            <p style="color: var(--text-secondary); font-style: italic; line-height: 1.5; font-size: 12px; margin: 0;">${pathos}</p>
                        </div>
                    `;
                }

                if (logos) {
                    modalContent += `
                        <div style="padding: 12px; background: rgba(52,152,219,0.1); border-radius: 10px; border-left: 3px solid #3498db;">
                            <div style="color: #3498db; font-weight: 600; font-size: 13px; margin-bottom: 6px;">${TiageI18n.t('archetypeModal.logosLabel', 'Logos (Rationale Ebene)')}</div>
                            <p style="color: var(--text-secondary); font-style: italic; line-height: 1.5; font-size: 12px; margin: 0;">${logos}</p>
                        </div>
                    `;
                }

                modalContent += `</div>`;
            }

            modalContent += '</div>';

            // Add navigation dots and confirm button
            modalContent += `
                <div class="definition-nav-dots" style="display: flex; justify-content: center; gap: 8px; margin-top: 15px; padding-top: 15px; border-top: 1px solid var(--border);">
                    ${archetypeOrder.map((id, index) => `
                        <span class="definition-dot${index === currentDefinitionIndex ? ' active' : ''}"
                              onclick="navigateDefinitionToIndex(${index})"
                              style="width: 10px; height: 10px; border-radius: 50%; background: ${index === currentDefinitionIndex ? 'var(--primary)' : 'var(--border)'}; cursor: pointer; transition: all 0.2s;"></span>
                    `).join('')}
                </div>
                <div style="text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 8px;">${swipeHint}</div>
                <button onclick="confirmDefinitionSelection()" style="
                    display: block;
                    width: 100%;
                    margin-top: 15px;
                    padding: 12px 20px;
                    background: var(--primary);
                    color: white;
                    border: none;
                    border-radius: 8px;
                    font-size: 14px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                " onmouseover="this.style.opacity='0.9'" onmouseout="this.style.opacity='1'">
                    ${TiageI18n.t('archetypeModal.confirmSelection', 'Auswahl Ã¼bernehmen')}
                </button>
            `;

            const definitionLabel = TiageI18n.t('archetypeModal.definition', 'Definition');
            document.getElementById('definitionModalTitle').textContent = `${localizedArch.name} - ${definitionLabel}`;
            document.getElementById('definitionModalBody').innerHTML = modalContent;
            document.getElementById('definitionModalBody').scrollTop = 0;
        }

        function navigateDefinitionToIndex(index) {
            currentDefinitionIndex = index;
            const newArchetype = archetypeOrder[index];
            showArchetypeInfoByType(newArchetype);

            // Sync dropdown and dispatch change event to trigger UI updates
            if (currentDefinitionPerson === 'ich') {
                const ichSelect = document.getElementById('ichSelect');
                if (ichSelect) {
                    ichSelect.value = newArchetype;
                    ichSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
            } else if (currentDefinitionPerson === 'partner') {
                const partnerSelect = document.getElementById('partnerSelect');
                if (partnerSelect) {
                    partnerSelect.value = newArchetype;
                    partnerSelect.dispatchEvent(new Event('change', { bubbles: true }));
                }
            }
        }

        function confirmDefinitionSelection() {
            console.log('confirmDefinitionSelection called');
            console.log('currentDefinitionIndex:', currentDefinitionIndex);
            console.log('archetypeOrder:', archetypeOrder);

            const selectedArchetype = archetypeOrder[currentDefinitionIndex];
            console.log('selectedArchetype:', selectedArchetype);
            console.log('currentDefinitionPerson:', currentDefinitionPerson);

            if (currentDefinitionPerson === 'ich') {
                // Update main dropdown
                currentArchetype = selectedArchetype;
                const selectElement = document.getElementById('archetypeSelect');
                if (selectElement) {
                    selectElement.value = selectedArchetype;
                    // Dispatch change event to ensure listeners are notified
                    selectElement.dispatchEvent(new Event('change', { bubbles: true }));
                }
                console.log('Updated currentArchetype to:', currentArchetype);
                updateAll();
            } else {
                // Update partner selection
                console.log('Calling selectPartner with:', selectedArchetype);
                selectPartner(selectedArchetype);
            }

            // Close modal
            document.getElementById('definitionModal').classList.remove('active');
            document.body.style.overflow = '';
            console.log('Modal closed, selection complete');
        }

        // Get short definition for tooltip
        function getShortDef(archetypeId) {
            return archetypeDescriptions[archetypeId]?.shortDef || '';
        }

        // Store current match data for modal access
        let currentTopMatch = { id: null, score: 0 };
        let currentChallenge = { id: null, score: 0 };
        let modalContextPartner = null; // Track which partner to use in category modal
        let currentMatchModalView = TiageState.get('ui.matchModalView') || 'pathos'; // pathos or logos
        let currentMatchModalData = null; // Store current modal data for toggle refresh

        // Match Modal Toggle Function
        function toggleMatchModalView(view) {
            currentMatchModalView = view;
            TiageState.set('ui.matchModalView', view);

            // Update toggle button styles
            document.getElementById('matchTogglePathos').classList.toggle('active', view === 'pathos');
            document.getElementById('matchToggleLogos').classList.toggle('active', view === 'logos');

            // Refresh modal content if data is available
            if (currentMatchModalData) {
                const content = getMatchModalContent(
                    currentMatchModalData.partnerArch,
                    currentMatchModalData.interaction,
                    currentMatchModalData.scores,
                    currentMatchModalData.scoreColor,
                    currentMatchModalData.myArch
                );
                document.getElementById('modalBody').innerHTML = content;
            }
        }

        // Generate dynamic Pro items based on current view (Pathos/Logos)
        function generateDynamicPro(myArch, partnerArch, view) {
            const items = [];
            const ichId = myArch.id;
            const partnerId = partnerArch.id;

            if (view === 'pathos') {
                // Emotional/Pathos perspective - use PathosTextGenerator if available
                if (typeof PathosTextGenerator !== 'undefined') {
                    const resonance = PathosTextGenerator.calculateResonance?.(myArch, partnerArch) || {};
                    if (resonance.emotional > 0.6) items.push('Starke emotionale Resonanz zwischen euren Energien');
                    if (resonance.intuitive > 0.5) items.push('Intuitives VerstÃ¤ndnis fÃ¼reinander');
                }
                // Fallback emotional pros
                if (ichId === partnerId) {
                    items.push('Tiefes GefÃ¼hl des Verstandenwerdens');
                    items.push('Geteilte emotionale Sprache');
                }
                if (items.length === 0) {
                    items.push('Potenzial fÃ¼r emotionale Verbindung');
                    items.push('Raum fÃ¼r gegenseitiges Wachstum');
                }
            } else {
                // Rational/Logos perspective - use LogosTextGenerator if available
                if (typeof LogosTextGenerator !== 'undefined') {
                    const analysis = LogosTextGenerator.analyzeCompatibility?.(myArch, partnerArch) || {};
                    if (analysis.structuralMatch > 0.6) items.push('Kompatible Beziehungsstrukturen');
                    if (analysis.valueAlignment > 0.5) items.push('Ãœbereinstimmende Grundwerte');
                }
                // Fallback structural pros
                if (ichId === partnerId) {
                    items.push('Identische Beziehungsphilosophie');
                    items.push('Gleiche Erwartungen an Verbindlichkeit');
                }
                if (items.length === 0) {
                    items.push('Klare Kommunikationsbasis mÃ¶glich');
                    items.push('Strukturelle Anpassung machbar');
                }
            }
            return items;
        }

        // Generate dynamic Contra items based on current view (Pathos/Logos)
        function generateDynamicContra(myArch, partnerArch, view) {
            const items = [];
            const ichId = myArch.id;
            const partnerId = partnerArch.id;

            // Use IntegratedSynthesisTextGenerator for conflicts if available
            if (typeof IntegratedSynthesisTextGenerator !== 'undefined') {
                const conflicts = IntegratedSynthesisTextGenerator.identifyPartnerConflicts(
                    ichId, partnerId, null, null
                );

                if (view === 'pathos') {
                    // Emotional perspective on conflicts
                    conflicts.forEach(conflict => {
                        if (conflict.dynamics?.core_wound) {
                            items.push(conflict.dynamics.core_wound);
                        }
                    });
                    // Inner conflicts
                    const innerData = IntegratedSynthesisTextGenerator.data?.innerConflicts;
                    if (innerData?.[ichId]?.shadow) {
                        items.push(`Dein Schatten: ${innerData[ichId].shadow.substring(0, 80)}...`);
                    }
                } else {
                    // Rational perspective on conflicts
                    conflicts.forEach(conflict => {
                        items.push(`${conflict.title}: ${conflict.dynamics?.pattern || ''}`);
                    });
                }
            }

            // Fallback contras
            if (items.length === 0) {
                if (view === 'pathos') {
                    items.push('Emotionale Frequenzen kÃ¶nnen divergieren');
                    items.push('Risiko von MissverstÃ¤ndnissen auf GefÃ¼hlsebene');
                } else {
                    items.push('Unterschiedliche Erwartungen mÃ¶glich');
                    items.push('Kommunikationsarbeit erforderlich');
                }
            }

            return items;
        }

        // Generate synthesis section with psychological depth
        function generateSynthesisSection(myArch, partnerArch) {
            if (typeof IntegratedSynthesisTextGenerator === 'undefined') {
                return '';
            }

            const ichId = myArch.id;
            const partnerId = partnerArch.id;

            // Get inner conflicts
            const innerData = IntegratedSynthesisTextGenerator.data?.innerConflicts || {};
            const ichConflict = innerData[ichId];
            const partnerConflict = innerData[partnerId];

            let conflictHtml = '';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DEIN INNERER KONFLIKT - Mit voller Tiefe
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (ichConflict) {
                conflictHtml += `
                    <div class="match-modal-inner-conflict">
                        <div class="match-modal-inner-conflict-title">ğŸ”® Dein innerer Konflikt: ${ichConflict.core}</div>
                        <div class="match-modal-inner-conflict-text">${ichConflict.description}</div>
                        ${ichConflict.psychological ? `
                            <div style="margin-top: 10px; padding: 8px; background: rgba(255, 193, 7, 0.05); border-radius: 6px;">
                                <div style="font-size: 11px; color: #f39c12; font-weight: 600; margin-bottom: 4px;">ğŸ§  Psychologisch</div>
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5;">${ichConflict.psychological}</div>
                            </div>
                        ` : ''}
                        ${ichConflict.shadow ? `
                            <div style="margin-top: 8px; padding: 8px; background: rgba(128, 0, 128, 0.08); border-radius: 6px;">
                                <div style="font-size: 11px; color: #9b59b6; font-weight: 600; margin-bottom: 4px;">ğŸŒ‘ Schattenseite</div>
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5;">${ichConflict.shadow}</div>
                            </div>
                        ` : ''}
                        ${ichConflict.growth ? `
                            <div style="margin-top: 8px; padding: 8px; background: rgba(39, 174, 96, 0.08); border-radius: 6px;">
                                <div style="font-size: 11px; color: #27ae60; font-weight: 600; margin-bottom: 4px;">ğŸŒ± Wachstumspotenzial</div>
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5;">${ichConflict.growth}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PARTNER-KONFLIKT - Mit voller Tiefe
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (partnerConflict && ichId !== partnerId) {
                conflictHtml += `
                    <div class="match-modal-inner-conflict" style="margin-top: 12px;">
                        <div class="match-modal-inner-conflict-title">ğŸ”® Partner-Konflikt: ${partnerConflict.core}</div>
                        <div class="match-modal-inner-conflict-text">${partnerConflict.description}</div>
                        ${partnerConflict.psychological ? `
                            <div style="margin-top: 10px; padding: 8px; background: rgba(255, 193, 7, 0.05); border-radius: 6px;">
                                <div style="font-size: 11px; color: #f39c12; font-weight: 600; margin-bottom: 4px;">ğŸ§  Psychologisch</div>
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5;">${partnerConflict.psychological}</div>
                            </div>
                        ` : ''}
                        ${partnerConflict.shadow ? `
                            <div style="margin-top: 8px; padding: 8px; background: rgba(128, 0, 128, 0.08); border-radius: 6px;">
                                <div style="font-size: 11px; color: #9b59b6; font-weight: 600; margin-bottom: 4px;">ğŸŒ‘ Schattenseite</div>
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5;">${partnerConflict.shadow}</div>
                            </div>
                        ` : ''}
                        ${partnerConflict.growth ? `
                            <div style="margin-top: 8px; padding: 8px; background: rgba(39, 174, 96, 0.08); border-radius: 6px;">
                                <div style="font-size: 11px; color: #27ae60; font-weight: 600; margin-bottom: 4px;">ğŸŒ± Wachstumspotenzial</div>
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5;">${partnerConflict.growth}</div>
                            </div>
                        ` : ''}
                    </div>
                `;
            }

            // Get partner conflicts (interpersonelle Spannungen)
            const partnerConflicts = IntegratedSynthesisTextGenerator.identifyPartnerConflicts(
                ichId, partnerId, null, null
            );

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // HAUPTSPANNUNGSFELD - Mit voller Tiefe
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let partnerConflictHtml = '';
            if (partnerConflicts.length > 0) {
                const mainConflict = partnerConflicts[0];
                partnerConflictHtml = `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(231, 76, 60, 0.08); border-radius: 8px; border: 1px solid rgba(231, 76, 60, 0.2);">
                        <div style="font-weight: 600; color: var(--danger); font-size: var(--font-sm); margin-bottom: 8px;">
                            âš¡ Hauptspannungsfeld: ${mainConflict.title}
                        </div>

                        <!-- Dynamik-Sektion -->
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: #e74c3c; font-weight: 600; margin-bottom: 6px;">ğŸ“Š Dynamik</div>
                            ${mainConflict.dynamics?.pattern ? `
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5; margin-bottom: 6px;">
                                    <strong>Muster:</strong> ${mainConflict.dynamics.pattern}
                                </div>
                            ` : ''}
                            ${mainConflict.dynamics?.escalation ? `
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5; margin-bottom: 6px;">
                                    <strong>Eskalation:</strong> ${mainConflict.dynamics.escalation}
                                </div>
                            ` : ''}
                            ${mainConflict.dynamics?.core_wound ? `
                                <div style="font-size: var(--font-xs); color: #e74c3c; line-height: 1.5; padding: 6px; background: rgba(231,76,60,0.1); border-radius: 4px;">
                                    <strong>ğŸ’” Kernwunde:</strong> ${mainConflict.dynamics.core_wound}
                                </div>
                            ` : ''}
                        </div>

                        <!-- LÃ¶sungs-Sektion -->
                        <div style="padding-top: 12px; border-top: 1px solid rgba(255,255,255,0.1);">
                            <div style="font-size: 11px; color: var(--success); font-weight: 600; margin-bottom: 6px;">ğŸ’¡ LÃ¶sungsweg</div>
                            ${mainConflict.resolution?.understanding ? `
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5; margin-bottom: 6px;">
                                    <strong>VerstÃ¤ndnis:</strong> ${mainConflict.resolution.understanding}
                                </div>
                            ` : ''}
                            ${mainConflict.resolution?.practical ? `
                                <div style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5; margin-bottom: 6px;">
                                    <strong>Praktisch:</strong> ${mainConflict.resolution.practical}
                                </div>
                            ` : ''}
                            ${mainConflict.resolution?.growth ? `
                                <div style="font-size: var(--font-xs); color: var(--success); line-height: 1.5; padding: 6px; background: rgba(39,174,96,0.1); border-radius: 4px;">
                                    <strong>ğŸŒ± Wachstum:</strong> ${mainConflict.resolution.growth}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
            }

            return `
                <div class="match-modal-section synthese">
                    <div class="match-modal-section-title">ğŸ¯ Psychologische Tiefe</div>
                    ${conflictHtml}
                    ${partnerConflictHtml}
                </div>
            `;
        }

        // Match Modal Functions
        function openMatchModal(type) {
            const matchData = type === 'top' ? currentTopMatch : currentChallenge;
            if (!matchData.id) return;

            // Set the modal context to use this match's partner
            modalContextPartner = matchData.id;

            const myArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[matchData.id];
            const interactionKey = `${currentArchetype}_${matchData.id}`;
            const interaction = data.interactions[interactionKey] || {};
            const scores = interaction.scores || {};

            const title = type === 'top' ? 'Top Match' : 'Challenge';
            const scoreColor = getScoreColor(matchData.score);

            // Store data for toggle refresh
            currentMatchModalData = {
                myArch,
                partnerArch,
                interaction,
                scores,
                scoreColor
            };

            // Initialize toggle buttons to current view state
            setTimeout(() => {
                const pathosBtn = document.getElementById('matchTogglePathos');
                const logosBtn = document.getElementById('matchToggleLogos');
                if (pathosBtn && logosBtn) {
                    pathosBtn.classList.toggle('active', currentMatchModalView === 'pathos');
                    logosBtn.classList.toggle('active', currentMatchModalView === 'logos');
                }
            }, 0);

            document.getElementById('modalTitle').textContent = `${myArch.name} + ${partnerArch.name}`;
            document.getElementById('modalBody').innerHTML = getMatchModalContent(partnerArch, interaction, scores, scoreColor, myArch);
            document.getElementById('categoryModal').classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        function getMatchModalContent(partnerArch, interaction, scores, scoreColor, myArch) {
            const categories = ['A', 'B', 'C', 'D', 'E', 'F'];
            const overall = interaction.overall || 0;
            const isIdenticalType = myArch.id === partnerArch.id;

            const categoryBars = categories.map(cat => {
                const value = scores[cat]?.value || 0;
                const barClass = getBarClass(value);
                const name = categoryNames[cat] || cat;

                // Special note for identical types on category A (Beziehungsphilosophie)
                const isPhilosophyCategory = cat === 'A' && isIdenticalType;
                const specialNote = isPhilosophyCategory
                    ? '<div style="font-size: 10px; color: var(--success); margin-top: 2px;">Identische GrundÃ¼berzeugung</div>'
                    : '';

                return `
                    <div class="match-modal-bar-row clickable" onclick="openSingleCategoryModal('${cat}')">
                        <span class="match-modal-bar-label">${cat}</span>
                        <div class="match-modal-bar-container">
                            <div class="match-modal-bar ${barClass}" style="width: ${value}%">
                                <span class="match-modal-bar-value">${value}%</span>
                            </div>
                            ${specialNote}
                        </div>
                        <span class="match-modal-bar-name">${name}</span>
                    </div>
                `;
            }).join('');

            // Generate dynamic Pro/Contra based on current view (Pathos/Logos)
            const dynamicPro = generateDynamicPro(myArch, partnerArch, currentMatchModalView);
            const dynamicContra = generateDynamicContra(myArch, partnerArch, currentMatchModalView);

            // Combine static (from JSON) and dynamic items
            const staticPro = interaction.pro || [];
            const staticContra = interaction.contra || [];

            // Use dynamic items first, then add unique static items
            const combinedPro = [...dynamicPro];
            staticPro.forEach(p => {
                if (!combinedPro.some(dp => dp.toLowerCase().includes(p.toLowerCase().substring(0, 20)))) {
                    combinedPro.push(p);
                }
            });

            const combinedContra = [...dynamicContra];
            staticContra.forEach(c => {
                if (!combinedContra.some(dc => dc.toLowerCase().includes(c.toLowerCase().substring(0, 20)))) {
                    combinedContra.push(c);
                }
            });

            const proItems = combinedPro.map(p => `<li>${p}</li>`).join('') || '<li>Keine Daten</li>';
            const contraItems = combinedContra.map(c => `<li>${c}</li>`).join('') || '<li>Keine Daten</li>';

            // Perspective indicator
            const perspectiveLabel = currentMatchModalView === 'pathos'
                ? 'ğŸ”¥ Pathos-Perspektive (emotional)'
                : 'ğŸ§  Logos-Perspektive (rational)';

            // Generate synthesis section
            const synthesisSection = generateSynthesisSection(myArch, partnerArch);

            // Special banner for identical types
            const identicalTypeBanner = isIdenticalType ? `
                <div style="background: linear-gradient(135deg, rgba(46, 204, 113, 0.15), rgba(46, 204, 113, 0.05));
                            border: 1px solid var(--success); border-radius: 10px; padding: 12px; margin-bottom: 15px; text-align: center;">
                    <div style="font-weight: 600; color: var(--success); margin-bottom: 4px;">âœ“ Identischer Beziehungstyp</div>
                    <div style="font-size: var(--font-sm); color: var(--text-secondary);">
                        Ihr teilt dieselbe GrundÃ¼berzeugung Ã¼ber Beziehungen
                    </div>
                </div>
            ` : '';

            const comboText = `${myArch.name} + ${partnerArch.name}`;
            const myDef = archetypeDescriptions[myArch.id]?.shortDef || '';
            const partnerDef = archetypeDescriptions[partnerArch.id]?.shortDef || '';

            return `
                <div class="modal-feedback-btn" onclick="openFeedbackModalWithContext('${comboText}')">
                    ğŸ’¬ Feedback zu ${comboText}
                </div>

                <div class="match-modal-header">
                    <div class="match-modal-icon" style="background: ${partnerArch.color}">${icons[partnerArch.id]}</div>
                    <div class="match-modal-info">
                        <h3 style="color: ${partnerArch.color}">
                            ${partnerArch.name}
                            <span class="type-info-icon" onclick="openDefinitionModal('${partnerArch.id}')" title="Definition anzeigen">â„¹</span>
                        </h3>
                        <p>${partnerArch.shortDescription || ''}</p>
                    </div>
                </div>

                ${identicalTypeBanner}

                <div class="type-definitions-compact" style="background: var(--bg-dark); border-radius: 10px; padding: 12px; margin-bottom: 15px; font-size: var(--font-sm);">
                    <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                        <div style="flex: 1; min-width: 200px;">
                            <span style="color: ${myArch.color}; font-weight: 600;">${icons[myArch.id]} ${myArch.name}</span>
                            <span class="type-info-icon" onclick="openDefinitionModal('${myArch.id}')" style="margin-left: 4px;">â„¹</span>
                            <div style="color: var(--text-muted); margin-top: 4px; line-height: 1.4;">${myDef}</div>
                        </div>
                        <div style="flex: 1; min-width: 200px;">
                            <span style="color: ${partnerArch.color}; font-weight: 600;">${icons[partnerArch.id]} ${partnerArch.name}</span>
                            <span class="type-info-icon" onclick="openDefinitionModal('${partnerArch.id}')" style="margin-left: 4px;">â„¹</span>
                            <div style="color: var(--text-muted); margin-top: 4px; line-height: 1.4;">${partnerDef}</div>
                        </div>
                    </div>
                </div>

                <div class="match-modal-score">
                    <span class="match-modal-score-label">BeziehungsqualitÃ¤t ${isIdenticalType ? '(gleicher Typ)' : 'mit ' + myArch.name}</span>
                    <span class="match-modal-score-value" style="color: ${scoreColor}">${overall}</span>
                </div>

                <div class="match-modal-categories">
                    <div class="match-modal-categories-title">Kategorie-Bewertungen</div>
                    ${categoryBars}
                </div>

                <div class="match-modal-perspective">${perspectiveLabel}</div>

                <div class="match-modal-section pro">
                    <div class="match-modal-section-title">âœ“ Was funktioniert</div>
                    <ul class="match-modal-list">${proItems}</ul>
                </div>

                <div class="match-modal-section contra">
                    <div class="match-modal-section-title">âœ— Herausforderungen</div>
                    <ul class="match-modal-list">${contraItems}</ul>
                </div>

                ${synthesisSection}
            `;
        }

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeCategoryModal();
            }
        });

        // ==========================================
        // FEEDBACK SYSTEM (entfernt - commentModal wird verwendet)
        // ==========================================
        // Leere Stubs um JavaScript-Fehler zu vermeiden
        function openFeedbackModal() { console.log('feedbackModal entfernt - bitte commentModal verwenden'); }
        function openFeedbackModalWithContext(ctx) { console.log('feedbackModal entfernt - bitte commentModal verwenden'); }
        function closeFeedbackModal(event) { }
        function initStarRatings() { }
        // submitFeedback entfernt - wird nicht mehr verwendet

        // Local storage backup - alles in tiage_comments
        function saveLocalFeedback(entry) {
            const stored = JSON.parse(localStorage.getItem('tiage_comments') || '[]');
            entry.timestamp = new Date().toISOString();
            entry.Typ = 'comment';  // Einheitlicher Typ
            stored.unshift(entry);
            localStorage.setItem('tiage_comments', JSON.stringify(stored));
        }

        function getLocalFeedback() {
            return JSON.parse(localStorage.getItem('tiage_comments') || '[]');
        }

        // Load and display feedback
        async function loadFeedback() {
            const container = document.getElementById('feedbackList');

            try {
                if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                    // Try to load from Google Sheets
                    const response = await fetch(GOOGLE_SCRIPT_URL);
                    const serverData = await response.json();
                    feedbackData = serverData.reverse(); // Newest first
                } else {
                    // Use local data only
                    feedbackData = getLocalFeedback();
                }
            } catch (error) {
                console.error('Load feedback error:', error);
                // Fallback to local
                feedbackData = getLocalFeedback();
            }

            // Populate type filter dropdowns
            populateTypeFilters();
            renderFeedbackList();
        }

        // Populate type dropdowns for filters
        function populateTypeFilters() {
            const archetypes = Object.values(data?.archetypes || {});
            const myTypeSelect = document.getElementById('filterMyType');
            const partnerTypeSelect = document.getElementById('filterPartnerType');

            const options = archetypes.map(a =>
                `<option value="${a.id}">${a.name}</option>`
            ).join('');

            myTypeSelect.innerHTML = `<option value="all">Alle Typen</option>${options}`;
            partnerTypeSelect.innerHTML = `<option value="all">Alle Partner</option>${options}`;
        }

        function renderFeedbackList() {
            const container = document.getElementById('feedbackList');

            // Apply all filters
            let filtered = feedbackData.filter(f => {
                const kontextId = (f.KontextID || f.kontextId || '').toLowerCase();
                const name = (f.Name || f.name || '').toLowerCase();
                const titel = (f.Titel || f.titel || '').toLowerCase();
                const kommentar = (f.Kommentar || f.kommentar || '').toLowerCase();
                const antwortAuf = f.AntwortAuf || f.antwortAuf || '';

                // Skip replies in main list (they'll be shown as threads)
                if (antwortAuf) return false;

                // Search filter
                if (feedbackFilters.search) {
                    const search = feedbackFilters.search.toLowerCase();
                    if (!name.includes(search) && !titel.includes(search) && !kommentar.includes(search)) {
                        return false;
                    }
                }

                // Type filters (parse from context ID like "Single (Ich) mit Duo")
                if (feedbackFilters.myType !== 'all' || feedbackFilters.partnerType !== 'all') {
                    const myTypeName = data?.archetypes?.[feedbackFilters.myType]?.name?.toLowerCase();
                    const partnerTypeName = data?.archetypes?.[feedbackFilters.partnerType]?.name?.toLowerCase();

                    if (feedbackFilters.myType !== 'all' && myTypeName) {
                        if (!kontextId.includes(myTypeName)) return false;
                    }
                    if (feedbackFilters.partnerType !== 'all' && partnerTypeName) {
                        if (!kontextId.includes('mit ' + partnerTypeName)) return false;
                    }
                }

                // Category filter
                if (feedbackFilters.category !== 'all') {
                    const cat = feedbackFilters.category;
                    if (cat === 'TM') {
                        if (!kontextId.includes('top match')) return false;
                    } else if (cat === 'CH') {
                        if (!kontextId.includes('challenge')) return false;
                    } else {
                        // Category A-F: check for category name
                        const catName = categoryNames[cat]?.toLowerCase();
                        if (catName && !kontextId.includes(catName)) return false;
                    }
                }

                return true;
            });

            // Sort
            if (feedbackFilters.sort === 'oldest') {
                filtered = filtered.reverse();
            } else if (feedbackFilters.sort === 'rating') {
                filtered.sort((a, b) => {
                    const aRating = (a.Verstand || a.verstand || 0) + (a.Gefuehl || a.gefuehl || 0);
                    const bRating = (b.Verstand || b.verstand || 0) + (b.Gefuehl || b.gefuehl || 0);
                    return bRating - aRating;
                });
            }

            if (filtered.length === 0) {
                container.innerHTML = `
                    <div class="feedback-empty">
                        ${feedbackData.length === 0
                            ? 'Noch kein Feedback vorhanden.<br>Sei der Erste!'
                            : 'Kein Feedback fÃ¼r diesen Filter.'}
                    </div>
                `;
                return;
            }

            container.innerHTML = filtered.map(f => renderFeedbackItem(f)).join('');
        }

        // Render single feedback item with replies
        function renderFeedbackItem(f, isReply = false) {
            const id = f.Id || f.id || f.timestamp || '';
            const kontextId = f.KontextID || f.kontextId || '-';
            const name = f.Name || f.name || 'Anonym';
            const titel = f.Titel || f.titel || '';
            const kommentar = f.Kommentar || f.kommentar || '';
            const verstand = f.Verstand || f.verstand || 0;
            const gefuehl = f.Gefuehl || f.gefuehl || 0;
            const timestamp = f.Timestamp || f.timestamp || '';

            // Find replies to this item
            const replies = feedbackData.filter(r =>
                (r.AntwortAuf || r.antwortAuf) === id
            );

            const timeStr = timestamp ? new Date(timestamp).toLocaleDateString('de-DE') : '';

            return `
                <div class="feedback-item ${isReply ? 'reply' : ''}" data-id="${id}">
                    <div class="feedback-item-header">
                        <span class="feedback-item-context">${kontextId}</span>
                        <div style="display: flex; align-items: center; gap: 10px;">
                            <span class="feedback-item-name">${name}</span>
                            ${timeStr ? `<span class="feedback-timestamp">${timeStr}</span>` : ''}
                        </div>
                    </div>
                    <div class="feedback-item-title">${titel}</div>
                    ${kommentar ? `<div class="feedback-item-comment">${kommentar}</div>` : ''}
                    <div class="feedback-item-footer">
                        <div class="feedback-item-ratings">
                            <div class="feedback-rating">
                                <span>Verstand:</span>
                                <span class="stars">${'â˜…'.repeat(verstand)}${'â˜†'.repeat(5-verstand)}</span>
                            </div>
                            <div class="feedback-rating">
                                <span>GefÃ¼hl:</span>
                                <span class="stars">${'â˜…'.repeat(gefuehl)}${'â˜†'.repeat(5-gefuehl)}</span>
                            </div>
                        </div>
                        <button class="feedback-reply-btn" onclick="openReplyModal('${id}', '${name}')">
                            â†© Antworten
                        </button>
                    </div>
                    ${replies.length > 0 ? `
                        <div class="feedback-replies">
                            ${replies.map(r => renderFeedbackItem(r, true)).join('')}
                        </div>
                    ` : ''}
                </div>
            `;
        }

        // Open reply modal - uses commentModal (feedbackModal was removed)
        function openReplyModal(parentId, parentName) {
            replyToId = parentId;
            // Open comment modal for replies
            const modal = document.getElementById('commentModal');
            if (modal) {
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';

                // Reset form
                const nameInput = document.getElementById('commentName');
                const textInput = document.getElementById('commentText');
                if (nameInput) nameInput.value = '';
                if (textInput) {
                    textInput.value = '';
                    textInput.placeholder = `Antwort auf ${parentName}...`;
                }
            }
        }

        // Initialize advanced filters
        function initAdvancedFilters() {
            // Search input
            document.getElementById('feedbackSearch').addEventListener('input', (e) => {
                feedbackFilters.search = e.target.value;
                renderFeedbackList();
            });

            // Type selects
            document.getElementById('filterMyType').addEventListener('change', (e) => {
                feedbackFilters.myType = e.target.value;
                renderFeedbackList();
            });

            document.getElementById('filterPartnerType').addEventListener('change', (e) => {
                feedbackFilters.partnerType = e.target.value;
                renderFeedbackList();
            });

            // Category buttons
            document.querySelectorAll('.cat-filter-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.cat-filter-btn').forEach(b =>
                        b.classList.remove('active')
                    );
                    btn.classList.add('active');
                    feedbackFilters.category = btn.dataset.cat;
                    renderFeedbackList();
                });
            });

            // Sort select
            document.getElementById('filterSort').addEventListener('change', (e) => {
                feedbackFilters.sort = e.target.value;
                renderFeedbackList();
            });
        }

        // Initialize feedback system
        function initFeedbackSystem() {
            initStarRatings();
            initAdvancedFilters();
        }

        // Age Verification - Modal shows once per session (uses sessionStorage)
        function checkAgeVerification() {
            // Check if user already verified age in this session
            try {
                if (sessionStorage.getItem('tiage_age_verified') === 'true') {
                    // Already verified in this session, don't show modal
                    const modal = document.getElementById('ageVerificationModal');
                    if (modal) {
                        modal.classList.add('hidden');
                        modal.style.display = 'none';
                    }
                    return;
                }
            } catch(e) {
                console.warn('Could not check sessionStorage:', e);
            }

            // Show modal for age verification
            const modal = document.getElementById('ageVerificationModal');
            if (modal) {
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
                document.body.style.overflow = 'hidden';
            }
        }

        // Make confirmAge globally available - automatically accepts cookies
        window.confirmAge = function(isAdult) {
            console.log('confirmAge called with:', isAdult);

            if (isAdult) {
                // Save age verification for this session (prevents showing on back navigation)
                try {
                    sessionStorage.setItem('tiage_age_verified', 'true');
                } catch(e) {
                    console.warn('Could not save session age verification:', e);
                }

                // Automatically save cookie consent when user confirms age
                try {
                    localStorage.setItem('tiage_cookie_consent', 'true');
                    localStorage.setItem('tiage_cookie_consent_timestamp', new Date().toISOString());
                } catch(e) {
                    console.warn('Could not save cookie consent:', e);
                }

                // Hide modal
                var modal = document.getElementById('ageVerificationModal');
                if (modal) {
                    modal.classList.add('hidden');
                    modal.style.display = 'none';
                }
                document.body.style.overflow = 'auto';
            } else {
                window.location.href = 'https://www.google.com';
            }
        };

        // Also keep the regular function reference
        function confirmAge(isAdult) {
            window.confirmAge(isAdult);
        }

        // Initialize age verification - robust version with multiple fallbacks
        function initAgeVerification() {
            const modal = document.getElementById('ageVerificationModal');
            const yesButton = document.getElementById('ageVerifyYes');
            const noButton = document.getElementById('ageVerifyNo');

            // Helper function to handle age confirmation - uses sessionStorage
            function handleAgeConfirm(isAdult, event) {
                if (event) {
                    event.preventDefault();
                    event.stopPropagation();
                }
                console.log('handleAgeConfirm called:', isAdult);

                if (isAdult) {
                    // Save age verification for this session (prevents showing on back navigation)
                    try {
                        sessionStorage.setItem('tiage_age_verified', 'true');
                    } catch(e) {
                        console.warn('Could not save session age verification:', e);
                    }

                    if (modal) {
                        modal.classList.add('hidden');
                        modal.style.display = 'none';
                        modal.style.visibility = 'hidden';
                        modal.style.opacity = '0';
                        modal.style.pointerEvents = 'none';
                    }
                    document.body.style.overflow = 'auto';

                    // Check for pending openComments navigation after age verification
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.get('openComments') === '1') {
                        // Remove openComments parameter from URL to prevent loop on back-navigation
                        urlParams.delete('openComments');
                        const cleanUrl = urlParams.toString()
                            ? `${window.location.pathname}?${urlParams.toString()}${window.location.hash}`
                            : `${window.location.pathname}${window.location.hash}`;
                        history.replaceState(null, '', cleanUrl);

                        setTimeout(() => {
                            if (typeof openCommentsListModal === 'function') {
                                openCommentsListModal();
                            }
                        }, 100);
                    }
                } else {
                    window.location.href = 'https://www.google.com';
                }
            }

            // Add event listeners to YES button
            if (yesButton) {
                yesButton.style.pointerEvents = 'auto';
                yesButton.style.cursor = 'pointer';
                yesButton.style.position = 'relative';
                yesButton.style.zIndex = '10002';

                // Remove old onclick to prevent double-firing
                yesButton.removeAttribute('onclick');

                // Add multiple event types for maximum compatibility
                yesButton.addEventListener('click', function(e) {
                    handleAgeConfirm(true, e);
                }, { passive: false, capture: true });

                yesButton.addEventListener('touchend', function(e) {
                    handleAgeConfirm(true, e);
                }, { passive: false, capture: true });

                // Also handle mousedown as fallback
                yesButton.addEventListener('mousedown', function(e) {
                    handleAgeConfirm(true, e);
                }, { passive: false, capture: true });
            }

            // Add event listeners to NO button
            if (noButton) {
                noButton.style.pointerEvents = 'auto';
                noButton.style.cursor = 'pointer';
                noButton.style.position = 'relative';
                noButton.style.zIndex = '10002';

                // Remove old onclick
                noButton.removeAttribute('onclick');

                noButton.addEventListener('click', function(e) {
                    handleAgeConfirm(false, e);
                }, { passive: false, capture: true });

                noButton.addEventListener('touchend', function(e) {
                    handleAgeConfirm(false, e);
                }, { passive: false, capture: true });
            }

            // Check if already verified in this session before showing modal
            try {
                if (sessionStorage.getItem('tiage_age_verified') === 'true') {
                    // Already verified, hide modal
                    if (modal) {
                        modal.classList.add('hidden');
                        modal.style.display = 'none';
                    }
                    return;
                }
            } catch(e) {
                console.warn('Could not check sessionStorage:', e);
            }

            // Show modal on page load if not verified
            if (modal) {
                modal.classList.remove('hidden');
                modal.style.display = 'flex';
                modal.style.visibility = 'visible';
                modal.style.opacity = '1';
                modal.style.pointerEvents = 'auto';
                document.body.style.overflow = 'hidden'; // Prevent scrolling behind modal
            }
        }

        // ========================================
        // Extended Dimensions Functions
        // ========================================

        function showDimensionTooltip(type) {
            // Try to get translated tooltip first, fall back to hardcoded
            let tooltip = TiageI18n.t(`tooltips.${type}`);
            if (!tooltip || typeof tooltip !== 'object' || !tooltip.title) {
                tooltip = dimensionTooltips[type];
            }
            if (!tooltip) return;

            document.getElementById('dimensionTooltipTitle').textContent = tooltip.title;
            document.getElementById('dimensionTooltipText').innerHTML = tooltip.text.replace(/\n/g, '<br>');
            document.getElementById('dimensionTooltipOverlay').classList.add('active');
        }

        function closeDimensionTooltip() {
            document.getElementById('dimensionTooltipOverlay').classList.remove('active');
        }

        // ========================================
        // Geschlecht Info Modal Functions
        // ========================================
        function showGeschlechtInfoModal() {
            document.getElementById('geschlechtInfoModal').classList.add('active');
        }

        function closeGeschlechtInfoModal() {
            document.getElementById('geschlechtInfoModal').classList.remove('active');
        }

        // ========================================
        // Dominanz Info Modal Functions
        // ========================================
        function showDominanzInfoModal() {
            document.getElementById('dominanzInfoModal').classList.add('active');
        }

        function closeDominanzInfoModal() {
            document.getElementById('dominanzInfoModal').classList.remove('active');
        }

        // ========================================
        // Orientierung Info Modal Functions
        // ========================================
        function showOrientierungInfoModal() {
            document.getElementById('orientierungInfoModal').classList.add('active');
        }

        function closeOrientierungInfoModal() {
            document.getElementById('orientierungInfoModal').classList.remove('active');
        }

        // ========================================
        // Body & Soul Info Modal Functions
        // ========================================
        function showBodySoulModal() {
            document.getElementById('bodySoulModal').classList.add('active');
        }

        function closeBodySoulModal() {
            document.getElementById('bodySoulModal').classList.remove('active');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GESCHLECHT PRIMARY/SECONDARY SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Handle click on a Geschlecht button
         * Logic:
         * - First click = Primary (I indicator)
         * - Second click on different = Secondary (G indicator)
         * - Click on Primary = Clear both (primary and secondary)
         * - Click on Secondary = Clear only secondary
         */
        function handleGeschlechtClick(person, geschlechtValue, btn) {
            // Valid geschlecht values
            const validGeschlechtValues = ['cis_mann', 'cis_frau', 'trans_mann', 'trans_frau', 'nonbinaer', 'genderfluid', 'agender', 'intersex', 'divers'];

            // Ensure geschlecht has correct structure (migration from old format)
            if (!personDimensions[person].geschlecht ||
                !('primary' in personDimensions[person].geschlecht)) {
                personDimensions[person].geschlecht = { primary: null, secondary: null };
            }

            // Clean up invalid old values (e.g., 'mÃ¤nnlich', 'weiblich' from old format)
            if (personDimensions[person].geschlecht.primary &&
                !validGeschlechtValues.includes(personDimensions[person].geschlecht.primary)) {
                console.log('[FIX] Clearing invalid primary value:', personDimensions[person].geschlecht.primary);
                personDimensions[person].geschlecht.primary = null;
            }
            if (personDimensions[person].geschlecht.secondary &&
                !validGeschlechtValues.includes(personDimensions[person].geschlecht.secondary)) {
                console.log('[FIX] Clearing invalid secondary value:', personDimensions[person].geschlecht.secondary);
                personDimensions[person].geschlecht.secondary = null;
            }

            const currentPrimary = personDimensions[person].geschlecht.primary;
            const currentSecondary = personDimensions[person].geschlecht.secondary;

            if (geschlechtValue === currentPrimary) {
                // Click on Primary: Clear both
                personDimensions[person].geschlecht.primary = null;
                personDimensions[person].geschlecht.secondary = null;
            } else if (geschlechtValue === currentSecondary) {
                // Click on Secondary: Clear only secondary
                personDimensions[person].geschlecht.secondary = null;
            } else if (!currentPrimary) {
                // No primary yet: Set as primary (handles both null and undefined)
                personDimensions[person].geschlecht.primary = geschlechtValue;
            } else {
                // Primary exists, different value clicked: Set as secondary
                personDimensions[person].geschlecht.secondary = geschlechtValue;
            }

            // Sync with mobilePersonDimensions for mobile view consistency
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions[person].geschlecht.primary = personDimensions[person].geschlecht.primary;
                mobilePersonDimensions[person].geschlecht.secondary = personDimensions[person].geschlecht.secondary;
            }

            // Sync with TiageState if available
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.geschlecht`, personDimensions[person].geschlecht);
                TiageState.saveToStorage(); // Sofort speichern fÃ¼r Persistenz
            }

            // Sync all UIs
            syncGeschlechtUI(person);

            // Remove needs-selection if primary is set
            const hasPrimary = personDimensions[person].geschlecht.primary !== null;
            document.querySelectorAll(`[data-dimension="${person}-geschlecht-new"], [data-dimension="mobile-${person}-geschlecht"], [data-dimension="${person}-geschlecht"]`).forEach(dim => {
                if (hasPrimary) {
                    dim.classList.remove('needs-selection');
                } else {
                    dim.classList.add('needs-selection');
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX: Resonanzfaktoren bei Geschlecht-Wechsel neu berechnen
            // R4 (IdentitÃ¤t) hÃ¤ngt vom Geschlecht ab und muss aktualisiert werden
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personArchetyp = person === 'ich' ? currentArchetype : selectedPartner;
                let needs = null;

                // Hole Needs aus LoadedArchetypProfile
                const flatNeeds = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                // Fallback: Standard-Werte des Archetyps
                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[personArchetyp]) {
                        needs = GfkBeduerfnisse.archetypProfile[personArchetyp].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: personArchetyp,
                    needs: needs,
                    dominanz: personDimensions[person]?.dominanz || null,
                    orientierung: personDimensions[person]?.orientierung || null,
                    geschlecht: personDimensions[person]?.geschlecht || null
                };

                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    const resonanzLoaded = ResonanzCard.loadCalculatedValues(resonanzProfileContext, person);
                    if (resonanzLoaded) {
                        console.log('[TIAGE] Resonanzfaktoren nach Geschlecht-Wechsel aktualisiert fÃ¼r', person);
                    }
                }
            }

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * Handle click on geschlecht button
         * v4.0: Geschlecht ist jetzt ein einfacher String (mann, frau, nonbinaer)
         */
        function handleGeschlechtPClick(person, value, btn) {
            console.log('[TIAGE] handleGeschlechtPClick (v4.0):', person, value);

            // v4.0: Geschlecht als einfacher String
            const currentGeschlecht = personDimensions[person].geschlecht;

            if (value === currentGeschlecht) {
                // Click on same: Deselect
                personDimensions[person].geschlecht = null;
            } else {
                // Click on different: Set new value
                personDimensions[person].geschlecht = value;
            }

            // v4.0: Kein S-Grid mehr nÃ¶tig - verstecken falls noch sichtbar
            const sRow = document.getElementById(`${person}-geschlecht-s-row`);
            if (sRow) sRow.style.display = 'none';

            // Sync and save
            syncGeschlechtState(person);
            syncGeschlechtUI(person);
            updateGeschlechtNeedsSelection(person);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX: Resonanzfaktoren bei Geschlecht-Wechsel neu berechnen
            // R4 (IdentitÃ¤t) hÃ¤ngt vom Geschlecht ab und muss aktualisiert werden
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personArchetyp = person === 'ich' ? currentArchetype : selectedPartner;
                let needs = null;

                const flatNeeds = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[personArchetyp]) {
                        needs = GfkBeduerfnisse.archetypProfile[personArchetyp].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: personArchetyp,
                    needs: needs,
                    dominanz: personDimensions[person]?.dominanz || null,
                    orientierung: personDimensions[person]?.orientierung || null,
                    geschlecht: personDimensions[person]?.geschlecht || null
                };

                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    ResonanzCard.loadCalculatedValues(resonanzProfileContext, person);
                }
            }

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * Handle click on S (IdentitÃ¤t) geschlecht button
         * S = Secondary = IdentitÃ¤t (kontextabhÃ¤ngig von P)
         */
        function handleGeschlechtSClick(person, value, btn) {
            console.log('[TIAGE] handleGeschlechtSClick:', person, value);

            // Ensure geschlecht has correct structure
            if (!personDimensions[person].geschlecht) {
                personDimensions[person].geschlecht = { primary: null, secondary: null };
            }

            const currentSecondary = personDimensions[person].geschlecht.secondary;

            if (value === currentSecondary) {
                // Click on same S: Deselect S
                personDimensions[person].geschlecht.secondary = null;
            } else {
                // Click on different S: Set new S
                personDimensions[person].geschlecht.secondary = value;
            }

            // Sync and save
            syncGeschlechtState(person);
            syncGeschlechtUI(person);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX: Resonanzfaktoren bei Geschlecht-Wechsel neu berechnen
            // R4 (IdentitÃ¤t) hÃ¤ngt vom Geschlecht ab und muss aktualisiert werden
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personArchetyp = person === 'ich' ? currentArchetype : selectedPartner;
                let needs = null;

                const flatNeeds = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[personArchetyp]) {
                        needs = GfkBeduerfnisse.archetypProfile[personArchetyp].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: personArchetyp,
                    needs: needs,
                    dominanz: personDimensions[person]?.dominanz || null,
                    orientierung: personDimensions[person]?.orientierung || null,
                    geschlecht: personDimensions[person]?.geschlecht || null
                };

                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    ResonanzCard.loadCalculatedValues(resonanzProfileContext, person);
                }
            }

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * Update S-Grid options based on P selection
         * P = Mann/Frau â†’ S = Cis, Trans, NonbinÃ¤r
         * P = Inter â†’ S = NonbinÃ¤r, Fluid
         */
        function updateGeschlechtSGrid(person) {
            const primary = personDimensions[person].geschlecht?.primary;

            // Desktop S-Grid
            const sRow = document.getElementById(`${person}-geschlecht-s-row`);
            const sGrid = document.getElementById(`${person}-geschlecht-s-grid`);

            // Mobile S-Grid
            const mobileSRow = document.getElementById(`mobile-${person}-geschlecht-s-row`);
            const mobileSGrid = document.getElementById(`mobile-${person}-geschlecht-s-grid`);

            // Helper to update a single S grid
            function updateSingleSGrid(row, grid) {
                if (!row || !grid) return;

                if (!primary) {
                    // No P selected: hide S row
                    row.style.display = 'none';
                    grid.innerHTML = '';
                    return;
                }

                // Show S row
                row.style.display = 'block';

                // Get S options based on P
                let sOptions;
                if (primary === 'inter') {
                    sOptions = [
                        { value: 'nonbinaer', label: TiageI18n.t('geschlecht.secondary.nonbinaer', 'NonbinÃ¤r') },
                        { value: 'fluid', label: TiageI18n.t('geschlecht.secondary.fluid', 'Fluid') }
                    ];
                } else {
                    // Mann or Frau: Cis, Trans, NonbinÃ¤r (3 options - matches profile-config.js)
                    sOptions = [
                        { value: 'cis', label: TiageI18n.t('geschlecht.secondary.cis', 'Cis') },
                        { value: 'trans', label: TiageI18n.t('geschlecht.secondary.trans', 'Trans') },
                        { value: 'nonbinaer', label: TiageI18n.t('geschlecht.secondary.nonbinaer', 'NonbinÃ¤r') }
                    ];
                }

                // Populate S grid (include secondary-selected class if already selected)
                const currentSecondary = personDimensions[person].geschlecht?.secondary;
                grid.innerHTML = sOptions.map(opt => {
                    const isSelected = opt.value === currentSecondary;
                    const selectedClass = isSelected ? ' secondary-selected' : '';
                    return `<button type="button" class="geschlecht-btn geschlecht-s-btn${selectedClass}" data-value="${opt.value}" onclick="handleGeschlechtSClick('${person}', '${opt.value}', this)">${opt.label}${isSelected ? '<span class="geschlecht-indicator indicator-secondary" title="IdentitÃ¤t (SekundÃ¤r)">S</span>' : ''}</button>`;
                }).join('');
            }

            // Update Desktop S-Grid
            updateSingleSGrid(sRow, sGrid);

            // Update Mobile S-Grid
            updateSingleSGrid(mobileSRow, mobileSGrid);
        }

        /**
         * Sync geschlecht state with mobile/TiageState
         * v4.0: Geschlecht ist jetzt ein einfacher String
         */
        function syncGeschlechtState(person) {
            // v4.0: Geschlecht als String
            const geschlecht = personDimensions[person].geschlecht;

            // Sync with mobilePersonDimensions (fÃ¼r Legacy-KompatibilitÃ¤t)
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions[person].geschlecht = geschlecht;
            }

            // Sync with TiageState
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.geschlecht`, geschlecht);
            }
        }

        /**
         * Update needs-selection class for geschlecht
         * v4.0: PrÃ¼ft ob Geschlecht als String gesetzt ist
         */
        function updateGeschlechtNeedsSelection(person) {
            // v4.0: Geschlecht ist String, nicht Object
            const geschlecht = personDimensions[person].geschlecht;
            const hasGeschlecht = geschlecht !== null && geschlecht !== undefined;
            document.querySelectorAll(`[data-dimension="${person}-geschlecht-multi"], [data-dimension="mobile-${person}-geschlecht"], [data-dimension="mobile-${person}-geschlecht-multi"], [data-dimension="${person}-geschlecht"]`).forEach(dim => {
                if (hasGeschlecht) {
                    dim.classList.remove('needs-selection');
                } else {
                    dim.classList.add('needs-selection');
                }
            });
        }

        // Legacy aliases for backwards compatibility
        function handleGeschlechtClick(person, value, btn) {
            handleGeschlechtPClick(person, value, btn);
        }
        function handleGeschlechtPrimaryClick(person, value, btn) {
            handleGeschlechtPClick(person, value, btn);
        }
        function handleGeschlechtSecondaryClick(person, value, btn) {
            handleGeschlechtSClick(person, value, btn);
        }

        /**
         * Sync Geschlecht UI across all views (Desktop, Mobile, Modal)
         * v4.0: Geschlecht als einfacher String (kein P/S System mehr)
         */
        function syncGeschlechtUI(person) {
            // v4.0: Geschlecht als String
            const geschlecht = personDimensions[person].geschlecht;

            // Update Geschlecht buttons - Desktop and Mobile
            const gridSelectors = [
                `#${person}-geschlecht-p-grid .geschlecht-btn`,
                `#mobile-${person}-geschlecht-p-grid .geschlecht-btn`,
                `#mobile-${person}-geschlecht-grid .geschlecht-btn`,
                `#modal-${person}-geschlecht-grid .geschlecht-btn`
            ];
            gridSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(btn => {
                    const value = btn.dataset.value;
                    btn.classList.remove('primary-selected', 'primary-strikethrough', 'secondary-selected', 'selected');

                    // Remove existing indicators
                    const existingIndicator = btn.querySelector('.geschlecht-indicator');
                    if (existingIndicator) existingIndicator.remove();

                    if (value === geschlecht) {
                        btn.classList.add('selected', 'primary-selected');
                    }
                });
            });

            // v4.0: S-Grid verstecken (nicht mehr benÃ¶tigt)
            const sRow = document.getElementById(`${person}-geschlecht-s-row`);
            if (sRow) sRow.style.display = 'none';

            // LEGACY: S-Grid buttons leeren
            const sGridSelectors = [
                `#${person}-geschlecht-s-grid .geschlecht-btn`,
                `#mobile-${person}-geschlecht-s-grid .geschlecht-btn`
            ];
            sGridSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(btn => {
                    btn.classList.remove('secondary-selected');
                });
            });

            // Legacy: Update old combined grids (mobile etc.)
            const legacySelectors = [
                `#mobile-${person}-geschlecht-grid .geschlecht-btn`,
                `#modal-${person}-geschlecht-grid .geschlecht-btn`
            ];

            legacySelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(btn => {
                    const value = btn.dataset.value;
                    btn.classList.remove('primary-selected', 'secondary-selected', 'primary-strikethrough');

                    const existingIndicator = btn.querySelector('.geschlecht-indicator');
                    if (existingIndicator) existingIndicator.remove();

                    // v4.0: Geschlecht ist jetzt ein einfacher String, kein P/S System
                    if (value === geschlecht) {
                        btn.classList.add('primary-selected');
                    }
                });
            });

            // Also sync legacy radio buttons if they exist
            document.querySelectorAll(`input[name="${person}-geschlecht"]`).forEach(radio => {
                radio.checked = (radio.value === geschlecht);
            });
            document.querySelectorAll(`input[name="mobile-${person}-geschlecht"]`).forEach(radio => {
                radio.checked = (radio.value === geschlecht);
            });

            // Ensure S-Grid visibility is correct
            updateGeschlechtSGrid(person);

            // Update collapsed summary for geschlecht
            updateGeschlechtSummary(person);
        }

        /**
         * Update secondary geschlecht from external source (e.g., Profile Review Modal)
         * Syncs personDimensions with the new value and updates UI
         * @param {string} person - 'ich' or 'partner'
         * @param {string} secondaryValue - New secondary value ('mann', 'frau', 'nonbinaer', 'fluid', 'suchend')
         */
        function setSecondaryGeschlechtAndSync(person, secondaryValue) {
            if (!personDimensions[person].geschlecht) {
                personDimensions[person].geschlecht = { primary: null, secondary: null };
            }
            personDimensions[person].geschlecht.secondary = secondaryValue;

            // Sync to TiageState
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.geschlecht.secondary`, secondaryValue);
            }

            // Update UI
            syncGeschlechtUI(person);

            console.log('[Geschlecht] Secondary updated and synced:', person, 'â†’', secondaryValue);
        }
        window.setSecondaryGeschlechtAndSync = setSecondaryGeschlechtAndSync;

        /**
         * Get summary text for geschlecht selection
         */
        function getGeschlechtSummary(person) {
            // v4.0: geschlecht is a simple string, not an object with .primary/.secondary
            const geschlecht = personDimensions[person].geschlecht;
            const primary = typeof geschlecht === 'string' ? geschlecht : (geschlecht?.primary || null);

            if (!primary) {
                return 'Geschlecht fehlt';
            }

            const primaryLabel = TiageI18n.t(`geschlecht.types.${primary}`, primary);
            return 'âœ“ ' + primaryLabel + ' (P)';
        }

        /**
         * Get summary text for geschlecht selection in grid (without 'fehlt' text)
         * Returns selected values in green, or empty string if nothing selected
         */
        function getGeschlechtGridSummary(person) {
            // v4.0: geschlecht is a simple string, not an object with .primary/.secondary
            const geschlecht = personDimensions[person].geschlecht;
            const primary = typeof geschlecht === 'string' ? geschlecht : (geschlecht?.primary || null);

            if (!primary) {
                return ''; // No 'fehlt' text for grid - only show selections
            }

            const primaryLabel = TiageI18n.t(`geschlecht.types.${primary}`, primary);
            return 'âœ“ ' + primaryLabel + ' (P)';
        }

        /**
         * Update header summary for geschlecht (only in header area, not in collapsed-summary)
         */
        function updateGeschlechtSummary(person) {
            const summaryText = getGeschlechtSummary(person);
            const gridSummaryText = getGeschlechtGridSummary(person);
            // v4.0: geschlecht is a simple string, not an object with .primary
            const geschlecht = personDimensions[person].geschlecht;
            const primary = typeof geschlecht === 'string' ? geschlecht : (geschlecht?.primary || null);
            const isMissing = !primary;

            // Update header element (shows 'fehlt' if nothing selected) - Desktop and Mobile
            ['', 'mobile-'].forEach(prefix => {
                const headerId = `${prefix}${person}-header-geschlecht`;
                const header = document.getElementById(headerId);
                if (header) {
                    header.textContent = summaryText;
                    header.classList.toggle('missing', isMissing);
                }
            });

            // Update grid collapsed-summary (only shows selections in green, no 'fehlt')
            ['', 'mobile-'].forEach(prefix => {
                const summaryId = `${prefix}${person}-geschlecht-summary`;
                const summary = document.getElementById(summaryId);
                if (summary) {
                    summary.innerHTML = gridSummaryText;
                    summary.classList.toggle('has-selection', !isMissing);
                }
            });
        }

        /**
         * Check if geschlecht has any selection (primary)
         */
        function hasGeschlechtSelected(person) {
            // v4.0: geschlecht is a simple string, not an object with .primary
            const geschlecht = personDimensions[person].geschlecht;
            const primary = typeof geschlecht === 'string' ? geschlecht : (geschlecht?.primary || null);
            return primary !== null;
        }

        /**
         * Handle hover on geschlecht button - highlight I or G in legend
         * Based on click logic: if no primary -> next click sets I, if primary exists -> next click sets G
         */
        function handleGeschlechtHover(person, geschlechtValue, isEntering) {
            const legendSelectors = [
                `#${person}-geschlecht-legend`,
                `#mobile-${person}-geschlecht-legend`
            ];

            legendSelectors.forEach(selector => {
                const legend = document.querySelector(selector);
                if (!legend) return;

                if (!isEntering) {
                    // Mouse left - remove all highlights
                    legend.classList.remove('highlight-p', 'highlight-s');
                    return;
                }

                // Mouse entered - determine which to highlight based on click logic
                const currentPrimary = personDimensions[person].geschlecht.primary;
                const currentSecondary = personDimensions[person].geschlecht.secondary;

                legend.classList.remove('highlight-p', 'highlight-s');

                if (geschlechtValue === currentPrimary || geschlechtValue === currentSecondary) {
                    // Hovering over already selected - highlight what would be affected
                    if (geschlechtValue === currentPrimary) {
                        legend.classList.add('highlight-p');
                    } else {
                        legend.classList.add('highlight-s');
                    }
                } else if (currentPrimary === null) {
                    // No primary yet: next click sets primary (P)
                    legend.classList.add('highlight-p');
                } else {
                    // Primary exists, different value: next click sets secondary (S)
                    legend.classList.add('highlight-s');
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DYNAMISCHE BUTTON-GENERIERUNG (Harmonisierung Desktop/Mobile/Modal)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Initialisiert alle Dimension-Buttons dynamisch
         * Ersetzt statische HTML-Buttons durch dynamisch generierte
         */
        function initDimensionButtons() {
            console.log('[TIAGE DEBUG] initDimensionButtons called');

            // v4.0: Geschlecht als einfacher String (kein Primary/Secondary mehr)
            const geschlechtPOptions = [
                { value: 'mann', label: TiageI18n.t('geschlecht.primary.mann', 'Mann') },
                { value: 'frau', label: TiageI18n.t('geschlecht.primary.frau', 'Frau') },
                { value: 'nonbinaer', label: TiageI18n.t('geschlecht.primary.nonbinaer', 'NonbinÃ¤r') }
            ];

            // LEGACY: S-Optionen bleiben fÃ¼r eventuelle RÃ¼ckwÃ¤rtskompatibilitÃ¤t
            // FÃ¼r P = Mann/Frau: Cis, Trans, NonbinÃ¤r (3 options - matches profile-config.js)
            const geschlechtSOptionsMannFrau = [
                { value: 'cis', label: TiageI18n.t('geschlecht.secondary.cis', 'Cis') },
                { value: 'trans', label: TiageI18n.t('geschlecht.secondary.trans', 'Trans') },
                { value: 'nonbinaer', label: TiageI18n.t('geschlecht.secondary.nonbinaer', 'NonbinÃ¤r') }
            ];
            // FÃ¼r P = Inter: NonbinÃ¤r, Fluid (2 options)
            const geschlechtSOptionsInter = [
                { value: 'nonbinaer', label: TiageI18n.t('geschlecht.secondary.nonbinaer', 'NonbinÃ¤r') },
                { value: 'fluid', label: TiageI18n.t('geschlecht.secondary.fluid', 'Fluid') }
            ];

            // Dominanz Optionen
            const dominanzOptions = [
                { value: 'dominant', label: 'dominant' },
                { value: 'submissiv', label: 'submissiv' },
                { value: 'switch', label: 'switch' },
                { value: 'ausgeglichen', label: 'ausgeglichen' }
            ];

            // v4.0: Orientierung als Multi-Select Array
            // v4.1: 5 separate Orientierungs-Optionen
            const orientierungOptions = [
                { value: 'heterosexuell', label: 'Hetero' },
                { value: 'gay_lesbisch', label: 'Gay/L' },
                { value: 'bisexuell', label: 'Bi' },
                { value: 'pansexuell', label: 'Pan' },
                { value: 'queer', label: 'Queer' }
            ];

            // GFK Optionen (Gewaltfreie Kommunikation / NVC)
            const gfkOptions = [
                { value: 'niedrig', label: TiageI18n.t('dimensions.gfkLevels.niedrig', 'niedrig') },
                { value: 'mittel', label: TiageI18n.t('dimensions.gfkLevels.mittel', 'mittel') },
                { value: 'hoch', label: TiageI18n.t('dimensions.gfkLevels.hoch', 'hoch') }
            ];

            // Geschlecht P-Grids befÃ¼llen (KÃ¶rper: Mann, Frau, Inter)
            // Use both class selector and explicit IDs as fallback (including mobile)
            const pGridSelectors = ['.geschlecht-p-grid', '#ich-geschlecht-p-grid', '#partner-geschlecht-p-grid', '#mobile-ich-geschlecht-p-grid', '#mobile-partner-geschlecht-p-grid'];
            const processedPGrids = new Set();
            pGridSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(grid => {
                    if (processedPGrids.has(grid.id)) return;
                    processedPGrids.add(grid.id);
                    const person = grid.dataset.person;
                    console.log('[TIAGE DEBUG] Processing p-grid for person:', person, 'id:', grid.id);
                    if (!person) return;
                    grid.innerHTML = geschlechtPOptions.map(opt =>
                        `<button type="button" class="geschlecht-btn geschlecht-p-btn" data-value="${opt.value}" onclick="handleGeschlechtPClick('${person}', '${opt.value}', this)">${opt.label}</button>`
                    ).join('');
                });
            });
            console.log('[TIAGE DEBUG] Processed geschlecht-p-grids:', processedPGrids.size);

            // Mobile und Modal Geschlecht-Grids befÃ¼llen (kombiniertes P/S Grid)
            const mobileModalGrids = document.querySelectorAll('#mobile-ich-geschlecht-grid, #mobile-partner-geschlecht-grid, #modal-ich-geschlecht-grid, #modal-partner-geschlecht-grid');
            console.log('[TIAGE DEBUG] Found mobile/modal geschlecht-grids:', mobileModalGrids.length);
            mobileModalGrids.forEach(grid => {
                const person = grid.dataset.person;
                if (!person) return;
                // Mobile/Modal uses combined P options with handleGeschlechtClick
                grid.innerHTML = geschlechtPOptions.map(opt =>
                    `<button type="button" class="geschlecht-btn" data-value="${opt.value}" onclick="handleGeschlechtClick('${person}', '${opt.value}', this)">${opt.label}</button>`
                ).join('');
            });

            // Geschlecht S-Grids werden dynamisch in handleGeschlechtPClick befÃ¼llt
            // (kontextabhÃ¤ngig von P-Auswahl)

            // Dominanz-Grids befÃ¼llen (nur Desktop mit data-person)
            // Use both class selector and explicit IDs as fallback
            const dGridSelectors = ['.dominanz-grid[data-person]', '#ich-dominanz-grid', '#partner-dominanz-grid'];
            const processedDGrids = new Set();
            dGridSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(grid => {
                    if (processedDGrids.has(grid.id)) return;
                    processedDGrids.add(grid.id);
                    const person = grid.dataset.person;
                    console.log('[TIAGE DEBUG] Processing dominanz-grid for person:', person, 'id:', grid.id);
                    if (!person) return;
                    grid.innerHTML = dominanzOptions.map(opt =>
                        `<button type="button" class="dominanz-btn" data-value="${opt.value}" onclick="handleDominanzClick('${person}', '${opt.value}', this)">${opt.label}</button>`
                    ).join('');
                });
            });
            console.log('[TIAGE DEBUG] Processed dominanz-grids:', processedDGrids.size);

            // Orientierung-Grids befÃ¼llen (nur Desktop mit data-person)
            // Use both class selector and explicit IDs as fallback
            const oGridSelectors = ['.orientierung-grid[data-person]', '#ich-orientierung-grid', '#partner-orientierung-grid'];
            const processedOGrids = new Set();
            oGridSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(grid => {
                    if (processedOGrids.has(grid.id)) return;
                    processedOGrids.add(grid.id);
                    const person = grid.dataset.person;
                    console.log('[TIAGE DEBUG] Processing orientierung-grid for person:', person, 'id:', grid.id);
                    if (!person) return;
                    grid.innerHTML = orientierungOptions.map(opt =>
                        `<button type="button" class="orientierung-btn" data-value="${opt.value}" onclick="handleOrientierungClick('${person}', '${opt.value}', this)">${opt.label}</button>`
                    ).join('');
                });
            });
            console.log('[TIAGE DEBUG] Processed orientierung-grids:', processedOGrids.size);

            // GFK-Grids befÃ¼llen
            // Use both class selector and explicit IDs as fallback
            const gfkGridSelectors = ['.gfk-grid[data-person]', '#ich-gfk-grid', '#partner-gfk-grid', '#mobile-ich-gfk-grid', '#mobile-partner-gfk-grid'];
            const processedGfkGrids = new Set();
            gfkGridSelectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(grid => {
                    if (processedGfkGrids.has(grid.id)) return;
                    processedGfkGrids.add(grid.id);
                    const person = grid.dataset.person;
                    console.log('[TIAGE DEBUG] Processing gfk-grid for person:', person, 'id:', grid.id);
                    if (!person) return;
                    grid.innerHTML = gfkOptions.map(opt =>
                        `<button type="button" class="gfk-btn" data-value="${opt.value}" onclick="handleGfkClick('${person}', '${opt.value}', this)">${opt.label}</button>`
                    ).join('');
                });
            });
            console.log('[TIAGE DEBUG] Processed gfk-grids:', processedGfkGrids.size);

            // UI mit gespeichertem State synchronisieren
            ['ich', 'partner'].forEach(person => {
                syncGeschlechtUI(person);
                syncDominanzUI(person);
                syncOrientierungUI(person);
                syncGfkUI(person);
            });

            console.log('[TIAGE DEBUG] initDimensionButtons completed');
        }

        /**
         * Initialize geschlecht hover events for all grids
         */
        function initGeschlechtHoverEvents() {
            document.querySelectorAll('.geschlecht-grid').forEach(grid => {
                const person = grid.dataset.person;
                if (!person) return;

                grid.querySelectorAll('.geschlecht-btn').forEach(btn => {
                    const value = btn.dataset.value;

                    btn.addEventListener('mouseenter', () => {
                        handleGeschlechtHover(person, value, true);
                    });

                    btn.addEventListener('mouseleave', () => {
                        handleGeschlechtHover(person, value, false);
                    });
                });
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DOMINANZ PRIMARY/SECONDARY SYSTEM (same logic as GeschlechtsidentitÃ¤t)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Handle click on a Dominanz button
         * Logic (same as GeschlechtsidentitÃ¤t):
         * - First click = Primary (I indicator)
         * - Second click on different = Secondary (G indicator)
         * - Click on Primary = Clear both (primary and secondary)
         * - Click on Secondary = Clear only secondary
         */
        function handleDominanzClick(person, dominanzValue, btn) {
            console.log('[TIAGE] handleDominanzClick:', person, dominanzValue);

            // Ensure dominanz has correct structure (migration from old format)
            if (!personDimensions[person].dominanz ||
                !('primary' in personDimensions[person].dominanz)) {
                personDimensions[person].dominanz = { primary: null, secondary: null };
            }

            const currentPrimary = personDimensions[person].dominanz.primary;
            const currentSecondary = personDimensions[person].dominanz.secondary;

            if (dominanzValue === currentPrimary) {
                // Click on Primary: Clear both
                personDimensions[person].dominanz.primary = null;
                personDimensions[person].dominanz.secondary = null;
            } else if (dominanzValue === currentSecondary) {
                // Click on Secondary: Clear only secondary
                personDimensions[person].dominanz.secondary = null;
            } else if (!currentPrimary) {
                // No primary yet: Set as primary (handles both null and undefined)
                personDimensions[person].dominanz.primary = dominanzValue;
            } else {
                // Primary exists, different value clicked: Set as secondary
                personDimensions[person].dominanz.secondary = dominanzValue;
            }

            // Sync with mobilePersonDimensions for mobile view consistency
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions[person].dominanz.primary = personDimensions[person].dominanz.primary;
                mobilePersonDimensions[person].dominanz.secondary = personDimensions[person].dominanz.secondary;
            }

            // Sync with TiageState if available
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.dominanz`, personDimensions[person].dominanz);
                TiageState.saveToStorage(); // Sofort speichern fÃ¼r Persistenz
            }

            // Sync all UIs
            syncDominanzUI(person);

            // Remove needs-selection if primary is set
            const hasPrimary = personDimensions[person].dominanz.primary !== null;
            document.querySelectorAll(`[data-dimension="${person}-dominanz-multi"], [data-dimension="mobile-${person}-dominanz"], [data-dimension="${person}-dominanz"]`).forEach(dim => {
                if (hasPrimary) {
                    dim.classList.remove('needs-selection');
                } else {
                    dim.classList.add('needs-selection');
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX: Resonanzfaktoren bei Dominanz-Wechsel neu berechnen
            // R3 (Dynamik) hÃ¤ngt von der Dominanz ab und muss aktualisiert werden
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personArchetyp = person === 'ich' ? currentArchetype : selectedPartner;
                let needs = null;

                // Hole Needs aus LoadedArchetypProfile
                const flatNeeds = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                // Fallback: Standard-Werte des Archetyps
                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[personArchetyp]) {
                        needs = GfkBeduerfnisse.archetypProfile[personArchetyp].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: personArchetyp,
                    needs: needs,
                    dominanz: personDimensions[person]?.dominanz || null,
                    orientierung: personDimensions[person]?.orientierung || null,
                    geschlecht: personDimensions[person]?.geschlecht || null
                };

                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    const resonanzLoaded = ResonanzCard.loadCalculatedValues(resonanzProfileContext, person);
                    if (resonanzLoaded) {
                        console.log('[TIAGE] Resonanzfaktoren nach Dominanz-Wechsel aktualisiert fÃ¼r', person);
                    }
                }
            }

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * GEMEINSAME Funktion: Sync UI fÃ¼r Dominanz oder Orientierung
         * Aktualisiert Buttons in Desktop, Mobile und Modal
         *
         * @param {string} person - 'ich' oder 'partner'
         * @param {string} dimension - 'dominanz' oder 'orientierung'
         */
        function syncDimensionUI(person, dimension) {
            const data = personDimensions[person][dimension];
            if (!data) return;

            const primary = data.primary;
            const secondary = data.secondary;

            // Button-Selektoren fÃ¼r diese Dimension
            const selectors = [
                `.${dimension}-grid[data-person="${person}"] .${dimension}-btn`,
                `#${person}-${dimension}-grid .${dimension}-btn`,
                `#mobile-${person}-${dimension}-grid .${dimension}-btn`,
                `#modal-${person}-${dimension}-grid .${dimension}-btn`
            ];

            selectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(btn => {
                    const value = btn.dataset.value;

                    // Alle States entfernen
                    btn.classList.remove('primary-selected', 'secondary-selected');

                    // Bestehende Indikatoren entfernen
                    const existingIndicator = btn.querySelector('.geschlecht-indicator');
                    if (existingIndicator) {
                        existingIndicator.remove();
                    }

                    // Passenden State und Indikator hinzufÃ¼gen
                    if (value === primary) {
                        btn.classList.add('primary-selected');
                        const indicator = document.createElement('span');
                        indicator.className = 'geschlecht-indicator indicator-primary';
                        indicator.textContent = 'P';
                        indicator.title = 'PrimÃ¤r';
                        btn.appendChild(indicator);
                    } else if (value === secondary) {
                        btn.classList.add('secondary-selected');
                        const indicator = document.createElement('span');
                        indicator.className = 'geschlecht-indicator indicator-secondary';
                        indicator.textContent = 'S';
                        indicator.title = 'SekundÃ¤r';
                        btn.appendChild(indicator);
                    }
                });
            });

            // Summary aktualisieren
            if (dimension === 'dominanz') {
                updateDominanzSummary(person);
            } else if (dimension === 'orientierung') {
                updateOrientierungSummary(person);
            }

            // Mobile Status-Toggle-Buttons synchronisieren (einheitlich fÃ¼r Desktop und Mobile)
            if (typeof syncMobileStatusButtons === 'function') {
                syncMobileStatusButtons(person, dimension);
            }
        }

        // Wrapper fÃ¼r RÃ¼ckwÃ¤rtskompatibilitÃ¤t
        function syncDominanzUI(person) {
            syncDimensionUI(person, 'dominanz');
        }

        /**
         * GEMEINSAME Funktion: Summary-Text fÃ¼r eine Dimension erstellen
         *
         * @param {string} person - 'ich' oder 'partner'
         * @param {string} dimension - 'dominanz' oder 'orientierung'
         * @param {boolean} showMissing - true = zeigt "fehlt", false = zeigt ""
         */
        function getDimensionSummary(person, dimension, showMissing = true) {
            const data = personDimensions[person][dimension];
            if (!data) return showMissing ? `${dimension} fehlt` : '';

            const primary = data.primary;
            const secondary = data.secondary;

            if (!primary) {
                // Dimension-Name mit GroÃŸbuchstabe fÃ¼r "fehlt" Text
                const label = dimension.charAt(0).toUpperCase() + dimension.slice(1);
                return showMissing ? `${label} fehlt` : '';
            }

            const parts = [primary + ' (P)'];
            if (secondary) {
                parts.push(secondary + ' (S)');
            }

            return 'âœ“ ' + parts.join(', ');
        }

        // Wrapper fÃ¼r RÃ¼ckwÃ¤rtskompatibilitÃ¤t
        function getDominanzSummary(person) {
            return getDimensionSummary(person, 'dominanz', true);
        }

        function getDominanzGridSummary(person) {
            return getDimensionSummary(person, 'dominanz', false);
        }

        /**
         * Update header summary for dominanz (only in header area, not in collapsed-summary)
         */
        function updateDominanzSummary(person) {
            const summaryText = getDominanzSummary(person);
            const gridSummaryText = getDominanzGridSummary(person);
            const isMissing = !personDimensions[person].dominanz.primary;

            // Update header element (shows 'fehlt' if nothing selected) - Desktop and Mobile
            ['', 'mobile-'].forEach(prefix => {
                const headerId = `${prefix}${person}-header-dominanz`;
                const header = document.getElementById(headerId);
                if (header) {
                    header.textContent = summaryText;
                    header.classList.toggle('missing', isMissing);
                }
            });

            // Update grid collapsed-summary (only shows selections in green, no 'fehlt')
            ['', 'mobile-'].forEach(prefix => {
                const summaryId = `${prefix}${person}-dominanz-summary`;
                const summary = document.getElementById(summaryId);
                if (summary) {
                    summary.textContent = gridSummaryText;
                    summary.classList.toggle('has-selection', !isMissing);
                }
            });

            // Update needs-selection classes
            ['', 'mobile-', 'modal-'].forEach(prefix => {
                const dim = document.querySelector(`[data-dimension="${prefix}${person}-dominanz-multi"]`);
                if (dim) {
                    if (!isMissing) dim.classList.remove('needs-selection');
                    else dim.classList.add('needs-selection');
                }
            });
        }

        // Helper: Check if any dominanz is selected (for backwards compatibility)
        function hasAnyDominanzSelected(person) {
            return personDimensions[person].dominanz.primary !== null;
        }

        // Get the primary dominanz type (for backwards compatibility)
        function getPrimaryFaktDominanz(person) {
            return personDimensions[person].dominanz.primary;
        }

        // Get the primary orientierung type (for backwards compatibility)
        function getPrimaryFaktOrientierung(person) {
            return personDimensions[person].orientierung.primary;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ORIENTIERUNG PRIMARY/SECONDARY SYSTEM (same logic as GeschlechtsidentitÃ¤t)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Soft Warning Card - Sanftere Warnung im Card-Style
         * Ersetzt die harten browser alert() Dialoge
         * @param {Object} options - Konfiguration
         * @param {string} options.title - Titel der Warnung
         * @param {string} options.message - Hauptnachricht
         * @param {string} [options.detail] - Detailtext (optional)
         * @param {Array} [options.examples] - Erlaubte Beispiele (optional)
         * @param {Function} [options.onClose] - Callback beim SchlieÃŸen
         */
        function showSoftWarning(options = {}) {
            const {
                title = 'Hinweis',
                message = '',
                detail = '',
                examples = [],
                onClose = null
            } = options;

            // Overlay erstellen
            const overlay = document.createElement('div');
            overlay.className = 'soft-warning-overlay';
            overlay.setAttribute('role', 'dialog');
            overlay.setAttribute('aria-modal', 'true');
            overlay.setAttribute('aria-label', title);

            // Card erstellen
            const card = document.createElement('div');
            card.className = 'soft-warning-card';

            // Icon
            const icon = document.createElement('div');
            icon.className = 'soft-warning-card__icon';
            icon.innerHTML = 'ğŸ’¡';

            // Title
            const titleEl = document.createElement('h3');
            titleEl.className = 'soft-warning-card__title';
            titleEl.textContent = title;

            // Message
            const messageEl = document.createElement('p');
            messageEl.className = 'soft-warning-card__message';
            messageEl.textContent = message;

            // Detail (optional)
            let detailEl = null;
            if (detail) {
                detailEl = document.createElement('p');
                detailEl.className = 'soft-warning-card__detail';
                detailEl.textContent = detail;
            }

            // Examples (optional)
            let examplesEl = null;
            if (examples && examples.length > 0) {
                examplesEl = document.createElement('div');
                examplesEl.className = 'soft-warning-card__examples';

                const examplesTitle = document.createElement('span');
                examplesTitle.className = 'soft-warning-card__examples-title';
                examplesTitle.textContent = 'Aber erlaubt ist z.B.:';
                examplesEl.appendChild(examplesTitle);

                examples.forEach(example => {
                    const item = document.createElement('div');
                    item.className = 'soft-warning-card__example-item';
                    item.textContent = example;
                    examplesEl.appendChild(item);
                });
            }

            // Button
            const btn = document.createElement('button');
            btn.className = 'soft-warning-card__btn';
            btn.textContent = 'Verstanden';

            // Card zusammenbauen
            card.appendChild(icon);
            card.appendChild(titleEl);
            card.appendChild(messageEl);
            if (detailEl) card.appendChild(detailEl);
            if (examplesEl) card.appendChild(examplesEl);
            card.appendChild(btn);
            overlay.appendChild(card);

            // Zum Body hinzufÃ¼gen
            document.body.appendChild(overlay);

            // Animation triggern
            requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                    overlay.classList.add('soft-warning-overlay--visible');
                });
            });

            // Close-Handler
            function handleClose() {
                overlay.classList.remove('soft-warning-overlay--visible');
                setTimeout(() => {
                    overlay.remove();
                    if (typeof onClose === 'function') {
                        onClose();
                    }
                }, 250);
            }

            // Event-Listener
            btn.addEventListener('click', handleClose);
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) {
                    handleClose();
                }
            });

            // Escape/Enter schlieÃŸen
            function handleKeydown(e) {
                if (e.key === 'Escape' || e.key === 'Enter') {
                    handleClose();
                    document.removeEventListener('keydown', handleKeydown);
                }
            }
            document.addEventListener('keydown', handleKeydown);

            // Focus auf Button
            btn.focus();
        }

        /**
         * Handle click on an Orientierung button
         * v4.0: Multi-Select Array - Klick togglet Wert im Array
         */
        function handleOrientierungClick(person, orientierungValue, btn) {
            console.log('[TIAGE] handleOrientierungClick (v4.1 Multi-Select + KO):', person, orientierungValue);

            // v4.0: Orientierung als Array (Multi-Select)
            if (!Array.isArray(personDimensions[person].orientierung)) {
                // Migration: Falls altes Format, zu Array konvertieren
                const oldOri = personDimensions[person].orientierung;
                personDimensions[person].orientierung = [];
                if (oldOri) {
                    if (typeof oldOri === 'string') {
                        personDimensions[person].orientierung.push(oldOri);
                    } else if (oldOri.primary) {
                        personDimensions[person].orientierung.push(oldOri.primary);
                        if (oldOri.secondary) {
                            personDimensions[person].orientierung.push(oldOri.secondary);
                        }
                    }
                }
            }

            const orientierungen = personDimensions[person].orientierung;
            const index = orientierungen.indexOf(orientierungValue);

            if (index > -1) {
                // Bereits ausgewÃ¤hlt: Entfernen (Toggle off) - immer erlaubt
                orientierungen.splice(index, 1);
            } else {
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // v4.1.1: KO-Kriterien mit PRIMÃ„R/SEKUNDÃ„R System
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Erstes Element im Array = PRIMÃ„R (Hauptorientierung)
                // Weitere Elemente = SEKUNDÃ„R (Exploration, Offenheit)
                // Nur primÃ¤re Konflikte werden blockiert (Hetero+Gay)
                const exclusionRules = TiageConfig.ORIENTIERUNG_EXCLUSION_RULES || {};

                if (orientierungen.length === 0) {
                    // Array leer: Neue Auswahl wird PRIMÃ„R
                    orientierungen.push(orientierungValue);
                    console.log('[TIAGE] PrimÃ¤re Orientierung gesetzt:', orientierungValue);
                } else {
                    // Array nicht leer: Neue Auswahl wird SEKUNDÃ„R
                    // PrÃ¼fe ob primÃ¤re Orientierung (erstes Element) mit neuer kompatibel ist
                    const primaryOrientation = orientierungen[0];
                    const excludedByPrimary = exclusionRules[primaryOrientation] || [];

                    if (excludedByPrimary.includes(orientierungValue)) {
                        // KO: PrimÃ¤re Orientierung ist mit neuer inkompatibel
                        const primaryLabel = TiageConfig.ORIENTIERUNG_LABELS[primaryOrientation] || primaryOrientation;
                        const newLabel = TiageConfig.ORIENTIERUNG_LABELS[orientierungValue] || orientierungValue;

                        showSoftWarning({
                            title: 'Diese Kombination ist nicht mÃ¶glich',
                            message: `"${primaryLabel}" (primÃ¤r) ist mit "${newLabel}" inkompatibel.`,
                            detail: 'Nur Hetero und Gay/Lesbisch kÃ¶nnen nicht kombiniert werden.',
                            examples: [
                                'Hetero (primÃ¤r) + Pan (sekundÃ¤r)',
                                'Gay (primÃ¤r) + Queer (sekundÃ¤r)'
                            ]
                        });
                        console.log('[TIAGE] KO-Kriterium verletzt:', primaryOrientation, '(primÃ¤r) schlieÃŸt', orientierungValue, 'aus');
                        return;  // Abbrechen
                    }

                    // PrÃ¼fe umgekehrt: WÃ¼rde neue Auswahl die primÃ¤re ausschlieÃŸen?
                    const excludedByNew = exclusionRules[orientierungValue] || [];
                    if (excludedByNew.includes(primaryOrientation)) {
                        // KO: Neue Auswahl ist mit primÃ¤rer inkompatibel
                        const primaryLabel = TiageConfig.ORIENTIERUNG_LABELS[primaryOrientation] || primaryOrientation;
                        const newLabel = TiageConfig.ORIENTIERUNG_LABELS[orientierungValue] || orientierungValue;

                        showSoftWarning({
                            title: 'Diese Kombination ist nicht mÃ¶glich',
                            message: `"${newLabel}" ist mit "${primaryLabel}" (primÃ¤r) inkompatibel.`,
                            detail: `Wenn Sie "${newLabel}" als primÃ¤re Orientierung setzen mÃ¶chten, entfernen Sie zuerst "${primaryLabel}".`
                        });
                        console.log('[TIAGE] KO-Kriterium verletzt:', orientierungValue, 'schlieÃŸt', primaryOrientation, '(primÃ¤r) aus');
                        return;  // Abbrechen
                    }

                    // HinzufÃ¼gen erlaubt als SEKUNDÃ„R
                    orientierungen.push(orientierungValue);
                    console.log('[TIAGE] SekundÃ¤re Orientierung hinzugefÃ¼gt:', orientierungValue);
                }
            }

            // Sync with mobilePersonDimensions
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions[person].orientierung = [...orientierungen];
            }

            // Sync with TiageState
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.orientierung`, orientierungen);
                TiageState.saveToStorage();
            }

            // Sync UI
            syncOrientierungUI(person);

            // Update needs-selection class
            const hasOrientierung = orientierungen.length > 0;
            document.querySelectorAll(`[data-dimension="${person}-orientierung-multi"], [data-dimension="mobile-${person}-orientierung"], [data-dimension="${person}-orientierung"]`).forEach(dim => {
                if (hasOrientierung) {
                    dim.classList.remove('needs-selection');
                } else {
                    dim.classList.add('needs-selection');
                }
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX: Resonanzfaktoren bei Orientierung-Wechsel neu berechnen
            // R1 (Leben) hÃ¤ngt von der Orientierung ab und muss aktualisiert werden
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personArchetyp = person === 'ich' ? currentArchetype : selectedPartner;
                let needs = null;

                // Hole Needs aus LoadedArchetypProfile
                const flatNeeds = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                // Fallback: Standard-Werte des Archetyps
                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[personArchetyp]) {
                        needs = GfkBeduerfnisse.archetypProfile[personArchetyp].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: personArchetyp,
                    needs: needs,
                    dominanz: personDimensions[person]?.dominanz || null,
                    orientierung: personDimensions[person]?.orientierung || null,
                    geschlecht: personDimensions[person]?.geschlecht || null
                };

                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    const resonanzLoaded = ResonanzCard.loadCalculatedValues(resonanzProfileContext, person);
                    if (resonanzLoaded) {
                        console.log('[TIAGE] Resonanzfaktoren nach Orientierung-Wechsel aktualisiert fÃ¼r', person);
                    }
                }
            }

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * v4.2: Handler fÃ¼r Mobile Orientierung Status Toggle (PrimÃ¤r/SekundÃ¤r Buttons)
         * Styled wie Dominanz fÃ¼r konsistente Mobile UX
         */
        function handleOrientierungStatusToggle(person, orientierungValue, status, btn) {
            console.log('[TIAGE] handleOrientierungStatusToggle:', person, orientierungValue, status);

            // Ensure array format
            if (!Array.isArray(personDimensions[person].orientierung)) {
                const oldOri = personDimensions[person].orientierung;
                personDimensions[person].orientierung = [];
                if (oldOri) {
                    if (typeof oldOri === 'string') {
                        personDimensions[person].orientierung.push(oldOri);
                    } else if (oldOri.primary) {
                        personDimensions[person].orientierung.push(oldOri.primary);
                        if (oldOri.secondary) {
                            personDimensions[person].orientierung.push(oldOri.secondary);
                        }
                    }
                }
            }

            const orientierungen = personDimensions[person].orientierung;
            const currentIndex = orientierungen.indexOf(orientierungValue);
            const exclusionRules = TiageConfig.ORIENTIERUNG_EXCLUSION_RULES || {};

            if (status === 'primaer') {
                // Handle PrimÃ¤r button click
                if (currentIndex === 0) {
                    // Already primary - toggle off (remove)
                    orientierungen.splice(0, 1);
                    console.log('[TIAGE] PrimÃ¤re Orientierung entfernt:', orientierungValue);
                } else if (currentIndex > 0) {
                    // Currently secondary - promote to primary
                    // Check if current primary is compatible
                    const currentPrimary = orientierungen[0];
                    const excludedByNew = exclusionRules[orientierungValue] || [];

                    if (excludedByNew.includes(currentPrimary)) {
                        // KO: Would conflict with current primary as secondary
                        showSoftWarning({
                            title: 'Diese Kombination ist nicht mÃ¶glich',
                            message: `"${TiageConfig.ORIENTIERUNG_LABELS[orientierungValue] || orientierungValue}" ist mit "${TiageConfig.ORIENTIERUNG_LABELS[currentPrimary] || currentPrimary}" inkompatibel.`,
                            detail: 'Nur Hetero und Gay/Lesbisch kÃ¶nnen nicht kombiniert werden.'
                        });
                        return;
                    }

                    // Remove from current position
                    orientierungen.splice(currentIndex, 1);
                    // Insert at front as new primary
                    orientierungen.unshift(orientierungValue);
                    console.log('[TIAGE] Orientierung zu PrimÃ¤r befÃ¶rdert:', orientierungValue);
                } else {
                    // Not selected - add as primary
                    if (orientierungen.length > 0) {
                        // Check if new primary is compatible with existing secondaries
                        const excludedByNew = exclusionRules[orientierungValue] || [];
                        for (const existing of orientierungen) {
                            if (excludedByNew.includes(existing)) {
                                showSoftWarning({
                                    title: 'Diese Kombination ist nicht mÃ¶glich',
                                    message: `"${TiageConfig.ORIENTIERUNG_LABELS[orientierungValue] || orientierungValue}" ist mit "${TiageConfig.ORIENTIERUNG_LABELS[existing] || existing}" inkompatibel.`,
                                    detail: 'Nur Hetero und Gay/Lesbisch kÃ¶nnen nicht kombiniert werden.'
                                });
                                return;
                            }
                        }
                    }
                    // Insert at front as new primary
                    orientierungen.unshift(orientierungValue);
                    console.log('[TIAGE] Neue PrimÃ¤re Orientierung:', orientierungValue);
                }
            } else if (status === 'sekundaer') {
                // Handle SekundÃ¤r button click
                if (currentIndex > 0) {
                    // Already secondary - toggle off (remove)
                    orientierungen.splice(currentIndex, 1);
                    console.log('[TIAGE] SekundÃ¤re Orientierung entfernt:', orientierungValue);
                } else if (currentIndex === 0) {
                    // Currently primary - demote to secondary (needs another primary)
                    if (orientierungen.length === 1) {
                        // Only this one selected - cannot demote without another primary
                        showSoftWarning({
                            title: 'PrimÃ¤r erforderlich',
                            message: 'Bitte wÃ¤hle zuerst eine andere Orientierung als PrimÃ¤r.',
                            detail: 'Mindestens eine PrimÃ¤re Orientierung muss ausgewÃ¤hlt sein.'
                        });
                        return;
                    }
                    // Remove from front
                    orientierungen.shift();
                    // Add at end as secondary
                    orientierungen.push(orientierungValue);
                    console.log('[TIAGE] Orientierung zu SekundÃ¤r degradiert:', orientierungValue);
                } else {
                    // Not selected - add as secondary
                    if (orientierungen.length === 0) {
                        // No primary yet - suggest selecting primary first
                        showSoftWarning({
                            title: 'PrimÃ¤r erforderlich',
                            message: 'Bitte wÃ¤hle zuerst eine PrimÃ¤re Orientierung.',
                            detail: 'SekundÃ¤re Orientierungen ergÃ¤nzen die PrimÃ¤re.'
                        });
                        return;
                    }

                    // Check KO rules
                    const primary = orientierungen[0];
                    const excludedByPrimary = exclusionRules[primary] || [];
                    const excludedByNew = exclusionRules[orientierungValue] || [];

                    if (excludedByPrimary.includes(orientierungValue) || excludedByNew.includes(primary)) {
                        showSoftWarning({
                            title: 'Diese Kombination ist nicht mÃ¶glich',
                            message: `"${TiageConfig.ORIENTIERUNG_LABELS[primary] || primary}" (primÃ¤r) ist mit "${TiageConfig.ORIENTIERUNG_LABELS[orientierungValue] || orientierungValue}" inkompatibel.`,
                            detail: 'Nur Hetero und Gay/Lesbisch kÃ¶nnen nicht kombiniert werden.'
                        });
                        return;
                    }

                    // Add as secondary
                    orientierungen.push(orientierungValue);
                    console.log('[TIAGE] Neue SekundÃ¤re Orientierung:', orientierungValue);
                }
            }

            // Sync with mobilePersonDimensions
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions[person].orientierung = [...orientierungen];
            }

            // Sync with TiageState
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.orientierung`, orientierungen);
                TiageState.saveToStorage();
            }

            // Sync UI
            syncOrientierungUI(person);

            // Update needs-selection class
            const hasOrientierung = orientierungen.length > 0;
            document.querySelectorAll(`[data-dimension="${person}-orientierung-multi"], [data-dimension="mobile-${person}-orientierung"], [data-dimension="${person}-orientierung"]`).forEach(dim => {
                if (hasOrientierung) {
                    dim.classList.remove('needs-selection');
                } else {
                    dim.classList.add('needs-selection');
                }
            });

            // Update Resonanzfaktoren (same as handleOrientierungClick)
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personArchetyp = person === 'ich' ? currentArchetype : selectedPartner;
                let needs = null;

                const flatNeeds = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[personArchetyp]) {
                        needs = GfkBeduerfnisse.archetypProfile[personArchetyp].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: personArchetyp,
                    needs: needs,
                    dominanz: personDimensions[person]?.dominanz || null,
                    orientierung: personDimensions[person]?.orientierung || null,
                    geschlecht: personDimensions[person]?.geschlecht || null
                };

                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    const resonanzLoaded = ResonanzCard.loadCalculatedValues(resonanzProfileContext, person);
                    if (resonanzLoaded) {
                        console.log('[TIAGE] Resonanzfaktoren nach Orientierung-Wechsel aktualisiert fÃ¼r', person);
                    }
                }
            }

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * v4.0: Sync Orientierung UI fÃ¼r Multi-Select Array
         * v4.2: Added support for mobile list-style UI with PrimÃ¤r/SekundÃ¤r toggle buttons
         */
        function syncOrientierungUI(person) {
            const orientierungen = personDimensions[person].orientierung;

            // Falls noch altes Format, nicht crashen
            if (!Array.isArray(orientierungen)) {
                // Fallback auf alte Logik
                syncDimensionUI(person, 'orientierung');
                return;
            }

            // === Desktop/Modal Button-Selektoren (old style with P/S badges) ===
            const selectors = [
                `.orientierung-grid[data-person="${person}"] .orientierung-btn`,
                `#${person}-orientierung-grid .orientierung-btn`,
                `#modal-${person}-orientierung-grid .orientierung-btn`
            ];

            selectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(btn => {
                    const value = btn.dataset.value;

                    // Alle States entfernen
                    btn.classList.remove('primary-selected', 'secondary-selected', 'selected');

                    // Bestehende Indikatoren entfernen
                    const existingIndicator = btn.querySelector('.geschlecht-indicator');
                    if (existingIndicator) existingIndicator.remove();

                    // v4.1.1: PrÃ¼fen ob Wert im Array und ob PrimÃ¤r/SekundÃ¤r
                    const index = orientierungen.indexOf(value);
                    if (index > -1) {
                        if (index === 0) {
                            // PrimÃ¤r (erstes Element)
                            btn.classList.add('selected', 'primary-selected');
                            // P-Indikator hinzufÃ¼gen
                            const indicator = document.createElement('span');
                            indicator.className = 'geschlecht-indicator';
                            indicator.textContent = 'P';
                            btn.appendChild(indicator);
                        } else {
                            // SekundÃ¤r (weitere Elemente)
                            btn.classList.add('selected', 'secondary-selected');
                            // S-Indikator hinzufÃ¼gen
                            const indicator = document.createElement('span');
                            indicator.className = 'geschlecht-indicator';
                            indicator.textContent = 'S';
                            btn.appendChild(indicator);
                        }
                    }
                });
            });

            // === Mobile List-Style UI (v4.2 - Dominanz-like with PrimÃ¤r/SekundÃ¤r buttons) ===
            const mobileGrid = document.querySelector(`#mobile-${person}-orientierung-grid.orientierung-multi-select`);
            if (mobileGrid) {
                // Update each row
                mobileGrid.querySelectorAll('.orientierung-option-row').forEach(row => {
                    const value = row.dataset.value;
                    const index = orientierungen.indexOf(value);

                    // Reset row classes
                    row.classList.remove('has-primary', 'has-secondary');

                    // Reset button states
                    row.querySelectorAll('.status-toggle-btn').forEach(btn => {
                        btn.classList.remove('active-primaer', 'active-sekundaer');
                    });

                    if (index > -1) {
                        if (index === 0) {
                            // This is the primary orientation
                            row.classList.add('has-primary');
                            const primaerBtn = row.querySelector('.status-toggle-btn[data-status="primaer"]');
                            if (primaerBtn) primaerBtn.classList.add('active-primaer');
                        } else {
                            // This is a secondary orientation
                            row.classList.add('has-secondary');
                            const sekundaerBtn = row.querySelector('.status-toggle-btn[data-status="sekundaer"]');
                            if (sekundaerBtn) sekundaerBtn.classList.add('active-sekundaer');
                        }
                    }
                });
            }

            // Summary aktualisieren
            updateOrientierungSummary(person);
        }

        // Wrapper fÃ¼r RÃ¼ckwÃ¤rtskompatibilitÃ¤t (nutzen getDimensionSummary)
        function getOrientierungSummary(person) {
            return getDimensionSummary(person, 'orientierung', true);
        }

        function getOrientierungGridSummary(person) {
            return getDimensionSummary(person, 'orientierung', false);
        }

        /**
         * Update header summary for orientierung (only in header area, not in collapsed-summary)
         * v4.0: UnterstÃ¼tzt Multi-Select Array
         */
        function updateOrientierungSummary(person) {
            const orientierungen = personDimensions[person].orientierung;

            // v4.0: Array-basierte PrÃ¼fung
            const isMissing = !Array.isArray(orientierungen) || orientierungen.length === 0;

            // v4.0: Summary aus Array erstellen
            let summaryText = 'Orientierung fehlt';
            let gridSummaryText = '';
            if (Array.isArray(orientierungen) && orientierungen.length > 0) {
                // Labels fÃ¼r die Werte (v4.1.1: 5 separate Optionen + P/S Indikatoren)
                const labels = {
                    'heterosexuell': 'hetero',
                    'gay_lesbisch': 'gay/L',
                    'bisexuell': 'bi',
                    'pansexuell': 'pan',
                    'queer': 'queer',
                    // Legacy v4.0
                    'pansexuell_queer': 'pan/queer'
                };
                // v4.1.1: Erste = PrimÃ¤r (P), weitere = SekundÃ¤r (S)
                const labelList = orientierungen.map((o, index) => {
                    const label = labels[o] || o;
                    if (index === 0) {
                        return label + ' (P)';  // PrimÃ¤r
                    } else {
                        return label + ' (S)';  // SekundÃ¤r
                    }
                });
                summaryText = 'âœ“ ' + labelList.join(', ');
                gridSummaryText = labelList.join(', ');
            }

            // Update header element (shows 'fehlt' if nothing selected) - Desktop and Mobile
            ['', 'mobile-'].forEach(prefix => {
                const headerId = `${prefix}${person}-header-orientierung`;
                const header = document.getElementById(headerId);
                if (header) {
                    header.textContent = summaryText;
                    header.classList.toggle('missing', isMissing);
                }
            });

            // Update grid collapsed-summary (only shows selections in green, no 'fehlt')
            ['', 'mobile-'].forEach(prefix => {
                const summaryId = `${prefix}${person}-orientierung-summary`;
                const summary = document.getElementById(summaryId);
                if (summary) {
                    summary.textContent = gridSummaryText;
                    summary.classList.toggle('has-selection', !isMissing);
                }
            });

            // Update needs-selection classes
            ['', 'mobile-', 'modal-'].forEach(prefix => {
                const dim = document.querySelector(`[data-dimension="${prefix}${person}-orientierung-multi"]`);
                if (dim) {
                    if (!isMissing) dim.classList.remove('needs-selection');
                    else dim.classList.add('needs-selection');
                }
            });
        }

        // Helper: Check if any orientierung is selected (for backwards compatibility)
        // v4.0: PrÃ¼ft Array-LÃ¤nge
        function hasAnyOrientierungSelected(person) {
            const ori = personDimensions[person].orientierung;
            if (Array.isArray(ori)) return ori.length > 0;
            return ori && ori.primary !== null;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // MOBILE STATUS TOGGLE HANDLERS (Gelebt/Interessiert buttons)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * GEMEINSAME Funktion fÃ¼r Dominanz und Orientierung Status-Toggle
         * Reduziert Code-Duplizierung erheblich!
         *
         * @param {string} person - 'ich' oder 'partner'
         * @param {string} dimension - 'dominanz' oder 'orientierung'
         * @param {string} type - z.B. 'dominant', 'heterosexuell', etc.
         * @param {string} status - 'gelebt' (primary) oder 'interessiert' (secondary)
         */
        function handleStatusToggle(person, dimension, type, status) {
            console.log('[TIAGE] handleStatusToggle:', person, dimension, type, status);

            // Sicherstellen, dass die Datenstruktur existiert
            if (!personDimensions[person][dimension] ||
                !('primary' in personDimensions[person][dimension])) {
                personDimensions[person][dimension] = { primary: null, secondary: null };
            }

            const data = personDimensions[person][dimension];
            const currentPrimary = data.primary;
            const currentSecondary = data.secondary;

            if (status === 'gelebt') {
                // Toggle primary (Gelebt)
                if (currentPrimary === type) {
                    // Schon primary â†’ entfernen
                    data.primary = null;
                    if (currentSecondary === type) {
                        data.secondary = null;
                    }
                } else {
                    // Als primary setzen
                    data.primary = type;
                    if (currentSecondary === type) {
                        data.secondary = null;
                    }
                }
            } else if (status === 'interessiert') {
                // Toggle secondary (Interessiert)
                if (currentSecondary === type) {
                    // Schon secondary â†’ entfernen
                    data.secondary = null;
                } else {
                    // Als secondary setzen (nur wenn nicht schon primary)
                    if (currentPrimary !== type) {
                        data.secondary = type;
                    }
                }
            }

            // Mit mobilePersonDimensions synchronisieren
            if (typeof mobilePersonDimensions !== 'undefined' &&
                mobilePersonDimensions[person]?.[dimension]) {
                mobilePersonDimensions[person][dimension].primary = data.primary;
                mobilePersonDimensions[person][dimension].secondary = data.secondary;
            }

            // Mit TiageState synchronisieren
            if (typeof TiageState !== 'undefined') {
                TiageState.set(`personDimensions.${person}.${dimension}`, data);
            }

            // UI synchronisieren (je nach Dimension)
            if (dimension === 'dominanz') {
                syncDominanzUI(person);
                syncMobileDominanzStatusButtons(person);
            } else if (dimension === 'orientierung') {
                syncOrientierungUI(person);
                syncMobileOrientierungStatusButtons(person);
            }

            // needs-selection aktualisieren
            const hasPrimary = data.primary !== null;
            document.querySelectorAll(`[data-dimension*="${person}-${dimension}"]`).forEach(dim => {
                dim.classList.toggle('needs-selection', !hasPrimary);
            });

            updateComparisonView();

            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        /**
         * Wrapper fÃ¼r Dominanz (behÃ¤lt alte onclick-Aufrufe funktionsfÃ¤hig)
         */
        function handleDominanzStatusToggle(person, dominanzType, status, btn) {
            handleStatusToggle(person, 'dominanz', dominanzType, status);
        }

        /**
         * Wrapper fÃ¼r Orientierung (behÃ¤lt alte onclick-Aufrufe funktionsfÃ¤hig)
         */
        function handleOrientierungStatusToggle(person, orientierungType, status, btn) {
            handleStatusToggle(person, 'orientierung', orientierungType, status);
        }

        /**
         * GEMEINSAME Funktion: Sync mobile status buttons fÃ¼r eine Dimension
         *
         * @param {string} person - 'ich' oder 'partner'
         * @param {string} dimension - 'dominanz' oder 'orientierung'
         */
        function syncMobileStatusButtons(person, dimension) {
            const data = personDimensions[person][dimension];
            if (!data) return;

            const primary = data.primary;
            const secondary = data.secondary;

            // Konfiguration fÃ¼r jede Dimension
            const config = {
                dominanz: {
                    types: ['dominant', 'submissiv', 'switch', 'ausgeglichen'],
                    abbrevs: ['dom', 'sub', 'sw', 'aus'],
                    letter: 'd'
                },
                orientierung: {
                    types: ['heterosexuell', 'homosexuell', 'bisexuell', 'pansexuell', 'queer'],
                    abbrevs: ['het', 'hom', 'bi', 'pan', 'queer'],
                    letter: 'o'
                }
            };

            const { types, abbrevs, letter } = config[dimension];
            const prefix = person === 'ich' ? 'm-ich' : 'm-partner';

            types.forEach((type, i) => {
                const statusGroup = document.getElementById(`${prefix}-${letter}-${abbrevs[i]}-status`);
                if (!statusGroup) return;

                const gelebtBtn = statusGroup.querySelector('[data-status="gelebt"]');
                const interessiertBtn = statusGroup.querySelector('[data-status="interessiert"]');

                if (gelebtBtn) {
                    gelebtBtn.classList.toggle('active-gelebt', primary === type);
                }
                if (interessiertBtn) {
                    interessiertBtn.classList.toggle('active-interessiert', secondary === type);
                }
            });
        }

        // Wrapper fÃ¼r RÃ¼ckwÃ¤rtskompatibilitÃ¤t
        function syncMobileDominanzStatusButtons(person) {
            syncMobileStatusButtons(person, 'dominanz');
        }

        function syncMobileOrientierungStatusButtons(person) {
            syncMobileStatusButtons(person, 'orientierung');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GFK (Gewaltfreie Kommunikation) HANDLER
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Handle click on a GFK button
         * GFK-Wert wird durch die App basierend auf Archetypen berechnet - nicht manuell umschaltbar.
         * Bei Klick wird ein erklÃ¤rendes Modal angezeigt.
         */
        function handleGfkClick(person, gfkValue, btn) {
            // GFK-Wert ist nicht manuell umschaltbar - zeige ErklÃ¤rungsmodal
            showGfkExplanationModal(gfkValue);
        }

        /**
         * GFK-ErklÃ¤rungen fÃ¼r die verschiedenen Level
         */
        const gfkLevelExplanations = {
            niedrig: {
                title: 'Niedrig',
                description: `
                    <p><strong>Niedrige BedÃ¼rfnis-Ãœbereinstimmung</strong> bedeutet, dass die KernbedÃ¼rfnisse der beiden Archetypen stark voneinander abweichen.</p>
                    <p>Dies kann zu Herausforderungen in der Kommunikation fÃ¼hren, da beide Partner unterschiedliche PrioritÃ¤ten haben. Eine bewusste Auseinandersetzung mit den BedÃ¼rfnissen des anderen ist hier besonders wichtig.</p>
                    <p>Typische Unterschiede betreffen oft:</p>
                    <ul style="margin-left: 20px; margin-top: 8px;">
                        <li>Freiheit vs. Sicherheit</li>
                        <li>Autonomie vs. NÃ¤he</li>
                        <li>StabilitÃ¤t vs. SpontaneitÃ¤t</li>
                    </ul>
                `
            },
            mittel: {
                title: 'Mittel',
                description: `
                    <p><strong>Mittlere BedÃ¼rfnis-Ãœbereinstimmung</strong> zeigt eine teilweise Schnittmenge der KernbedÃ¼rfnisse.</p>
                    <p>Es gibt sowohl gemeinsame Grundlagen als auch Bereiche, die Kompromissbereitschaft erfordern. Mit guter Kommunikation kÃ¶nnen diese Unterschiede als bereichernd erlebt werden.</p>
                    <p>Empfehlung: Fokussiert euch auf die gemeinsamen BedÃ¼rfnisse und entwickelt Strategien fÃ¼r die unterschiedlichen PrioritÃ¤ten.</p>
                `
            },
            hoch: {
                title: 'Hoch',
                description: `
                    <p><strong>Hohe BedÃ¼rfnis-Ãœbereinstimmung</strong> bedeutet, dass beide Archetypen Ã¤hnliche KernbedÃ¼rfnisse priorisieren.</p>
                    <p>Dies schafft eine natÃ¼rliche Basis fÃ¼r VerstÃ¤ndnis und kann die Kommunikation erleichtern. Beide Partner sprechen oft intuitiv die gleiche "BedÃ¼rfnis-Sprache".</p>
                    <p>Dies ist ein guter Ausgangspunkt - dennoch bleibt achtsame Kommunikation wichtig, da auch bei hoher Ãœbereinstimmung individuelle Unterschiede bestehen.</p>
                `
            }
        };

        /**
         * Zeigt das GFK-ErklÃ¤rungsmodal an
         */
        function showGfkExplanationModal(level) {
            const modal = document.getElementById('gfkExplanationModal');
            const badge = document.getElementById('gfkModalLevelBadge');
            const explanation = document.getElementById('gfkModalExplanation');

            if (!modal || !level) return;

            // Level-spezifische Daten
            const data = gfkLevelExplanations[level] || gfkLevelExplanations.niedrig;

            // Badge aktualisieren
            badge.textContent = data.title;
            badge.className = 'gfk-level-indicator gfk-level-' + level;

            // ErklÃ¤rung aktualisieren
            explanation.innerHTML = data.description;

            // Modal Ã¶ffnen
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        /**
         * SchlieÃŸt das GFK-ErklÃ¤rungsmodal
         */
        function closeGfkExplanationModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('gfkExplanationModal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        /**
         * Ã–ffnet das BedÃ¼rfnis-Vergleich Modal
         * @param {string} type - 'gemeinsam' oder 'unterschiedlich'
         */
        function openNeedsCompareModal(type) {
            const modal = document.getElementById('needsCompareModal');
            const body = document.getElementById('needsCompareModalBody');
            const title = document.getElementById('needsCompareModalTitle');

            if (!modal || !body) return;

            // Matching-Daten holen - SchlÃ¼ssel unverÃ¤ndert lassen (duo_flex, nicht duo-flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';

            if (!ichArchetyp || !partnerArchetyp) {
                body.innerHTML = '<p style="color: var(--text-muted);">Keine Daten verfÃ¼gbar.</p>';
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            const ichName = archetypeDescriptions[currentArchetype]?.name || 'ICH';
            const partnerName = archetypeDescriptions[selectedPartner]?.name || 'Partner';

            // NEU: Direkt aus TiageState.flatNeeds lesen
            let matching = null;
            let isFallback = false;

            // PrimÃ¤r: Direkt aus TiageState.flatNeeds
            const result = calculateNeedsMatchFromFlatNeeds();
            if (result) {
                // Format-Konvertierung: need â†’ { label, id, wert1, wert2, diff }
                const formatNeed = (item) => ({
                    label: formatBeduerfnisLabel(item.need),
                    id: item.need,
                    wert1: item.wert1,
                    wert2: item.wert2,
                    diff: Math.abs(item.wert1 - item.wert2)
                });

                // Top 10 fÃ¼r gemeinsam/unterschiedlich
                const allGemeinsam = [...result.gemeinsam, ...result.komplementaer].map(formatNeed);
                const allUnterschiedlich = result.unterschiedlich.map(formatNeed);

                // Nach Durchschnittswert sortieren (hÃ¶chste zuerst)
                allGemeinsam.sort((a, b) => ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2));
                allUnterschiedlich.sort((a, b) => ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2));

                matching = {
                    topUebereinstimmungen: allGemeinsam.slice(0, 10),
                    topKonflikte: allUnterschiedlich.slice(0, 10)
                };
                console.log('[openNeedsCompareModal] âœ“ Verwende individualisierte Werte aus TiageState.flatNeeds');
            }

            // Fallback: Alte Methode (nur Archetyp - falls flatNeeds leer)
            if (!matching && typeof GfkBeduerfnisse !== 'undefined') {
                matching = GfkBeduerfnisse.berechneMatching(ichArchetyp, partnerArchetyp);
                isFallback = true;
                console.log('[openNeedsCompareModal] âš  Fallback: Verwende Archetyp-basierte BedÃ¼rfniswerte');
            }

            if (!matching) {
                body.innerHTML = '<p style="color: var(--text-muted);">Keine Daten verfÃ¼gbar.</p>';
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            // Titel setzen
            if (type === 'gemeinsam') {
                title.textContent = 'Gemeinsame BedÃ¼rfnisse';
            } else {
                title.textContent = 'Unterschiedliche PrioritÃ¤ten';
            }

            // Daten fÃ¼r Anzeige vorbereiten
            const items = type === 'gemeinsam'
                ? (matching.topUebereinstimmungen || [])
                : (matching.topKonflikte || []);

            if (items.length === 0) {
                body.innerHTML = '<p style="color: var(--text-muted);">Keine EintrÃ¤ge vorhanden.</p>';
            } else {
                let html = '';

                // Fallback-Hinweis (nur wenn Archetyp-basierte Werte verwendet werden)
                if (isFallback) {
                    html += `
                        <div style="
                            background: rgba(234, 179, 8, 0.1);
                            border: 1px solid rgba(234, 179, 8, 0.3);
                            border-radius: 6px;
                            padding: 8px 12px;
                            margin-bottom: 16px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        ">
                            <span style="font-size: 14px;">â„¹ï¸</span>
                            <div style="flex: 1;">
                                <div style="font-size: 11px; font-weight: 600; color: #eab308; margin-bottom: 2px;">Archetyp-Basis-Werte</div>
                                <div style="font-size: 10px; color: var(--text-muted); line-height: 1.4;">
                                    Individualisierte Werte nicht verfÃ¼gbar. Es werden Standard-Archetyp-Werte angezeigt.
                                </div>
                            </div>
                        </div>
                    `;
                }

                html += `
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 16px;">
                        <div style="text-align: center; font-weight: 600; color: var(--success); font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">
                            ${ichName}
                        </div>
                        <div style="text-align: center; font-weight: 600; color: var(--danger); font-size: 12px; text-transform: uppercase; letter-spacing: 1px;">
                            ${partnerName}
                        </div>
                    </div>
                    <div style="display: flex; flex-direction: column; gap: 8px;">
                `;

                items.forEach(item => {
                    // item.id ist jetzt #B-ID, item.label ist der Display-Name
                    const label = item.label;
                    const wert1 = item.wert1 || 0;
                    const wert2 = item.wert2 || 0;
                    const diff = Math.abs(wert1 - wert2);

                    // Status-Icon und Farbe
                    let statusIcon, statusColor, statusText;
                    if (diff <= 15) {
                        statusIcon = 'âœ“';
                        statusColor = '#22c55e';
                        statusText = 'Ãœbereinstimmung';
                    } else if (diff <= 35) {
                        statusIcon = '~';
                        statusColor = '#eab308';
                        statusText = 'KomplementÃ¤r';
                    } else {
                        statusIcon = 'âœ—';
                        statusColor = '#ef4444';
                        statusText = 'Unterschied';
                    }

                    html += `
                        <div style="background: rgba(255,255,255,0.05); border-radius: 8px; padding: 12px; border-left: 3px solid ${statusColor};">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                                <span onclick="openNeedWithResonance('${item.id}')" style="font-weight: 500; color: var(--text-primary); cursor: pointer; display: inline-flex; align-items: center; gap: 4px; transition: color 0.2s;" onmouseover="this.style.color='var(--primary)'" onmouseout="this.style.color='var(--text-primary)'">${label} <span style="font-size: 10px; opacity: 0.5;">â“˜</span></span>
                                <span style="color: ${statusColor}; font-size: 11px; font-weight: 600;">${statusIcon} ${statusText}</span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div style="flex: 1; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert1}%; height: 100%; background: var(--success); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 35px; text-align: right;">${wert1}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <div style="flex: 1; height: 6px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert2}%; height: 100%; background: var(--danger); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 35px; text-align: right;">${wert2}</span>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += '</div>';

                // Info-Box hinzufÃ¼gen
                const infoText = type === 'gemeinsam'
                    ? 'Gemeinsame BedÃ¼rfnisse bilden das Fundament eurer Verbindung. Hier kÃ¶nnt ihr euch gegenseitig stÃ¤rken.'
                    : 'Unterschiedliche PrioritÃ¤ten zeigen Wachstumspotential. Diese Bereiche erfordern bewusste Kommunikation.';

                html += `
                    <div style="margin-top: 16px; padding: 12px; background: rgba(139,92,246,0.08); border-radius: 8px; border: 1px solid rgba(139,92,246,0.2);">
                        <p style="font-size: 12px; color: var(--text-secondary); margin: 0; line-height: 1.5;">${infoText}</p>
                    </div>
                `;

                body.innerHTML = html;
            }

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        /**
         * SchlieÃŸt das BedÃ¼rfnis-Vergleich Modal
         */
        function closeNeedsCompareModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('needsCompareModal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BEDÃœRFNIS-DEFINITIONEN MODAL
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Detaillierte Definitionen fÃ¼r alle BedÃ¼rfnisse
         * Basierend auf GFK (Gewaltfreie Kommunikation) nach Marshall Rosenberg
         */
        const needDefinitions = {
            // EXISTENZ
            luft: {
                "#ID": "#B1",
                label: "Luft",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das grundlegende BedÃ¼rfnis nach frischer Luft und freiem Atmen â€“ sowohl physisch als auch metaphorisch als Raum zum Durchatmen."
            },
            wasser: {
                "#ID": "#B2",
                label: "Wasser",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das BedÃ¼rfnis nach FlÃ¼ssigkeit und Erfrischung â€“ die Basis kÃ¶rperlicher VitalitÃ¤t."
            },
            nahrung: {
                "#ID": "#B3",
                label: "Nahrung",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das BedÃ¼rfnis nach NÃ¤hrung â€“ kÃ¶rperlich durch Essen, aber auch emotional durch nÃ¤hrende Beziehungen."
            },
            bewegung: {
                "#ID": "#B4",
                label: "Bewegung/BetÃ¤tigung",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das BedÃ¼rfnis nach kÃ¶rperlicher AktivitÃ¤t, Bewegung und dem Ausdruck von Lebensenergie durch den KÃ¶rper."
            },
            beruehrung: {
                "#ID": "#B5",
                label: "BerÃ¼hrung/KÃ¶rperkontakt",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das tiefe menschliche BedÃ¼rfnis nach physischem Kontakt, HautnÃ¤he und der WÃ¤rme eines anderen KÃ¶rpers."
            },
            erholung: {
                "#ID": "#B6",
                label: "Erholung/Schlaf",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das BedÃ¼rfnis nach Ruhe, Regeneration und ausreichend Schlaf zur Wiederherstellung von KÃ¶rper und Geist."
            },
            sexueller_ausdruck: {
                "#ID": "#B7",
                label: "Sexueller Ausdruck",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das BedÃ¼rfnis nach sexueller Entfaltung, kÃ¶rperlicher Lust und dem intimen Ausdruck von Begehren und Verbindung."
            },
            sicherheit_physisch: {
                "#ID": "#B8",
                label: "Physische Sicherheit",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das grundlegende BedÃ¼rfnis nach kÃ¶rperlicher Unversehrtheit und Schutz vor physischen Bedrohungen."
            },
            unterschlupf: {
                "#ID": "#B9",
                label: "Unterschlupf",
                kategorie: "Existenz",
                kategorieColor: "#E63946",
                definition: "Das BedÃ¼rfnis nach einem geschÃ¼tzten Raum, einem Zuhause und einem sicheren Ort zum Sein."
            },

            // SICHERHEIT
            bestaendigkeit: {
                "#ID": "#B10",
                label: "BestÃ¤ndigkeit",
                kategorie: "Sicherheit",
                kategorieColor: "#F4A261",
                definition: "Das BedÃ¼rfnis nach KontinuitÃ¤t, VerlÃ¤sslichkeit und der Gewissheit, dass Dinge bleiben und nicht plÃ¶tzlich verschwinden."
            },
            sich_sicher_fuehlen: {
                "#ID": "#B11",
                label: "Sich sicher fÃ¼hlen",
                kategorie: "Sicherheit",
                kategorieColor: "#F4A261",
                definition: "Das emotionale BedÃ¼rfnis nach innerer Sicherheit â€“ zu wissen, dass man in der Beziehung gehalten wird."
            },
            schutz: {
                "#ID": "#B12",
                label: "Schutz",
                kategorie: "Sicherheit",
                kategorieColor: "#F4A261",
                definition: "Das BedÃ¼rfnis, beschÃ¼tzt zu werden oder andere zu beschÃ¼tzen â€“ ein GefÃ¼hl von FÃ¼rsorge und Wachsamkeit."
            },
            stabilitaet: {
                "#ID": "#B13",
                label: "StabilitÃ¤t",
                kategorie: "Sicherheit",
                kategorieColor: "#F4A261",
                definition: "Das BedÃ¼rfnis nach einem festen Grund unter den FÃ¼ÃŸen â€“ emotionale und praktische BestÃ¤ndigkeit in der Beziehung."
            },
            leichtigkeit: {
                "#ID": "#B14",
                label: "Leichtigkeit",
                kategorie: "Sicherheit",
                kategorieColor: "#F4A261",
                definition: "Das BedÃ¼rfnis, sich entspannt und unbeschwert fÃ¼hlen zu kÃ¶nnen, ohne stÃ¤ndige Sorgen oder Anspannung."
            },
            geborgenheit: {
                "#ID": "#B15",
                label: "Geborgenheit",
                kategorie: "Sicherheit",
                kategorieColor: "#F4A261",
                definition: "Das tiefe BedÃ¼rfnis nach WÃ¤rme, Schutz und dem GefÃ¼hl, in der Beziehung vollstÃ¤ndig aufgefangen zu sein."
            },

            // ZUNEIGUNG
            waerme: {
                "#ID": "#B16",
                label: "WÃ¤rme",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis nach emotionaler WÃ¤rme â€“ Herzlichkeit, Zugewandtheit und liebevoller PrÃ¤senz."
            },
            wertschaetzung: {
                "#ID": "#B17",
                label: "WertschÃ¤tzung",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis, in seinem Wert erkannt und geschÃ¤tzt zu werden â€“ fÃ¼r das, was man ist und beitrÃ¤gt."
            },
            naehe: {
                "#ID": "#B18",
                label: "NÃ¤he",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis nach emotionaler und kÃ¶rperlicher NÃ¤he â€“ die Verbindung, die entsteht, wenn man sich einander Ã¶ffnet."
            },
            gesellschaft: {
                "#ID": "#B19",
                label: "Gesellschaft",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis nach Gemeinschaft und Zusammensein â€“ nicht allein zu sein, sondern Zeit miteinander zu verbringen."
            },
            intimitaet: {
                "#ID": "#B20",
                label: "IntimitÃ¤t",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis nach tiefer, ungeschÃ¼tzter Verbindung â€“ das Teilen von Innerem ohne Masken."
            },
            liebe: {
                "#ID": "#B21",
                label: "Liebe",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das universelle BedÃ¼rfnis, zu lieben und geliebt zu werden â€“ die kraftvollste Form menschlicher Verbindung."
            },
            fuersorge: {
                "#ID": "#B22",
                label: "FÃ¼rsorge",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis, fÃ¼r jemanden zu sorgen oder umsorgt zu werden â€“ aktive Zuwendung und KÃ¼mmern."
            },
            unterstuetzung: {
                "#ID": "#B23",
                label: "UnterstÃ¼tzung",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis nach Hilfe und Beistand â€“ zu wissen, dass jemand da ist, wenn man UnterstÃ¼tzung braucht."
            },
            fuereinander_da_sein: {
                "#ID": "#B24",
                label: "FÃ¼reinander da sein",
                kategorie: "Zuneigung",
                kategorieColor: "#E84393",
                definition: "Das BedÃ¼rfnis nach gegenseitiger PrÃ¤senz und VerfÃ¼gbarkeit â€“ fÃ¼reinander Zeit und Raum zu haben."
            },

            // VERSTÃ„NDNIS
            akzeptanz: {
                "#ID": "#B25",
                label: "Akzeptanz",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis, so angenommen zu werden, wie man ist â€“ ohne Bedingungen oder den Druck, sich Ã¤ndern zu mÃ¼ssen."
            },
            mitgefuehl: {
                "#ID": "#B26",
                label: "MitgefÃ¼hl",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis nach einfÃ¼hlsamer Anteilnahme â€“ dass jemand mit einem fÃ¼hlt, nicht nur versteht."
            },
            beruecksichtigung: {
                "#ID": "#B27",
                label: "BerÃ¼cksichtigung",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis, dass die eigenen BedÃ¼rfnisse, WÃ¼nsche und Grenzen in Betracht gezogen werden."
            },
            empathie: {
                "#ID": "#B28",
                label: "Empathie",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis nach tiefem Verstanden-Werden â€“ dass jemand sich in die eigene Welt einfÃ¼hlt."
            },
            vertrauen: {
                "#ID": "#B29",
                label: "Vertrauen",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das fundamentale BedÃ¼rfnis nach Vertrauen â€“ die Gewissheit, dass man sich auf den anderen verlassen kann."
            },
            beachtung: {
                "#ID": "#B30",
                label: "Beachtung",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis nach Aufmerksamkeit â€“ wahrgenommen und nicht Ã¼bersehen zu werden."
            },
            gesehen_werden: {
                "#ID": "#B31",
                label: "Gesehen werden",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das tiefe BedÃ¼rfnis, in seiner Essenz erkannt zu werden â€“ wirklich gesehen, nicht nur oberflÃ¤chlich."
            },
            verstanden_werden: {
                "#ID": "#B32",
                label: "Verstanden werden",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis, dass die eigene Perspektive, GefÃ¼hle und BeweggrÃ¼nde wirklich nachvollzogen werden."
            },
            harmonie: {
                "#ID": "#B33",
                label: "Harmonie",
                kategorie: "VerstÃ¤ndnis",
                kategorieColor: "#9B5DE5",
                definition: "Das BedÃ¼rfnis nach Einklang und Frieden â€“ ein konfliktfreies, ausgeglichenes Miteinander."
            },

            // FREIHEIT
            selbstbestimmung: {
                "#ID": "#B34",
                label: "Selbstbestimmung",
                kategorie: "Freiheit",
                kategorieColor: "#2A9D8F",
                definition: "Das BedÃ¼rfnis, das eigene Leben und die eigenen Entscheidungen selbst zu gestalten â€“ Autonomie Ã¼ber das eigene Sein."
            },
            waehlen_koennen: {
                "#ID": "#B35",
                label: "WÃ¤hlen kÃ¶nnen",
                kategorie: "Freiheit",
                kategorieColor: "#2A9D8F",
                definition: "Das BedÃ¼rfnis nach Wahlfreiheit â€“ Optionen zu haben und frei entscheiden zu kÃ¶nnen."
            },
            unabhaengigkeit: {
                "#ID": "#B36",
                label: "UnabhÃ¤ngigkeit",
                kategorie: "Freiheit",
                kategorieColor: "#2A9D8F",
                definition: "Das BedÃ¼rfnis nach EigenstÃ¤ndigkeit â€“ nicht von anderen abhÃ¤ngig oder kontrolliert zu sein."
            },
            raum_haben: {
                "#ID": "#B37",
                label: "Raum haben",
                kategorie: "Freiheit",
                kategorieColor: "#2A9D8F",
                definition: "Das BedÃ¼rfnis nach persÃ¶nlichem Freiraum â€“ Zeit und Raum fÃ¼r sich selbst, ohne Erwartungen."
            },
            spontaneitaet: {
                "#ID": "#B38",
                label: "SpontaneitÃ¤t",
                kategorie: "Freiheit",
                kategorieColor: "#2A9D8F",
                definition: "Das BedÃ¼rfnis nach Freiheit von Planung â€“ impulsiv handeln kÃ¶nnen, dem Moment folgen."
            },

            // TEILNAHME
            zusammenarbeit: {
                "#ID": "#B39",
                label: "Zusammenarbeit",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das BedÃ¼rfnis, gemeinsam an etwas zu arbeiten â€“ als Team zu agieren und gemeinsame Ziele zu verfolgen."
            },
            kommunikation: {
                "#ID": "#B40",
                label: "Kommunikation",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das BedÃ¼rfnis nach Austausch und Dialog â€“ Gedanken, GefÃ¼hle und Ideen miteinander zu teilen."
            },
            gemeinschaft: {
                "#ID": "#B41",
                label: "Gemeinschaft",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das BedÃ¼rfnis nach ZugehÃ¶rigkeit zu einer Gruppe â€“ Teil von etwas GrÃ¶ÃŸerem zu sein."
            },
            zugehoerigkeit: {
                "#ID": "#B42",
                label: "ZugehÃ¶rigkeit",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das tiefe BedÃ¼rfnis, dazuzugehÃ¶ren â€“ ein GefÃ¼hl von 'Hier bin ich richtig, hier gehÃ¶re ich hin'."
            },
            gegenseitigkeit: {
                "#ID": "#B43",
                label: "Gegenseitigkeit",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das BedÃ¼rfnis nach balanciertem Geben und Nehmen â€“ ein ausgewogener Austausch, bei dem beide Seiten beitragen und empfangen."
            },
            respekt: {
                "#ID": "#B44",
                label: "Respekt",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das BedÃ¼rfnis nach Achtung und WÃ¼rdigung â€“ als Mensch respektiert und ernst genommen zu werden."
            },
            bedeutung_haben: {
                "#ID": "#B45",
                label: "Bedeutung haben",
                kategorie: "Teilnahme",
                kategorieColor: "#06D6A0",
                definition: "Das BedÃ¼rfnis, fÃ¼r andere wichtig zu sein â€“ einen Unterschied zu machen und eine bedeutungsvolle Rolle zu haben."
            },

            // MUSSE
            schoenheit: {
                "#ID": "#B46",
                label: "SchÃ¶nheit",
                kategorie: "MuÃŸe",
                kategorieColor: "#118AB2",
                definition: "Das BedÃ¼rfnis nach Ã¤sthetischem Erleben â€“ SchÃ¶nheit wahrzunehmen und sich davon berÃ¼hren zu lassen."
            },
            freizeit: {
                "#ID": "#B47",
                label: "Freizeit",
                kategorie: "MuÃŸe",
                kategorieColor: "#118AB2",
                definition: "Das BedÃ¼rfnis nach freier, ungeplanter Zeit â€“ Raum fÃ¼r Erholung, Spiel und Nichtstun."
            },
            freude: {
                "#ID": "#B48",
                label: "Freude",
                kategorie: "MuÃŸe",
                kategorieColor: "#118AB2",
                definition: "Das BedÃ¼rfnis nach Freude und VergnÃ¼gen â€“ Momente der Leichtigkeit und des GlÃ¼cks."
            },
            humor: {
                "#ID": "#B49",
                label: "Humor",
                kategorie: "MuÃŸe",
                kategorieColor: "#118AB2",
                definition: "Das BedÃ¼rfnis nach Lachen und Leichtigkeit â€“ das Leben nicht immer ernst zu nehmen."
            },

            // IDENTITÃ„T
            authentizitaet: {
                "#ID": "#B50",
                label: "AuthentizitÃ¤t",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, echt und wahrhaftig zu sein â€“ sich selbst treu zu bleiben und nicht zu verstellen."
            },
            echtheit: {
                "#ID": "#B51",
                label: "Echtheit",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis nach Aufrichtigkeit und Wahrhaftigkeit â€“ in echten, unverfÃ¤lschten Begegnungen."
            },
            integritaet: {
                "#ID": "#B52",
                label: "IntegritÃ¤t",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, im Einklang mit den eigenen Werten zu handeln â€“ innere Stimmigkeit und Konsequenz."
            },
            praesenz: {
                "#ID": "#B53",
                label: "PrÃ¤senz",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, vollstÃ¤ndig im Moment zu sein â€“ ganz da, wach und aufmerksam."
            },
            ordnung: {
                "#ID": "#B54",
                label: "Ordnung",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis nach Struktur und Klarheit â€“ ein geordnetes Umfeld, das Orientierung gibt."
            },
            bewusstheit: {
                "#ID": "#B55",
                label: "Bewusstheit",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis nach Selbsterkenntnis und Achtsamkeit â€“ sich seiner selbst und der Welt bewusst zu sein."
            },
            herausforderung: {
                "#ID": "#B56",
                label: "Herausforderung",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, gefordert zu werden â€“ an Aufgaben zu wachsen und sich zu beweisen."
            },
            klarheit: {
                "#ID": "#B57",
                label: "Klarheit",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis nach Durchblick und VerstÃ¤ndnis â€“ zu wissen, woran man ist."
            },
            kompetenz: {
                "#ID": "#B58",
                label: "Kompetenz",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis nach FÃ¤higkeit und KÃ¶nnen â€“ etwas gut zu beherrschen und wirksam zu sein."
            },
            effizienz: {
                "#ID": "#B59",
                label: "Effizienz",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, Dinge effektiv und ohne Verschwendung zu tun â€“ optimales Handeln."
            },
            wirksamkeit: {
                "#ID": "#B60",
                label: "Wirksamkeit",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, etwas zu bewirken â€“ Einfluss zu haben und VerÃ¤nderung hervorzurufen."
            },
            wachstum: {
                "#ID": "#B61",
                label: "Wachstum",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis nach persÃ¶nlicher Entwicklung â€“ zu lernen, zu reifen und das eigene Potenzial zu entfalten."
            },
            sinn: {
                "#ID": "#B62",
                label: "Sinn",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das tiefe BedÃ¼rfnis nach Bedeutung und Zweck â€“ dass das Leben und Handeln einen Sinn hat."
            },
            beitrag_leisten: {
                "#ID": "#B63",
                label: "Einen Beitrag leisten",
                kategorie: "IdentitÃ¤t & Bedeutung",
                kategorieColor: "#FFD166",
                definition: "Das BedÃ¼rfnis, etwas beizutragen â€“ zum Wohlergehen anderer oder zum groÃŸen Ganzen."
            },

            // ERSCHAFFEN
            kreativitaet: {
                "#ID": "#B64",
                label: "KreativitÃ¤t",
                kategorie: "Etwas erschaffen",
                kategorieColor: "#FF6B6B",
                definition: "Das BedÃ¼rfnis, schÃ¶pferisch tÃ¤tig zu sein â€“ Neues zu erschaffen und kreativ Ausdruck zu finden."
            },
            entdecken: {
                "#ID": "#B65",
                label: "Entdecken",
                kategorie: "Etwas erschaffen",
                kategorieColor: "#FF6B6B",
                definition: "Das BedÃ¼rfnis nach Neugier und Exploration â€“ neue Dinge, Orte und Ideen zu entdecken."
            },
            lernen: {
                "#ID": "#B66",
                label: "Lernen",
                kategorie: "Etwas erschaffen",
                kategorieColor: "#FF6B6B",
                definition: "Das BedÃ¼rfnis nach Wissen und VerstÃ¤ndnis â€“ sich weiterzubilden und Neues zu verstehen."
            },
            selbst_ausdruck: {
                "#ID": "#B67",
                label: "Selbst-Ausdruck",
                kategorie: "Etwas erschaffen",
                kategorieColor: "#FF6B6B",
                definition: "Das BedÃ¼rfnis, sich auszudrÃ¼cken â€“ die eigene PersÃ¶nlichkeit, GefÃ¼hle und Ideen sichtbar zu machen."
            },
            anreize_bekommen: {
                "#ID": "#B68",
                label: "Anreize bekommen",
                kategorie: "Etwas erschaffen",
                kategorieColor: "#FF6B6B",
                definition: "Das BedÃ¼rfnis nach Stimulation und Inspiration â€“ neue Impulse, die motivieren und anregen."
            },

            // VERBUNDENHEIT
            leben_feiern: {
                "#ID": "#B69",
                label: "Das Leben feiern",
                kategorie: "Verbunden sein",
                kategorieColor: "#A8DADC",
                definition: "Das BedÃ¼rfnis, die SchÃ¶nheit und FÃ¼lle des Lebens zu wÃ¼rdigen â€“ Dankbarkeit und Freude am Sein."
            },
            inspiration: {
                "#ID": "#B70",
                label: "Inspiration",
                kategorie: "Verbunden sein",
                kategorieColor: "#A8DADC",
                definition: "Das BedÃ¼rfnis, inspiriert zu werden â€“ berÃ¼hrt, bewegt und zu HÃ¶herem angeregt."
            },
            trauer_ausdruecken: {
                "#ID": "#B71",
                label: "Trauer ausdrÃ¼cken",
                kategorie: "Verbunden sein",
                kategorieColor: "#A8DADC",
                definition: "Das BedÃ¼rfnis, Verlust und Schmerz ausdrÃ¼cken zu dÃ¼rfen â€“ Trauer als Teil des Lebens zu ehren."
            },
            einsehen: {
                "#ID": "#B72",
                label: "Einsehen",
                kategorie: "Verbunden sein",
                kategorieColor: "#A8DADC",
                definition: "Das BedÃ¼rfnis nach tieferer Erkenntnis â€“ ZusammenhÃ¤nge zu verstehen und Einsicht zu gewinnen."
            },
            anfang_ende: {
                "#ID": "#B73",
                label: "Anfang & Ende",
                kategorie: "Verbunden sein",
                kategorieColor: "#A8DADC",
                definition: "Das BedÃ¼rfnis, ÃœbergÃ¤nge zu wÃ¼rdigen â€“ AnfÃ¤nge zu feiern und Enden zu betrauern als Teil des Lebenskreislaufs."
            },

            // DYNAMIK & AUSTAUSCH
            kontrolle_ausueben: {
                "#ID": "#B74",
                label: "Kontrolle ausÃ¼ben",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, in einer Beziehung Verantwortung und FÃ¼hrung zu Ã¼bernehmen â€“ Entscheidungen zu treffen und Struktur zu geben."
            },
            hingabe: {
                "#ID": "#B75",
                label: "Hingabe",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, sich vertrauensvoll hinzugeben â€“ Kontrolle abzugeben und sich ganz auf den Partner einzulassen."
            },
            fuehrung_geben: {
                "#ID": "#B76",
                label: "FÃ¼hrung geben",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, Richtung und Orientierung zu geben â€“ den Partner zu leiten und zu fÃ¼hren."
            },
            gefuehrt_werden: {
                "#ID": "#B77",
                label: "GefÃ¼hrt werden",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, sich fÃ¼hren zu lassen â€“ Vertrauen in die FÃ¼hrung des Partners zu haben und Entlastung zu erfahren."
            },
            ritual: {
                "#ID": "#B78",
                label: "Rituale & Struktur",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach wiederkehrenden Praktiken und Strukturen â€“ Rituale, die Verbindung und Bedeutung schaffen."
            },
            nachsorge: {
                "#ID": "#B79",
                label: "Nachsorge/Aftercare",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach FÃ¼rsorge und Geborgenheit nach intensiven Erlebnissen â€“ sanftes ZurÃ¼ckkommen und Aufgefangen-Werden."
            },
            grenzen_setzen: {
                "#ID": "#B80",
                label: "Grenzen setzen",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, eigene Grenzen zu kennen und zu kommunizieren â€“ Selbstschutz und klare Kommunikation."
            },
            grenzen_respektieren: {
                "#ID": "#B81",
                label: "Grenzen respektieren",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, dass die eigenen Grenzen geachtet werden â€“ und selbst die Grenzen anderer zu respektieren."
            },
            intensitaet: {
                "#ID": "#B82",
                label: "IntensitÃ¤t erleben",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach starken, tiefgehenden Erfahrungen â€“ Momente hoher emotionaler oder kÃ¶rperlicher IntensitÃ¤t."
            },
            vertrauen_schenken: {
                "#ID": "#B83",
                label: "Vertrauen schenken",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, Vertrauen aktiv zu geben â€“ sich verletzlich zu zeigen und dem Partner zu vertrauen."
            },
            verantwortung_uebernehmen: {
                "#ID": "#B84",
                label: "Verantwortung Ã¼bernehmen",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, Verantwortung fÃ¼r sich, den Partner oder die Dynamik zu tragen â€“ verlÃ¤sslich und achtsam zu sein."
            },
            sich_fallenlassen: {
                "#ID": "#B85",
                label: "Sich fallenlassen",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, loszulassen und sich ganz einzulassen â€“ in Vertrauen die Kontrolle abzugeben."
            },
            machtaustausch: {
                "#ID": "#B86",
                label: "Machtaustausch",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach bewusstem Geben und Nehmen von Macht â€“ eine einvernehmliche Dynamik, die beide erfÃ¼llt."
            },
            dienend_sein: {
                "#ID": "#B87",
                label: "Dienend sein",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, dem Partner zu dienen â€“ Freude und ErfÃ¼llung darin zu finden, fÃ¼r den anderen da zu sein."
            },
            beschuetzen: {
                "#ID": "#B88",
                label: "BeschÃ¼tzen",
                kategorie: "Dynamik & Austausch",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, den Partner zu beschÃ¼tzen â€“ Sicherheit zu geben und Ã¼ber sein Wohlergehen zu wachen."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // LEBENSPLANUNG - Kinder, Ehe, Wohnen, Familie
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            kinderwunsch: {
                "#ID": "#B90",
                label: "Kinderwunsch",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, eigene Kinder zu haben und sie aufwachsen zu sehen â€“ ein tiefer Wunsch nach Weitergabe und FÃ¼rsorge.",
                quelle: "Evolutionspsychologie & Entwicklungspsychologie",
                quelleDetail: "Basiert auf dem biologischen Fortpflanzungstrieb (Darwin) und Eriksons Konzept der GenerativitÃ¤t â€“ dem BedÃ¼rfnis, etwas fÃ¼r die nÃ¤chste Generation zu hinterlassen."
            },
            elternschaft: {
                "#ID": "#B91",
                label: "Elternschaft",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, als Elternteil zu wirken â€“ Kinder zu erziehen, zu begleiten und in ihrer Entwicklung zu unterstÃ¼tzen.",
                quelle: "Erik Erikson â€“ Stufenmodell der psychosozialen Entwicklung",
                quelleDetail: "Im 7. Stadium (GenerativitÃ¤t vs. Stagnation) beschreibt Erikson das BedÃ¼rfnis, fÃ¼r die nÃ¤chste Generation zu sorgen als zentralen Entwicklungsaspekt des Erwachsenenalters."
            },
            fortpflanzung: {
                "#ID": "#B92",
                label: "Fortpflanzung",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das biologische BedÃ¼rfnis nach genetischer Weitergabe â€“ der Wunsch, eigene Gene und damit einen Teil von sich selbst weiterzugeben.",
                quelle: "Evolutionsbiologie & Soziobiologie",
                quelleDetail: "Richard Dawkins ('Das egoistische Gen', 1976) erklÃ¤rt, wie der Fortpflanzungsdrang evolutionÃ¤r verankert ist. Dieses BedÃ¼rfnis variiert individuell stark."
            },
            familie_gruenden: {
                "#ID": "#B93",
                label: "Familie grÃ¼nden",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, eine eigene Familieneinheit zu schaffen â€“ einen stabilen Rahmen fÃ¼r gemeinsames Leben und gegenseitige FÃ¼rsorge.",
                quelle: "Familiensoziologie & Bindungstheorie",
                quelleDetail: "Bowlby's Bindungstheorie zeigt, wie sichere Bindungen in Familien die Grundlage fÃ¼r psychische Gesundheit bilden."
            },
            generativitaet: {
                "#ID": "#B94",
                label: "GenerativitÃ¤t",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, etwas Bleibendes zu schaffen und weiterzugeben â€“ sei es durch Kinder, Mentoring oder kreative Werke.",
                quelle: "Erik Erikson â€“ Psychosoziale Entwicklung",
                quelleDetail: "Eriksons 7. Stufe beschreibt GenerativitÃ¤t als das BedÃ¼rfnis, Ã¼ber das eigene Selbst hinauszuwachsen und zur nÃ¤chsten Generation beizutragen."
            },
            verbindlichkeit: {
                "#ID": "#B95",
                label: "Verbindlichkeit",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach verlÃ¤sslichen Zusagen und bestÃ¤ndigen Verpflichtungen in der Beziehung.",
                quelle: "Bindungstheorie & Beziehungsforschung",
                quelleDetail: "John Gottman zeigt in seiner Forschung, dass Commitment (Verbindlichkeit) einer der stÃ¤rksten PrÃ¤diktoren fÃ¼r BeziehungsstabilitÃ¤t ist."
            },
            langfristige_bindung: {
                "#ID": "#B96",
                label: "Langfristige Bindung",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einer dauerhaften, stabilen Partnerschaft â€“ Sicherheit durch BestÃ¤ndigkeit.",
                quelle: "Bindungstheorie (Bowlby/Ainsworth)",
                quelleDetail: "Sicher gebundene Menschen zeigen ein starkes BedÃ¼rfnis nach langfristigen Bindungen, die emotionale Sicherheit bieten."
            },
            rechtliche_sicherheit: {
                "#ID": "#B97",
                label: "Rechtliche Sicherheit",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach rechtlicher Absicherung der Beziehung â€“ Schutz durch Institutionen wie Ehe oder eingetragene Partnerschaft.",
                quelle: "Familienrecht & Soziologie",
                quelleDetail: "Die Ehe bietet rechtliche Vorteile wie Erbrecht, Steuervorteile und Entscheidungsbefugnisse im Krankheitsfall."
            },
            treueversprechen: {
                "#ID": "#B98",
                label: "Treueversprechen",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach exklusiver emotionaler und/oder sexueller Bindung â€“ Vertrauen durch gegenseitige Treuezusage.",
                quelle: "Evolutionspsychologie & Kulturanthropologie",
                quelleDetail: "David Buss zeigt, wie sich Eifersucht und Treuewunsch evolutionÃ¤r entwickelt haben, wÃ¤hrend kulturelle Faktoren deren AusprÃ¤gung beeinflussen."
            },
            gemeinsamer_wohnraum: {
                "#ID": "#B99",
                label: "Gemeinsamer Wohnraum",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, den Lebensraum mit dem Partner zu teilen â€“ ein gemeinsames Zuhause als Symbol der Verbundenheit.",
                quelle: "Umweltpsychologie & Beziehungsforschung",
                quelleDetail: "Geteilter Wohnraum fÃ¶rdert IntimitÃ¤t und Alltagsroutinen, die die Beziehungszufriedenheit stÃ¤rken."
            },
            haeuslichkeit: {
                "#ID": "#B100",
                label: "HÃ¤uslichkeit",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einem gemÃ¼tlichen Zuhause â€“ Geborgenheit und Wohlbefinden in den eigenen vier WÃ¤nden.",
                quelle: "Umweltpsychologie",
                quelleDetail: "Das Konzept 'Home' (Zuhause) ist psychologisch mit Sicherheit, IdentitÃ¤t und emotionaler Regulierung verbunden."
            },
            nest_bauen: {
                "#ID": "#B101",
                label: "Nest bauen",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, gemeinsam ein Heim zu gestalten â€“ einen Ort der Sicherheit und des RÃ¼ckzugs zu schaffen.",
                quelle: "Evolutionspsychologie & Nesting-Instinkt",
                quelleDetail: "Der 'Nesting-Instinkt' ist besonders bei werdenden Eltern stark ausgeprÃ¤gt, aber auch generell ein Zeichen fÃ¼r Bindungssicherheit."
            },
            alltag_teilen: {
                "#ID": "#B102",
                label: "Alltag teilen",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, den tÃ¤glichen Rhythmus gemeinsam zu erleben â€“ kleine Momente des Zusammenseins im Alltag.",
                quelle: "Beziehungsforschung (Gottman)",
                quelleDetail: "Gottman betont die Bedeutung von 'Bids for Connection' â€“ kleinen Alltagsmomenten, die Beziehungen stÃ¤rken."
            },
            eigener_raum: {
                "#ID": "#B103",
                label: "Eigener Raum",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einem persÃ¶nlichen Bereich â€“ RÃ¼ckzugsort fÃ¼r IndividualitÃ¤t auch in der Partnerschaft.",
                quelle: "Selbstbestimmungstheorie (Deci & Ryan)",
                quelleDetail: "Autonomie ist ein GrundbedÃ¼rfnis. Auch in engen Beziehungen braucht jeder Mensch Raum fÃ¼r sich selbst."
            },
            rueckzugsort: {
                "#ID": "#B104",
                label: "RÃ¼ckzugsort",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einem Ort der Stille und Erholung â€“ Raum zum Auftanken und Reflektieren.",
                quelle: "Stressforschung & Resilienz",
                quelleDetail: "RÃ¼ckzugsmÃ¶glichkeiten sind essentiell fÃ¼r Stressregulation und emotionale Regeneration."
            },
            tierliebe: {
                "#ID": "#B105",
                label: "Tierliebe",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach Verbindung mit Tieren â€“ FÃ¼rsorge, Zuneigung und Freude im Umgang mit tierischen Begleitern.",
                quelle: "Anthrozoologie & TiergestÃ¼tzte Therapie",
                quelleDetail: "Die Mensch-Tier-Beziehung kann Oxytocin freisetzen und hat nachweislich positive Effekte auf die psychische Gesundheit."
            },
            fuersorge_tiere: {
                "#ID": "#B106",
                label: "FÃ¼rsorge fÃ¼r Tiere",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, fÃ¼r ein Tier zu sorgen â€“ Verantwortung, Pflege und die Freude am Wohlergehen eines Tieres.",
                quelle: "Caring-Motivation & Bindung",
                quelleDetail: "Die FÃ¼rsorge fÃ¼r Tiere aktiviert Ã¤hnliche neurologische Mechanismen wie die FÃ¼rsorge fÃ¼r Kinder."
            },
            begleiter: {
                "#ID": "#B107",
                label: "Tierischer Begleiter",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einem treuen tierischen GefÃ¤hrten â€“ bedingungslose PrÃ¤senz und Gesellschaft.",
                quelle: "Soziale UnterstÃ¼tzungsforschung",
                quelleDetail: "Haustiere bieten soziale UnterstÃ¼tzung und kÃ¶nnen Einsamkeit reduzieren."
            },
            verantwortung_tier: {
                "#ID": "#B108",
                label: "Verantwortung fÃ¼r Tier",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, Verantwortung fÃ¼r ein Lebewesen zu tragen â€“ Struktur und Sinn durch tÃ¤gliche FÃ¼rsorge.",
                quelle: "Entwicklungspsychologie",
                quelleDetail: "Verantwortung fÃ¼r andere (auch Tiere) fÃ¶rdert Selbstwirksamkeit und emotionale Reife."
            },
            sesshaftigkeit: {
                "#ID": "#B109",
                label: "Sesshaftigkeit",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einem festen Wohnort â€“ StabilitÃ¤t und Verwurzelung an einem Ort.",
                quelle: "Place Attachment Theorie",
                quelleDetail: "Ortsbindung (Place Attachment) ist mit IdentitÃ¤t, Sicherheit und Wohlbefinden verbunden."
            },
            verwurzelung: {
                "#ID": "#B110",
                label: "Verwurzelung",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach tiefer Verbindung mit einem Ort oder einer Gemeinschaft â€“ HeimatgefÃ¼hl und ZugehÃ¶rigkeit.",
                quelle: "Simone Weil â€“ 'Die Einwurzelung'",
                quelleDetail: "Weil beschreibt Verwurzelung als eines der wichtigsten, aber am wenigsten anerkannten BedÃ¼rfnisse der Seele."
            },
            mobilitaet: {
                "#ID": "#B111",
                label: "MobilitÃ¤t",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach Bewegungsfreiheit â€“ flexibel den Wohnort wechseln zu kÃ¶nnen.",
                quelle: "FreiheitsbedÃ¼rfnis & Moderne Soziologie",
                quelleDetail: "In einer globalisierten Welt ist MobilitÃ¤t fÃ¼r viele Menschen ein wichtiger Aspekt von Freiheit und Selbstverwirklichung."
            },
            heimat: {
                "#ID": "#B112",
                label: "Heimat",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach einem Ort der ZugehÃ¶rigkeit â€“ emotionale Verbundenheit mit einem geografischen oder sozialen Raum.",
                quelle: "Kulturpsychologie & IdentitÃ¤tsforschung",
                quelleDetail: "Heimat ist ein komplexes psychologisches Konstrukt, das Sicherheit, IdentitÃ¤t und soziale Einbettung umfasst."
            },
            neue_orte: {
                "#ID": "#B113",
                label: "Neue Orte",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, neue Orte zu entdecken und zu erleben â€“ Neugier und Offenheit fÃ¼r VerÃ¤nderung.",
                quelle: "Explorationsverhalten & Neugierforschung",
                quelleDetail: "Das BedÃ¼rfnis nach Neuheit (Novelty Seeking) ist ein PersÃ¶nlichkeitsmerkmal mit neurobiologischer Grundlage."
            },
            familienbindung: {
                "#ID": "#B114",
                label: "Familienbindung",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach enger Verbindung zur eigenen Familie â€“ emotionale NÃ¤he und regelmÃ¤ÃŸiger Kontakt.",
                quelle: "Bindungstheorie & Familienpsychologie",
                quelleDetail: "Sichere Bindungen zur Herkunftsfamilie kÃ¶nnen Ressource und Herausforderung zugleich sein."
            },
            herkunftsfamilie: {
                "#ID": "#B115",
                label: "Herkunftsfamilie",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, mit der Familie, in der man aufgewachsen ist, verbunden zu bleiben â€“ Wurzeln und Geschichte.",
                quelle: "Systemische Familientherapie",
                quelleDetail: "Die Herkunftsfamilie prÃ¤gt Beziehungsmuster, die in der Paarbeziehung reflektiert werden sollten."
            },
            familientreffen: {
                "#ID": "#B116",
                label: "Familientreffen",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach regelmÃ¤ÃŸigen ZusammenkÃ¼nften mit der erweiterten Familie â€“ Rituale der Verbundenheit.",
                quelle: "Ritual- und Familienforschung",
                quelleDetail: "Familienrituale stÃ¤rken den Zusammenhalt und geben Orientierung Ã¼ber Generationen hinweg."
            },
            generationenverbund: {
                "#ID": "#B117",
                label: "Generationenverbund",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach Verbindung Ã¼ber Generationen hinweg â€“ von GroÃŸeltern zu Enkeln, Weitergabe von Wissen und Werten.",
                quelle: "Generationenforschung & Narrative Psychologie",
                quelleDetail: "Die Weitergabe von Familiengeschichten stÃ¤rkt die IdentitÃ¤t und das GefÃ¼hl von KontinuitÃ¤t."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FINANZEN & KARRIERE
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            finanzielle_unabhaengigkeit: {
                "#ID": "#B127",
                label: "Finanzielle UnabhÃ¤ngigkeit",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, finanziell auf eigenen Beinen zu stehen â€“ nicht von anderen abhÃ¤ngig zu sein fÃ¼r den eigenen Lebensunterhalt.",
                quelle: "Selbstbestimmungstheorie (Deci & Ryan)",
                quelleDetail: "Finanzielle Autonomie ist eng mit dem psychologischen GrundbedÃ¼rfnis nach Autonomie verknÃ¼pft."
            },
            gemeinsame_finanzen: {
                "#ID": "#B128",
                label: "Gemeinsame Finanzen",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, Finanzen mit dem Partner zu teilen â€“ gemeinsame Konten, geteilte Ausgaben, finanzielle Einheit.",
                quelle: "Beziehungsforschung",
                quelleDetail: "Gemeinsame Finanzen kÃ¶nnen Vertrauen und Verbundenheit stÃ¤rken, erfordern aber klare Kommunikation."
            },
            finanzielle_transparenz: {
                "#ID": "#B129",
                label: "Finanzielle Transparenz",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach Offenheit Ã¼ber finanzielle Angelegenheiten â€“ keine Geheimnisse bei Geld, Schulden oder Ausgaben.",
                quelle: "Vertrauensforschung",
                quelleDetail: "Finanzielle Geheimnisse sind einer der hÃ¤ufigsten Konfliktpunkte in Beziehungen."
            },
            finanzielle_sicherheit: {
                "#ID": "#B130",
                label: "Finanzielle Sicherheit",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach materieller Absicherung â€“ genug Ressourcen fÃ¼r GrundbedÃ¼rfnisse und NotfÃ¤lle.",
                quelle: "Maslows BedÃ¼rfnispyramide",
                quelleDetail: "Finanzielle Sicherheit gehÃ¶rt zu den grundlegenden SicherheitsbedÃ¼rfnissen."
            },
            sparsamkeit: {
                "#ID": "#B131",
                label: "Sparsamkeit",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, mit Geld bewusst und sparsam umzugehen â€“ Ressourcen zu schonen und fÃ¼r die Zukunft vorzusorgen."
            },
            grosszuegigkeit: {
                "#ID": "#B132",
                label: "GroÃŸzÃ¼gigkeit",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, groÃŸzÃ¼gig zu geben â€“ Freude am Schenken und Teilen von Ressourcen mit anderen.",
                quelle: "Positive Psychologie",
                quelleDetail: "GroÃŸzÃ¼gigkeit ist mit hÃ¶herem Wohlbefinden und stÃ¤rkeren sozialen Bindungen verbunden."
            },
            berufliche_erfuellung: {
                "#ID": "#B133",
                label: "Berufliche ErfÃ¼llung",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, im Beruf Sinn und Zufriedenheit zu finden â€“ Arbeit als Quelle von ErfÃ¼llung, nicht nur Einkommen.",
                quelle: "Arbeitspsychologie",
                quelleDetail: "Berufliche ErfÃ¼llung korreliert stark mit allgemeiner Lebenszufriedenheit."
            },
            karriereambition: {
                "#ID": "#B134",
                label: "Karriereambition",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach beruflichem Aufstieg und Erfolg â€“ Ziele erreichen und sich professionell weiterzuentwickeln.",
                quelle: "Leistungsmotivation (McClelland)",
                quelleDetail: "Das BedÃ¼rfnis nach Leistung (Need for Achievement) treibt Karriereambitionen an."
            },
            work_life_balance: {
                "#ID": "#B135",
                label: "Work-Life-Balance",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach Ausgewogenheit zwischen Beruf und Privatleben â€“ Zeit und Energie fÃ¼r beide Bereiche.",
                quelle: "Arbeits- und Organisationspsychologie",
                quelleDetail: "Ungleichgewicht fÃ¼hrt zu Burnout und Beziehungsproblemen."
            },
            berufliche_anerkennung: {
                "#ID": "#B136",
                label: "Berufliche Anerkennung",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, fÃ¼r berufliche Leistungen gewÃ¼rdigt zu werden â€“ Respekt und WertschÃ¤tzung im Arbeitsumfeld.",
                quelle: "Herzbergs Zwei-Faktoren-Theorie",
                quelleDetail: "Anerkennung ist ein wichtiger Motivationsfaktor am Arbeitsplatz."
            },
            zeit_fuer_beziehung: {
                "#ID": "#B137",
                label: "Zeit fÃ¼r Beziehung",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, trotz beruflicher Anforderungen genÃ¼gend Zeit fÃ¼r die Partnerschaft zu haben.",
                quelle: "Beziehungsforschung (Gottman)",
                quelleDetail: "QualitÃ¤tszeit ist einer der wichtigsten Faktoren fÃ¼r Beziehungszufriedenheit."
            },
            berufliche_flexibilitaet: {
                "#ID": "#B138",
                label: "Berufliche FlexibilitÃ¤t",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach flexiblen Arbeitszeiten und -orten â€“ Freiheit in der Gestaltung des Arbeitsalltags.",
                quelle: "New Work & Arbeitspsychologie",
                quelleDetail: "FlexibilitÃ¤t am Arbeitsplatz erhÃ¶ht Zufriedenheit und ermÃ¶glicht bessere Vereinbarkeit."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // KOMMUNIKATIONSSTIL
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            taeglicher_austausch: {
                "#ID": "#B149",
                label: "TÃ¤glicher Austausch",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach regelmÃ¤ÃŸiger, alltÃ¤glicher Kommunikation â€“ sich Ã¼ber den Tag auszutauschen und in Verbindung zu bleiben.",
                quelle: "Beziehungsforschung",
                quelleDetail: "RegelmÃ¤ÃŸiger Austausch stÃ¤rkt die emotionale Verbindung und verhindert Entfremdung."
            },
            tiefgehende_gespraeche: {
                "#ID": "#B150",
                label: "Tiefgehende GesprÃ¤che",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach bedeutsamen, tiefgrÃ¼ndigen GesprÃ¤chen â€“ Ã¼ber GefÃ¼hle, Werte, TrÃ¤ume und existenzielle Themen.",
                quelle: "IntimitÃ¤t & Selbstoffenbarung",
                quelleDetail: "Tiefe GesprÃ¤che fÃ¶rdern emotionale IntimitÃ¤t und gegenseitiges VerstÃ¤ndnis."
            },
            small_talk: {
                "#ID": "#B151",
                label: "Small Talk",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach leichter, unverbindlicher Konversation â€“ entspannter Austausch ohne tiefe Themen."
            },
            stille_gemeinsam: {
                "#ID": "#B152",
                label: "Stille gemeinsam",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, auch in Stille zusammen sein zu kÃ¶nnen â€“ Verbundenheit ohne Worte, komfortables Schweigen.",
                quelle: "Bindungsforschung",
                quelleDetail: "Sichere Bindung ermÃ¶glicht es, auch in Stille verbunden zu sein, ohne Unbehagen."
            },
            verbale_verbindung: {
                "#ID": "#B153",
                label: "Verbale Verbindung",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, sich durch Worte zu verbinden â€“ Sprache als primÃ¤res Mittel der NÃ¤he und des Ausdrucks."
            },
            zuhoeren: {
                "#ID": "#B154",
                label: "ZuhÃ¶ren",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, wirklich gehÃ¶rt zu werden â€“ aktives, aufmerksames ZuhÃ¶ren ohne Unterbrechung oder vorschnelle RatschlÃ¤ge.",
                quelle: "Gewaltfreie Kommunikation (Rosenberg)",
                quelleDetail: "Empathisches ZuhÃ¶ren ist die Grundlage fÃ¼r echtes Verstehen und Verbindung."
            },
            emotionale_offenheit: {
                "#ID": "#B155",
                label: "Emotionale Offenheit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, GefÃ¼hle offen zu teilen und zu empfangen â€“ emotionale Transparenz in der Beziehung.",
                quelle: "Emotionsfokussierte Therapie (Johnson)",
                quelleDetail: "Emotionale Offenheit ist zentral fÃ¼r sichere Bindung und IntimitÃ¤t."
            },
            gefuehle_zeigen: {
                "#ID": "#B156",
                label: "GefÃ¼hle zeigen",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, eigene Emotionen ausdrÃ¼cken zu kÃ¶nnen â€“ TrÃ¤nen, Freude, Wut authentisch zu zeigen."
            },
            verletzlichkeit: {
                "#ID": "#B157",
                label: "Verletzlichkeit zulassen",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, sich verletzlich zeigen zu dÃ¼rfen â€“ SchwÃ¤chen und Unsicherheiten teilen zu kÃ¶nnen.",
                quelle: "BrenÃ© Brown â€“ Verletzlichkeitsforschung",
                quelleDetail: "Verletzlichkeit ist der Geburtsort von Liebe, ZugehÃ¶rigkeit und Freude."
            },
            emotionale_zurueckhaltung: {
                "#ID": "#B158",
                label: "Emotionale ZurÃ¼ckhaltung",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach Raum fÃ¼r emotionale PrivatsphÃ¤re â€“ nicht alles teilen zu mÃ¼ssen, GefÃ¼hle zu verarbeiten bevor man sie teilt."
            },
            emotionale_sicherheit: {
                "#ID": "#B159",
                label: "Emotionale Sicherheit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, sich emotional sicher zu fÃ¼hlen â€“ zu wissen, dass GefÃ¼hle nicht abgewertet oder gegen einen verwendet werden.",
                quelle: "Bindungstheorie",
                quelleDetail: "Emotionale Sicherheit ist die Grundlage fÃ¼r sichere Bindung und offene Kommunikation."
            },
            gefuehle_teilen: {
                "#ID": "#B160",
                label: "GefÃ¼hle teilen",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, emotionale Erlebnisse mit dem Partner zu teilen â€“ gemeinsam zu fÃ¼hlen und mitzuerleben."
            },
            konfliktklaerung: {
                "#ID": "#B161",
                label: "KonfliktklÃ¤rung",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, Konflikte offen anzusprechen und zu lÃ¶sen â€“ nicht unter den Teppich kehren, sondern klÃ¤ren.",
                quelle: "Gottman-Forschung",
                quelleDetail: "Die Art, wie Paare mit Konflikten umgehen, ist entscheidend fÃ¼r die BeziehungsqualitÃ¤t."
            },
            aussprache: {
                "#ID": "#B162",
                label: "Aussprache",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, Dinge auszusprechen â€“ MissverstÃ¤ndnisse zu klÃ¤ren und einen Abschluss zu finden."
            },
            konflikt_vermeiden: {
                "#ID": "#B163",
                label: "Konflikt vermeiden",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, Konfrontationen zu minimieren â€“ Harmonie zu bewahren und Streit aus dem Weg zu gehen."
            },
            streitkultur: {
                "#ID": "#B164",
                label: "Streitkultur",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach konstruktivem Streiten â€“ Konflikte fair und respektvoll auszutragen.",
                quelle: "Paartherapie-Forschung",
                quelleDetail: "Eine gesunde Streitkultur ermÃ¶glicht Wachstum und tieferes VerstÃ¤ndnis."
            },
            versoehnlichkeit: {
                "#ID": "#B165",
                label: "VersÃ¶hnlichkeit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach VersÃ¶hnung nach Konflikten â€“ wieder zueinander zu finden und Frieden zu schlieÃŸen.",
                quelle: "Vergebungsforschung",
                quelleDetail: "VersÃ¶hnlichkeit ist essentiell fÃ¼r langfristige Beziehungszufriedenheit."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SOZIALES LEBEN
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            soziale_energie: {
                "#ID": "#B177",
                label: "Soziale Energie",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach einem bestimmten Level sozialer Interaktion â€“ manche brauchen mehr, manche weniger.",
                quelle: "PersÃ¶nlichkeitspsychologie (Extraversion)",
                quelleDetail: "Das Kontinuum Introversion-Extraversion beschreibt unterschiedliche soziale EnergiebedÃ¼rfnisse."
            },
            geselligkeit: {
                "#ID": "#B178",
                label: "Geselligkeit",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach Gesellschaft und sozialem Beisammensein â€“ Freude an Gruppen und gemeinsamen AktivitÃ¤ten."
            },
            ruhe_von_menschen: {
                "#ID": "#B179",
                label: "Ruhe von Menschen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach Pausen von sozialen Interaktionen â€“ Zeit ohne Menschen, um sich zu erholen."
            },
            allein_aufladen: {
                "#ID": "#B180",
                label: "Allein aufladen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, durch Alleinsein Energie zu tanken â€“ Introversion als Kraftquelle.",
                quelle: "Introversionsforschung (Susan Cain)",
                quelleDetail: "Introvertierte Menschen regenerieren ihre Energie durch Alleinsein."
            },
            menschen_treffen: {
                "#ID": "#B181",
                label: "Menschen treffen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, regelmÃ¤ÃŸig andere Menschen zu sehen â€“ soziale Kontakte pflegen und neue Menschen kennenlernen."
            },
            kleine_gruppen: {
                "#ID": "#B182",
                label: "Kleine Gruppen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach IntimitÃ¤t kleiner Gruppen â€“ tiefere GesprÃ¤che statt oberflÃ¤chlicher GroÃŸgruppeninteraktion."
            },
            zeit_fuer_sich: {
                "#ID": "#B183",
                label: "Zeit fÃ¼r sich",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach persÃ¶nlicher Zeit ohne den Partner â€“ Raum fÃ¼r individuelle Interessen und SelbstfÃ¼rsorge.",
                quelle: "Selbstbestimmungstheorie",
                quelleDetail: "Autonomie, auch in Beziehungen, ist ein psychologisches GrundbedÃ¼rfnis."
            },
            eigene_hobbys: {
                "#ID": "#B184",
                label: "Eigene Hobbys",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, eigene Interessen und Hobbys zu pflegen â€“ IndividualitÃ¤t neben der Partnerschaft bewahren."
            },
            gemeinsame_zeit: {
                "#ID": "#B185",
                label: "Gemeinsame Zeit",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach QualitÃ¤tszeit zu zweit â€“ bewusste gemeinsame Momente und AktivitÃ¤ten.",
                quelle: "Liebessprachen (Gary Chapman)",
                quelleDetail: "QualitÃ¤tszeit ist eine der fÃ¼nf Liebessprachen."
            },
            partnerzeit: {
                "#ID": "#B186",
                label: "Partnerzeit",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach exklusiver Zeit mit dem Partner â€“ ungeteilte Aufmerksamkeit und PrÃ¤senz."
            },
            eigene_interessen: {
                "#ID": "#B187",
                label: "Eigene Interessen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, persÃ¶nliche Interessen zu verfolgen â€“ IdentitÃ¤t jenseits der Beziehung."
            },
            eigene_freunde: {
                "#ID": "#B188",
                label: "Eigene Freunde",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach eigenen Freundschaften auÃŸerhalb der Beziehung â€“ separate soziale Netzwerke."
            },
            gemeinsame_freunde: {
                "#ID": "#B189",
                label: "Gemeinsame Freunde",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach Freunden, die man als Paar teilt â€“ gemeinsame soziale Welt."
            },
            freundeskreis_teilen: {
                "#ID": "#B190",
                label: "Freundeskreis teilen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, den Partner in den eigenen Freundeskreis zu integrieren â€“ Welten zusammenfÃ¼hren."
            },
            soziales_netz: {
                "#ID": "#B191",
                label: "Soziales Netz",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach einem stabilen sozialen Netzwerk â€“ UnterstÃ¼tzung durch Freunde und Familie.",
                quelle: "Soziale UnterstÃ¼tzungsforschung",
                quelleDetail: "Ein starkes soziales Netz ist ein wichtiger Schutzfaktor fÃ¼r psychische Gesundheit."
            },
            freunde_pflegen: {
                "#ID": "#B192",
                label: "Freunde pflegen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, Freundschaften aktiv zu pflegen â€“ Zeit und Energie in Beziehungen auÃŸerhalb der Partnerschaft zu investieren."
            },
            neue_freundschaften: {
                "#ID": "#B193",
                label: "Neue Freundschaften",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, offen fÃ¼r neue Bekanntschaften zu sein â€“ Freundeskreis erweitern und neue Menschen kennenlernen."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // INTIMITÃ„T & ROMANTIK
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            koerpernaehe: {
                "#ID": "#B204",
                label: "KÃ¶rpernÃ¤he",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach physischer NÃ¤he zum Partner â€“ kÃ¶rperlich beieinander sein, spÃ¼rbare PrÃ¤senz.",
                quelle: "Bindungstheorie & KÃ¶rperpsychologie",
                quelleDetail: "KÃ¶rperliche NÃ¤he aktiviert das Bindungssystem und fÃ¶rdert Oxytocin-AusschÃ¼ttung."
            },
            kuscheln: {
                "#ID": "#B205",
                label: "Kuscheln",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach zÃ¤rtlichem kÃ¶rperlichem Kontakt â€“ Umarmungen, Anschmiegen, Geborgenheit durch BerÃ¼hrung."
            },
            physische_distanz: {
                "#ID": "#B206",
                label: "Physische Distanz",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach kÃ¶rperlichem Abstand â€“ Raum zwischen sich und anderen als Komfortzone."
            },
            koerperkontakt: {
                "#ID": "#B207",
                label: "KÃ¶rperkontakt",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach regelmÃ¤ÃŸigem kÃ¶rperlichem Kontakt â€“ BerÃ¼hrung als Sprache der Verbundenheit.",
                quelle: "Liebessprachen (Gary Chapman)",
                quelleDetail: "KÃ¶rperliche BerÃ¼hrung ist eine der fÃ¼nf Liebessprachen."
            },
            umarmungen: {
                "#ID": "#B208",
                label: "Umarmungen",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, umarmt zu werden und zu umarmen â€“ einfache, tiefe Gesten der Zuneigung."
            },
            hand_halten: {
                label: "Hand halten",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach HÃ¤ndchenhalten â€“ Ã¶ffentliche und private Geste der Verbundenheit."
            },
            romantische_gesten: {
                label: "Romantische Gesten",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach romantischen Ausdrucksformen â€“ Blumen, Briefe, Ã¼berraschende Gesten der Liebe."
            },
            ueberraschungen: {
                label: "Ãœberraschungen",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, Ã¼berrascht zu werden oder zu Ã¼berraschen â€“ Spannung und Freude durch Unerwartetes."
            },
            dates: {
                label: "Dates",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach bewussten Verabredungen â€“ Zeit zu zweit auÃŸerhalb des Alltags, auch in langen Beziehungen.",
                quelle: "Beziehungsforschung",
                quelleDetail: "RegelmÃ¤ÃŸige Dates erhalten die Romantik und verhindern Alltagstrott."
            },
            alltags_romantik: {
                label: "Alltags-Romantik",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach kleinen romantischen Momenten im Alltag â€“ liebevolle Gesten zwischendurch."
            },
            aufmerksamkeiten: {
                label: "Aufmerksamkeiten",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach kleinen Aufmerksamkeiten â€“ Geschenke, Komplimente, Zeichen der WertschÃ¤tzung."
            },
            liebesbekundungen: {
                label: "Liebesbekundungen",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, Liebe ausgedrÃ¼ckt zu bekommen â€“ 'Ich liebe dich' hÃ¶ren und sagen."
            },
            sexuelle_haeufigkeit: {
                label: "Sexuelle HÃ¤ufigkeit",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach einer bestimmten Frequenz sexueller IntimitÃ¤t â€“ unterschiedliche Libido-Level.",
                quelle: "Sexualforschung",
                quelleDetail: "Unterschiedliche sexuelle BedÃ¼rfnisse sind einer der hÃ¤ufigsten Beziehungskonflikte."
            },
            sexuelle_intimiaet: {
                label: "Sexuelle IntimitÃ¤t",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach sexueller Verbindung als Form tiefer IntimitÃ¤t â€“ Sex als Ausdruck von Liebe und NÃ¤he."
            },
            koerperliche_lust: {
                label: "KÃ¶rperliche Lust",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach kÃ¶rperlichem VergnÃ¼gen und Lust â€“ Genuss und Befriedigung durch SexualitÃ¤t."
            },
            sexuelle_experimentierfreude: {
                label: "Sexuelle Experimentierfreude",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, sexuell Neues auszuprobieren â€“ Neugier und Offenheit fÃ¼r Variation."
            },
            sexuelle_verbindung: {
                label: "Sexuelle Verbindung",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, durch SexualitÃ¤t eine tiefe Verbindung zu spÃ¼ren â€“ Sex als spirituelle und emotionale Erfahrung."
            },
            sexuelle_zufriedenheit: {
                label: "Sexuelle Zufriedenheit",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach erfÃ¼llender SexualitÃ¤t â€“ dass beide Partner zufrieden und erfÃ¼llt sind."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // WERTE & HALTUNGEN
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            spiritualitaet: {
                label: "SpiritualitÃ¤t",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach spiritueller Erfahrung und Praxis â€“ Verbindung zu etwas GrÃ¶ÃŸerem als sich selbst.",
                quelle: "Religionspsychologie",
                quelleDetail: "SpiritualitÃ¤t ist mit Sinnerleben und Wohlbefinden verbunden, unabhÃ¤ngig von Religion."
            },
            glaubenspraxis: {
                label: "Glaubenspraxis",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, den eigenen Glauben aktiv zu praktizieren â€“ Rituale, Gebete, religiÃ¶se Gemeinschaft."
            },
            religioese_gemeinschaft: {
                label: "ReligiÃ¶se Gemeinschaft",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, Teil einer religiÃ¶sen Gemeinde zu sein â€“ geteilter Glaube und spirituelle Gemeinschaft."
            },
            saekularitaet: {
                label: "SÃ¤kularitÃ¤t",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach einem weltlichen, nicht-religiÃ¶sen Lebensansatz â€“ Sinn ohne Religion finden."
            },
            sinnsuche: {
                label: "Sinnsuche",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, den Sinn des Lebens zu erforschen â€“ existenzielle Fragen zu stellen und Antworten zu suchen.",
                quelle: "Existenzpsychologie (Viktor Frankl)",
                quelleDetail: "Die Suche nach Sinn ist nach Frankl die primÃ¤re Motivation des Menschen."
            },
            transzendenz: {
                label: "Transzendenz",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, Ã¼ber das AlltÃ¤gliche hinauszugehen â€“ Erfahrungen, die Ã¼ber das Selbst hinausweisen.",
                quelle: "Maslow â€“ Selbsttranszendenz",
                quelleDetail: "Maslow fÃ¼gte spÃ¤ter Transzendenz als hÃ¶chste Stufe Ã¼ber Selbstverwirklichung hinzu."
            },
            traditionelle_werte: {
                label: "Traditionelle Werte",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach BewÃ¤hrtem â€“ Werte und Lebensweisen, die Ã¼ber Generationen weitergegeben wurden."
            },
            moderne_lebensweise: {
                label: "Moderne Lebensweise",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach zeitgemÃ¤ÃŸen, progressiven Lebensformen â€“ offen fÃ¼r neue Wege des Zusammenlebens."
            },
            konservative_werte: {
                label: "Konservative Werte",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach Bewahrung von Tradition â€“ StabilitÃ¤t durch bewÃ¤hrte Werte und Strukturen."
            },
            progressive_werte: {
                label: "Progressive Werte",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach gesellschaftlichem Fortschritt â€“ VerÃ¤nderung zum Besseren, soziale Gerechtigkeit."
            },
            kulturelle_tradition: {
                label: "Kulturelle Tradition",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, kulturelle Traditionen zu pflegen â€“ BrÃ¤uche, Feste und Rituale der eigenen Kultur."
            },
            offenheit_fuer_neues: {
                label: "Offenheit fÃ¼r Neues",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach Offenheit gegenÃ¼ber neuen Ideen und Erfahrungen â€“ Neugier und FlexibilitÃ¤t.",
                quelle: "Big Five â€“ Offenheit fÃ¼r Erfahrungen",
                quelleDetail: "Offenheit ist ein PersÃ¶nlichkeitsmerkmal mit Einfluss auf BeziehungskompatibilitÃ¤t."
            },
            umweltverantwortung: {
                label: "Umweltverantwortung",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, Verantwortung fÃ¼r die Umwelt zu Ã¼bernehmen â€“ nachhaltig leben und handeln."
            },
            nachhaltigkeit: {
                label: "Nachhaltigkeit",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, ressourcenschonend zu leben â€“ fÃ¼r kommende Generationen zu erhalten."
            },
            oekologisches_bewusstsein: {
                label: "Ã–kologisches Bewusstsein",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, Ã¶kologische ZusammenhÃ¤nge zu beachten â€“ die Natur als Teil des eigenen Wertsystems."
            },
            pragmatismus: {
                label: "Pragmatismus",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach praktischen, funktionierenden LÃ¶sungen â€“ Ideologie weniger wichtig als Ergebnis."
            },
            klimaschutz: {
                label: "Klimaschutz",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, aktiv zum Klimaschutz beizutragen â€“ Handeln gegen den Klimawandel."
            },
            ressourcenschonung: {
                label: "Ressourcenschonung",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, sparsam mit Ressourcen umzugehen â€“ weniger verbrauchen, wiederverwenden, recyceln."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PRAKTISCHES LEBEN
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            ordnungssinn: {
                label: "Ordnungssinn",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach Ordnung und AufgerÃ¤umtheit â€“ klare Strukturen im Wohnumfeld.",
                quelle: "PersÃ¶nlichkeitspsychologie (Gewissenhaftigkeit)",
                quelleDetail: "OrdnungsbedÃ¼rfnis ist Teil des PersÃ¶nlichkeitsmerkmals Gewissenhaftigkeit."
            },
            sauberkeit: {
                label: "Sauberkeit",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach Reinlichkeit â€“ ein sauberes Zuhause als WohlfÃ¼hlfaktor."
            },
            struktur: {
                label: "Struktur",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach klaren AblÃ¤ufen und Routinen â€“ Vorhersehbarkeit im Alltag."
            },
            chaos_toleranz: {
                label: "Chaos-Toleranz",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, mit Unordnung leben zu kÃ¶nnen â€“ FlexibilitÃ¤t gegenÃ¼ber Chaos."
            },
            organisiert_sein: {
                label: "Organisiert sein",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, Dinge geplant und organisiert zu haben â€“ Termine, Aufgaben, Alltag im Griff."
            },
            flexibilitaet_haushalt: {
                label: "FlexibilitÃ¤t im Haushalt",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach flexibler Aufteilung von Haushaltsaufgaben â€“ spontan und situationsabhÃ¤ngig."
            },
            reisen: {
                label: "Reisen",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis zu reisen und neue Orte zu entdecken â€“ Abenteuer und Horizonterweiterung.",
                quelle: "Neugierforschung",
                quelleDetail: "Reisen befriedigt das BedÃ¼rfnis nach Neuheit und Stimulation."
            },
            abenteuer: {
                label: "Abenteuer",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach aufregenden Erlebnissen â€“ Nervenkitzel und Unbekanntes."
            },
            neue_orte_entdecken: {
                label: "Neue Orte entdecken",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, unbekannte Orte zu erkunden â€“ Neugier auf fremde LÃ¤nder und Kulturen."
            },
            zuhause_bleiben: {
                label: "Zuhause bleiben",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, die eigenen vier WÃ¤nde als RÃ¼ckzugsort zu genieÃŸen â€“ HomebodymentalitÃ¤t."
            },
            urlaub: {
                label: "Urlaub",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach regelmÃ¤ÃŸigen Auszeiten vom Alltag â€“ Erholung durch Urlaub."
            },
            fernweh: {
                label: "Fernweh",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, in die Ferne zu schweifen â€“ Sehnsucht nach fernen LÃ¤ndern und Kulturen."
            },
            heimatverbundenheit: {
                label: "Heimatverbundenheit",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach Verbundenheit mit der Heimat â€“ Verwurzelung am Geburtsort oder Wohnort."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - Lebensplanung
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            biologisches_muster: {
                "#ID": "#B118",
                label: "Biologisches Muster",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach biologischer KontinuitÃ¤t â€“ Fortpflanzung und StammeszugehÃ¶rigkeit als natÃ¼rliches Muster.",
                quelle: "Robert M. Pirsig â€“ QualitÃ¤tsebenen",
                quelleDetail: "Das biologische QualitÃ¤tsmuster reprÃ¤sentiert evolutionÃ¤r entstandene BedÃ¼rfnisse."
            },
            soziales_muster: {
                "#ID": "#B119",
                label: "Soziales Muster",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach sozialen Strukturen â€“ Institutionen, Traditionen und gesellschaftliche Ordnung.",
                quelle: "Robert M. Pirsig â€“ Lila",
                quelleDetail: "Soziale Muster entstehen aus biologischen und ermÃ¶glichen Kultur und Zivilisation."
            },
            statische_stabilitaet: {
                "#ID": "#B120",
                label: "Statische StabilitÃ¤t",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach festen, verlÃ¤sslichen Mustern â€“ Vorhersehbarkeit und Struktur im Leben.",
                quelle: "Robert M. Pirsig â€“ Statische vs. Dynamische QualitÃ¤t",
                quelleDetail: "Statische QualitÃ¤t bewahrt, was funktioniert und gibt Sicherheit."
            },
            qualitaet_der_fuersorge: {
                "#ID": "#B121",
                label: "QualitÃ¤t der FÃ¼rsorge",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach sorgfÃ¤ltiger, achtsamer Planung und FÃ¼rsorge â€“ Verantwortung mit Hingabe.",
                quelle: "Robert M. Pirsig â€“ Care",
                quelleDetail: "Pirsig betont 'Care' (Sorgfalt) als wesentlich fÃ¼r QualitÃ¤t in allem Handeln."
            },
            familien_rebellion: {
                "#ID": "#B122",
                label: "Familien-Rebellion",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis, gegen traditionelle Familienstrukturen zu rebellieren â€“ eigene Wege der Verbindung finden.",
                quelle: "Osho â€“ Rebellion & Freiheit",
                quelleDetail: "Osho sah die traditionelle Familie oft als Quelle von Konditionierung und Unfreiheit."
            },
            zorba_das_kind: {
                "#ID": "#B123",
                label: "Zorba das Kind",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach weltlicher Freude am Familienleben â€“ Genuss und PrÃ¤senz im Hier und Jetzt.",
                quelle: "Osho â€“ Zorba der Buddha",
                quelleDetail: "Die kindliche QualitÃ¤t von Zorba verbindet Lebensfreude mit FamilienglÃ¼ck."
            },
            nicht_anhaften_an_familie: {
                "#ID": "#B124",
                label: "Nicht-Anhaften an Familie",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach Liebe ohne Besitzanspruch â€“ Familie haben, ohne daran zu klammern.",
                quelle: "Osho â€“ Nicht-Anhaftung",
                quelleDetail: "Oshos Konzept der Nicht-Anhaftung erlaubt Liebe ohne die Last des Besitzens."
            },
            bewusste_elternschaft: {
                "#ID": "#B125",
                label: "Bewusste Elternschaft",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach achtsamer, nicht-konditionierender Erziehung â€“ Kinder als eigenstÃ¤ndige Wesen ehren.",
                quelle: "Osho â€“ Bewusstes Elternsein",
                quelleDetail: "Kinder begleiten ohne zu formen, ihre natÃ¼rliche Entfaltung unterstÃ¼tzen."
            },
            commune_statt_kernfamilie: {
                "#ID": "#B126",
                label: "Kommune statt Kernfamilie",
                kategorie: "Lebensplanung",
                kategorieColor: "#10B981",
                definition: "Das BedÃ¼rfnis nach Gemeinschaftsleben statt isolierter Kleinfamilie â€“ erweiterte Wahlfamilie.",
                quelle: "Osho â€“ Kommune",
                quelleDetail: "Osho propagierte das Ashram-Leben als Alternative zur einengenden Kernfamilie."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - Finanzen & Karriere
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            gumption: {
                "#ID": "#B139",
                label: "Gumption",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach innerer Motivation und Enthusiasmus â€“ Flow und Begeisterung in der Arbeit.",
                quelle: "Robert M. Pirsig â€“ Gumption Traps",
                quelleDetail: "Gumption ist die psychische Benzin, die uns antreibt â€“ ohne sie bleiben wir stecken."
            },
            qualitaet_der_arbeit: {
                "#ID": "#B140",
                label: "QualitÃ¤t der Arbeit",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach handwerklicher Exzellenz â€“ Meisterschaft und Perfektion im eigenen Tun.",
                quelle: "Robert M. Pirsig â€“ Zen und die Kunst",
                quelleDetail: "Pirsigs zentrales Thema: QualitÃ¤t als das, was die Welt verbessert."
            },
            intellektuelles_muster: {
                "#ID": "#B141",
                label: "Intellektuelles Muster",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach konzeptueller Arbeit â€“ Verstehen, Systematisieren und geistige Durchdringung.",
                quelle: "Robert M. Pirsig â€“ QualitÃ¤tsebenen",
                quelleDetail: "Intellektuelle Muster stehen Ã¼ber sozialen und ermÃ¶glichen kritisches Denken."
            },
            dynamische_evolution: {
                "#ID": "#B142",
                label: "Dynamische Evolution",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach beruflicher Weiterentwicklung â€“ Wachstum, Innovation und VerÃ¤nderung.",
                quelle: "Robert M. Pirsig â€“ Dynamische QualitÃ¤t",
                quelleDetail: "Dynamische QualitÃ¤t treibt Evolution und KreativitÃ¤t an."
            },
            klassisches_verstehen: {
                "#ID": "#B143",
                label: "Klassisches Verstehen",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach analytischem, strukturiertem Arbeiten â€“ Logik, Systematik und rationales Vorgehen.",
                quelle: "Robert M. Pirsig â€“ Klassisch vs. Romantisch",
                quelleDetail: "Die klassische Sichtweise sieht die zugrundeliegende Form, nicht nur die OberflÃ¤che."
            },
            arbeit_als_meditation: {
                "#ID": "#B144",
                label: "Arbeit als Meditation",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, Arbeit als spirituelle Praxis zu erleben â€“ volle PrÃ¤senz und Achtsamkeit im Tun.",
                quelle: "Osho â€“ Meditatives Arbeiten",
                quelleDetail: "Jede Handlung kann Meditation werden, wenn sie mit totaler Bewusstheit geschieht."
            },
            nicht_karriere: {
                "#ID": "#B145",
                label: "Nicht-Karriere",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, Karriere-Ambitionen loszulassen â€“ nicht durch Status oder Position definiert zu sein.",
                quelle: "Osho â€“ Nicht-Ehrgeiz",
                quelleDetail: "Osho sah Karrierestreben als Ego-Spiel, das von wahrem GlÃ¼ck ablenkt."
            },
            zorba_der_unternehmer: {
                "#ID": "#B146",
                label: "Zorba der Unternehmer",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach weltlichem Erfolg verbunden mit SpiritualitÃ¤t â€“ reich an Erfahrung und Geld.",
                quelle: "Osho â€“ Zorba der Buddha",
                quelleDetail: "Zorba genieÃŸt das Materielle, Buddha transzendiert es â€“ beides zusammen ist mÃ¶glich."
            },
            nicht_anhaften_an_geld: {
                "#ID": "#B147",
                label: "Nicht-Anhaften an Geld",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis nach finanzieller Freiheit durch innere UnabhÃ¤ngigkeit â€“ Geld haben ohne davon besessen zu sein.",
                quelle: "Osho â€“ Nicht-Anhaftung",
                quelleDetail: "Geld kann flieÃŸen, ohne dass wir uns daran klammern oder es fÃ¼rchten."
            },
            kreative_selbstverwirklichung: {
                "#ID": "#B148",
                label: "Kreative Selbstverwirklichung",
                kategorie: "Finanzen & Karriere",
                kategorieColor: "#F59E0B",
                definition: "Das BedÃ¼rfnis, Arbeit als kreativen Ausdruck zu leben â€“ nicht fÃ¼r Geld, sondern aus innerem Antrieb.",
                quelle: "Osho â€“ KreativitÃ¤t",
                quelleDetail: "Wahre KreativitÃ¤t entsteht aus Freude, nicht aus dem BedÃ¼rfnis nach Anerkennung."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - Kommunikationsstil
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            romantisches_verstehen: {
                "#ID": "#B166",
                label: "Romantisches Verstehen",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach intuitivem, ganzheitlichem Kommunizieren â€“ GefÃ¼hl vor Analyse.",
                quelle: "Robert M. Pirsig â€“ Romantisch vs. Klassisch",
                quelleDetail: "Die romantische Sichtweise erfasst das Ganze, die unmittelbare Erscheinung."
            },
            klassische_klarheit: {
                "#ID": "#B167",
                label: "Klassische Klarheit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach prÃ¤ziser, analytischer Kommunikation â€“ klare Begriffe und logische Struktur.",
                quelle: "Robert M. Pirsig â€“ Klassisches Denken",
                quelleDetail: "Klassisches Denken zerlegt und analysiert, um zu verstehen."
            },
            dialektik: {
                "#ID": "#B168",
                label: "Dialektik",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach philosophischem Dialog â€“ Wahrheitsfindung durch These, Antithese, Synthese.",
                quelle: "Robert M. Pirsig â€“ Sokratisches GesprÃ¤ch",
                quelleDetail: "Pirsig nutzt die dialektische Methode, um QualitÃ¤t zu erkunden."
            },
            qualitaets_ausdruck: {
                "#ID": "#B169",
                label: "QualitÃ¤ts-Ausdruck",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach qualitativ hochwertigem Ausdruck â€“ Eloquenz, PrÃ¤zision und sprachliche SchÃ¶nheit.",
                quelle: "Robert M. Pirsig â€“ QualitÃ¤t",
                quelleDetail: "QualitÃ¤t zeigt sich auch in der Art, wie wir kommunizieren."
            },
            care_im_gespraech: {
                "#ID": "#B170",
                label: "Care im GesprÃ¤ch",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach sorgfÃ¤ltiger, achtsamer Kommunikation â€“ mit Hingabe und Aufmerksamkeit sprechen.",
                quelle: "Robert M. Pirsig â€“ Care",
                quelleDetail: "Sorgfalt im GesprÃ¤ch bedeutet, wirklich prÃ¤sent und aufmerksam zu sein."
            },
            schweigen_statt_worte: {
                "#ID": "#B171",
                label: "Schweigen statt Worte",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach Stille als Kommunikation â€“ das Ungesagte als tiefste VerstÃ¤ndigung.",
                quelle: "Osho â€“ Stille",
                quelleDetail: "Osho sprach viel Ã¼ber Stille als das eigentliche Medium der Wahrheit."
            },
            radikale_ehrlichkeit: {
                "#ID": "#B172",
                label: "Radikale Ehrlichkeit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach kompromissloser Wahrheit â€“ keine HÃ¶flichkeitslÃ¼gen, authentischer Ausdruck.",
                quelle: "Osho â€“ AuthentizitÃ¤t",
                quelleDetail: "Osho forderte radikale Ehrlichkeit, auch wenn sie unbequem ist."
            },
            humorvolle_leichtigkeit: {
                "#ID": "#B173",
                label: "Humorvolle Leichtigkeit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach Lachen und spielerischer Kommunikation â€“ Witz statt Schwere.",
                quelle: "Osho â€“ Humor & Lachen",
                quelleDetail: "Osho betonte Lachen als spirituelle Praxis und Zeichen von Freiheit."
            },
            paradoxe_weisheit: {
                "#ID": "#B174",
                label: "Paradoxe Weisheit",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach paradoxer Kommunikation â€“ Zen-Koans, WidersprÃ¼che als Weg zur Erkenntnis.",
                quelle: "Osho â€“ Zen",
                quelleDetail: "Paradoxe durchbrechen den analytischen Verstand und Ã¶ffnen fÃ¼r tiefere Einsicht."
            },
            herz_statt_kopf: {
                "#ID": "#B175",
                label: "Herz statt Kopf",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis nach emotionaler statt rationaler Kommunikation â€“ aus dem Herzen sprechen.",
                quelle: "Osho â€“ Herz",
                quelleDetail: "Osho sah den Kopf als Hindernis fÃ¼r wahre Kommunikation, das Herz als BrÃ¼cke."
            },
            authentischer_ausdruck: {
                "#ID": "#B176",
                label: "Authentischer Ausdruck",
                kategorie: "Kommunikationsstil",
                kategorieColor: "#3B82F6",
                definition: "Das BedÃ¼rfnis, ungefiltert zu kommunizieren â€“ keine soziale Maske, echte GefÃ¼hle zeigen.",
                quelle: "Osho â€“ AuthentizitÃ¤t",
                quelleDetail: "Authentischer Ausdruck erfordert Mut und die Bereitschaft, verletzlich zu sein."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - Soziales Leben
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            soziale_qualitaet: {
                "#ID": "#B194",
                label: "Soziale QualitÃ¤t",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach hochwertigen sozialen Beziehungen â€“ Tiefe statt Breite, QualitÃ¤t vor QuantitÃ¤t.",
                quelle: "Robert M. Pirsig â€“ QualitÃ¤t",
                quelleDetail: "QualitÃ¤t gilt auch fÃ¼r Beziehungen â€“ wenige tiefe sind wertvoller als viele oberflÃ¤chliche."
            },
            tribe_muster: {
                "#ID": "#B195",
                label: "Tribe-Muster",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach StammeszugehÃ¶rigkeit â€“ Teil einer Gruppe mit geteilter IdentitÃ¤t und Werten.",
                quelle: "Robert M. Pirsig â€“ Soziale Muster",
                quelleDetail: "Das Stammesmuster ist eines der ursprÃ¼nglichsten sozialen BedÃ¼rfnisse."
            },
            intellektuelle_gemeinschaft: {
                "#ID": "#B196",
                label: "Intellektuelle Gemeinschaft",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach Gleichgesinnten fÃ¼r geistigen Austausch â€“ philosophische GesprÃ¤che und geteilte Neugier.",
                quelle: "Robert M. Pirsig â€“ Intellektuelle Ebene",
                quelleDetail: "Intellektuelle Gemeinschaft transzendiert bloÃŸe soziale ZugehÃ¶rigkeit."
            },
            statische_sozialstrukturen: {
                "#ID": "#B197",
                label: "Statische Sozialstrukturen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach festen sozialen Rollen und Hierarchien â€“ Klarheit durch Struktur.",
                quelle: "Robert M. Pirsig â€“ Statische Muster",
                quelleDetail: "Statische Strukturen geben Orientierung, kÃ¶nnen aber auch einengen."
            },
            sannyas_gemeinschaft: {
                "#ID": "#B198",
                label: "Sannyas-Gemeinschaft",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach spiritueller Gemeinschaft â€“ Menschen auf dem gleichen inneren Weg.",
                quelle: "Osho â€“ Sannyas",
                quelleDetail: "Sannyas bedeutet bei Osho nicht Weltentsagung, sondern bewusstes Leben in Gemeinschaft."
            },
            rebellion_gegen_gesellschaft: {
                "#ID": "#B199",
                label: "Rebellion gegen Gesellschaft",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, gesellschaftliche Normen in Frage zu stellen â€“ Nonkonformismus als Freiheit.",
                quelle: "Osho â€“ Rebellion",
                quelleDetail: "Osho unterschied zwischen Reaktion (gegen etwas) und Rebellion (fÃ¼r Freiheit)."
            },
            einsamkeit_in_menge: {
                "#ID": "#B200",
                label: "Einsamkeit in Menge",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, auch in Gemeinschaft bei sich selbst zu bleiben â€“ allein und doch verbunden.",
                quelle: "Osho â€“ Aloneness",
                quelleDetail: "Osho unterschied zwischen Einsamkeit (loneliness) und Alleinsein (aloneness) â€“ letzteres ist positiv."
            },
            celebration_mit_anderen: {
                "#ID": "#B201",
                label: "Celebration mit Anderen",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis, gemeinsam zu feiern â€“ Freude, Tanz und Ekstase in der Gruppe.",
                quelle: "Osho â€“ Celebration",
                quelleDetail: "Oshos Ashrams waren fÃ¼r ihre Feiern und ekstatischen Meditationen bekannt."
            },
            keine_freundschaft_besitz: {
                "#ID": "#B202",
                label: "Keine Freundschafts-Besitz",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach Freundschaft ohne Besitzanspruch â€“ flieÃŸende, nicht-anhaftende Verbindungen.",
                quelle: "Osho â€“ Nicht-Anhaftung",
                quelleDetail: "Liebe ohne Besitzdenken gilt fÃ¼r alle Beziehungen, nicht nur romantische."
            },
            tantra_gruppe: {
                "#ID": "#B203",
                label: "Tantra-Gruppe",
                kategorie: "Soziales Leben",
                kategorieColor: "#8B5CF6",
                definition: "Das BedÃ¼rfnis nach Gruppen-IntimitÃ¤t und energetischem Austausch â€“ Verbindung jenseits des Individuellen.",
                quelle: "Osho â€“ Tantra",
                quelleDetail: "Oshos Tantra-Gruppen erforschten IntimitÃ¤t und Energie in geschÃ¼tztem Rahmen."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - IntimitÃ¤t & Romantik
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            biologische_anziehung: {
                label: "Biologische Anziehung",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach kÃ¶rperlicher Chemie und instinktiver Anziehung â€“ Pheromone und Biologie.",
                quelle: "Robert M. Pirsig â€“ Biologische Muster",
                quelleDetail: "Biologische Anziehung ist ein grundlegendes Muster, das intellektuell nicht vollstÃ¤ndig erklÃ¤rbar ist."
            },
            intellektuelle_verbindung: {
                label: "Intellektuelle Verbindung",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach geistigem Match â€“ gemeinsame WellenlÃ¤nge im Denken und in Interessen.",
                quelle: "Robert M. Pirsig â€“ Intellektuelle Ebene",
                quelleDetail: "Intellektuelle Verbindung ergÃ¤nzt biologische Anziehung um eine tiefere Dimension."
            },
            qualitaet_der_beruehrung: {
                label: "QualitÃ¤t der BerÃ¼hrung",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach achtsamer, prÃ¤senter BerÃ¼hrung â€“ QualitÃ¤t statt Routine.",
                quelle: "Robert M. Pirsig â€“ Care",
                quelleDetail: "Sorgfalt in der BerÃ¼hrung macht den Unterschied zwischen mechanisch und bedeutsam."
            },
            dynamische_liebe: {
                label: "Dynamische Liebe",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach sich entwickelnder, wachsender Liebe â€“ nicht statisch, sondern lebendig.",
                quelle: "Robert M. Pirsig â€“ Dynamische QualitÃ¤t",
                quelleDetail: "Dynamische Liebe Ã¼berrascht, wÃ¤chst und erneuert sich stÃ¤ndig."
            },
            care_in_intimitaet: {
                label: "Care in IntimitÃ¤t",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach Sorgfalt und Aufmerksamkeit in intimen Momenten â€“ PrÃ¤zision und Hingabe.",
                quelle: "Robert M. Pirsig â€“ Care",
                quelleDetail: "IntimitÃ¤t mit Care bedeutet volle Aufmerksamkeit und PrÃ¤senz."
            },
            sex_als_meditation: {
                label: "Sex als Meditation",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach tantrischer SexualitÃ¤t â€“ Sex als spirituelle Praxis und Meditation.",
                quelle: "Osho â€“ Tantra",
                quelleDetail: "Osho lehrte Sex als Tor zur Meditation, nicht als etwas zu UnterdrÃ¼ckendes."
            },
            liebe_ohne_beziehung: {
                label: "Liebe ohne Beziehung",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, zu lieben ohne Besitz und Erwartungen â€“ Liebe als Zustand, nicht als Vertrag.",
                quelle: "Osho â€“ Unconditional Love",
                quelleDetail: "Osho kritisierte Beziehungen, die auf Besitz statt auf Freiheit basieren."
            },
            orgastisches_leben: {
                label: "Orgastisches Leben",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach totaler kÃ¶rperlicher PrÃ¤senz â€“ der ganze KÃ¶rper als Instrument der Ekstase.",
                quelle: "Osho â€“ KÃ¶rper",
                quelleDetail: "Osho betonte die Heiligkeit des KÃ¶rpers und voller kÃ¶rperlicher Erfahrung."
            },
            nicht_anhaften_an_partner: {
                label: "Nicht-Anhaften an Partner",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach Freiheit in der Beziehung â€“ lieben ohne zu klammern.",
                quelle: "Osho â€“ Nicht-Anhaftung",
                quelleDetail: "Wahre Liebe hÃ¤lt nicht fest, sondern gibt FlÃ¼gel."
            },
            hier_und_jetzt_intimitaet: {
                label: "Hier-und-Jetzt-IntimitÃ¤t",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach vÃ¶lliger PrÃ¤senz in intimen Momenten â€“ keine Vergangenheit, keine Zukunft.",
                quelle: "Osho â€“ PrÃ¤senz",
                quelleDetail: "Nur im Jetzt ist echte IntimitÃ¤t mÃ¶glich."
            },
            polyamore_energie: {
                label: "Polyamore Energie",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis, Liebe und IntimitÃ¤t mit mehreren Menschen zu teilen â€“ Freiheit von Monogamie-Normen.",
                quelle: "Osho â€“ Freie Liebe",
                quelleDetail: "Osho stellte Monogamie als soziale Konditionierung in Frage."
            },
            wildheit_und_zartheit: {
                label: "Wildheit und Zartheit",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach beiden Polen â€“ sowohl wild und leidenschaftlich als auch sanft und zÃ¤rtlich.",
                quelle: "Osho â€“ PolaritÃ¤ten",
                quelleDetail: "Osho lehrte, alle PolaritÃ¤ten in sich zu vereinen."
            },
            meditation_zu_zweit: {
                label: "Meditation zu zweit",
                kategorie: "IntimitÃ¤t & Romantik",
                kategorieColor: "#EC4899",
                definition: "Das BedÃ¼rfnis nach gemeinsamer Stille und energetischer Verbindung â€“ zusammen meditieren.",
                quelle: "Osho â€“ Meditation",
                quelleDetail: "Gemeinsame Meditation kann tiefe Verbundenheit ohne Worte schaffen."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - Werte & Haltungen
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            qualitaet_als_gott: {
                label: "QualitÃ¤t als Gott",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, QualitÃ¤t als hÃ¶chsten Wert zu sehen â€“ eine sÃ¤kulare SpiritualitÃ¤t.",
                quelle: "Robert M. Pirsig â€“ Metaphysik der QualitÃ¤t",
                quelleDetail: "Pirsig schlÃ¤gt QualitÃ¤t als vereinendes Prinzip vor, das Wissenschaft und SpiritualitÃ¤t verbindet."
            },
            rationaler_mystizismus: {
                label: "Rationaler Mystizismus",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, Logik und SpiritualitÃ¤t zu verbinden â€“ Verstand und Transzendenz.",
                quelle: "Robert M. Pirsig â€“ Zen",
                quelleDetail: "Pirsigs Werk vereint analytisches Denken mit mystischer Erfahrung."
            },
            aristotelische_vernunft: {
                label: "Aristotelische Vernunft",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach logischem Denken und KausalitÃ¤t â€“ rationale WelterklÃ¤rung.",
                quelle: "Robert M. Pirsig â€“ Aristoteles-Kritik",
                quelleDetail: "Pirsig kritisiert, wie aristotelische Logik QualitÃ¤t nicht erfassen kann."
            },
            platonische_ideen: {
                label: "Platonische Ideen",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach absoluten Werten und ewigen Wahrheiten â€“ Idealismus.",
                quelle: "Robert M. Pirsig â€“ Platon",
                quelleDetail: "Pirsig setzt sich mit Platon auseinander, um seine eigene QualitÃ¤tsmetaphysik zu entwickeln."
            },
            buddhistische_achtsamkeit: {
                label: "Buddhistische Achtsamkeit",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach PrÃ¤senz und Nicht-DualitÃ¤t â€“ Zen als Lebensweg.",
                quelle: "Robert M. Pirsig â€“ Zen",
                quelleDetail: "Zen durchzieht Pirsigs Werk als Gegenpol zum rein analytischen Denken."
            },
            religionslosigkeit: {
                label: "Religionslosigkeit",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, frei von organisierten Religionen zu sein â€“ SpiritualitÃ¤t ohne Dogma.",
                quelle: "Osho â€“ Anti-Religion",
                quelleDetail: "Osho kritisierte alle organisierten Religionen als Hindernisse fÃ¼r wahre SpiritualitÃ¤t."
            },
            eigene_wahrheit: {
                label: "Eigene Wahrheit",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, die eigene Wahrheit selbst zu finden â€“ keine Ã¼bernommenen GlaubenssÃ¤tze.",
                quelle: "Osho â€“ IndividualitÃ¤t",
                quelleDetail: "Osho betonte, dass jeder seine eigene Wahrheit finden muss."
            },
            zen_paradox: {
                label: "Zen-Paradox",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach WidersprÃ¼chen und Koans â€“ den Verstand durch Paradoxe transzendieren.",
                quelle: "Osho â€“ Zen",
                quelleDetail: "Osho nutzte Zen-Geschichten und Paradoxe, um den analytischen Verstand zu Ã¼berwinden."
            },
            tantra_als_weg: {
                label: "Tantra als Weg",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach Bejahung von KÃ¶rper und Sinnlichkeit als spirituellem Weg â€“ keine Askese.",
                quelle: "Osho â€“ Tantra",
                quelleDetail: "Tantra sagt Ja zum Leben, zum KÃ¶rper, zur SexualitÃ¤t als Tor zum GÃ¶ttlichen."
            },
            politische_rebellion: {
                label: "Politische Rebellion",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, politische Systeme und Machtstrukturen in Frage zu stellen â€“ Anarchie des Geistes.",
                quelle: "Osho â€“ Politik-Kritik",
                quelleDetail: "Osho lehnte alle politischen Systeme als Formen der UnterdrÃ¼ckung ab."
            },
            individueller_anarchismus: {
                label: "Individueller Anarchismus",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach radikaler Freiheit â€“ keine AutoritÃ¤t auÃŸer dem eigenen Bewusstsein.",
                quelle: "Osho â€“ Freiheit",
                quelleDetail: "Wahre Freiheit ist innerlich und unabhÃ¤ngig von Ã¤uÃŸeren UmstÃ¤nden."
            },
            leben_als_kunst: {
                label: "Leben als Kunst",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis, das Leben selbst als kreatives Kunstwerk zu gestalten â€“ Ã¤sthetisch, nicht moralisch.",
                quelle: "Osho â€“ KreativitÃ¤t",
                quelleDetail: "Das Leben selbst ist die grÃ¶ÃŸte Leinwand fÃ¼r kreative Entfaltung."
            },
            celebration_statt_gebet: {
                label: "Celebration statt Gebet",
                kategorie: "Werte & Haltungen",
                kategorieColor: "#6366F1",
                definition: "Das BedÃ¼rfnis nach Freude statt Ernsthaftigkeit in der SpiritualitÃ¤t â€“ Feiern statt Bitten.",
                quelle: "Osho â€“ Celebration",
                quelleDetail: "Osho ersetzte frommes Gebet durch ekstatische Feier des Lebens."
            },

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PIRSIG & OSHO ERWEITERUNGEN - Praktisches Leben
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            motorrad_pflege: {
                label: "Motorrad-Pflege",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach handwerklicher Sorgfalt und TechnikverstÃ¤ndnis â€“ Wartung als Meditation.",
                quelle: "Robert M. Pirsig â€“ Motorrad",
                quelleDetail: "Das Motorrad ist Pirsigs Metapher fÃ¼r die Verbindung von Technik und Philosophie."
            },
            gumption_im_alltag: {
                label: "Gumption im Alltag",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach Motivation und Flow in tÃ¤glichen Aufgaben â€“ Enthusiasmus bewahren.",
                quelle: "Robert M. Pirsig â€“ Gumption",
                quelleDetail: "Gumption im Alltag verhindert, dass Routinen zur Last werden."
            },
            stuck_vermeiden: {
                label: "Stuck vermeiden",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, nicht festzustecken â€“ FlexibilitÃ¤t und KreativitÃ¤t bei Hindernissen.",
                quelle: "Robert M. Pirsig â€“ Gumption Traps",
                quelleDetail: "Pirsig beschreibt Fallen, die unsere Motivation blockieren, und wie man sie vermeidet."
            },
            klassische_ordnung: {
                label: "Klassische Ordnung",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach Systematik und Checklisten â€“ Struktur und rationale Organisation.",
                quelle: "Robert M. Pirsig â€“ Klassisch",
                quelleDetail: "Der klassische Ansatz analysiert und strukturiert fÃ¼r Effizienz."
            },
            romantisches_chaos: {
                label: "Romantisches Chaos",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach spontanem, intuitivem Alltag â€“ Gegen-Ordnung, kreatives Durcheinander.",
                quelle: "Robert M. Pirsig â€“ Romantisch",
                quelleDetail: "Der romantische Ansatz folgt dem GefÃ¼hl, nicht dem Plan."
            },
            qualitaets_werkzeug: {
                label: "QualitÃ¤ts-Werkzeug",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach gutem Werkzeug und richtiger AusrÃ¼stung â€“ QualitÃ¤t in den Mitteln.",
                quelle: "Robert M. Pirsig â€“ Werkzeug",
                quelleDetail: "Gutes Werkzeug ermÃ¶glicht gute Arbeit â€“ ein zentrales Thema bei Pirsig."
            },
            achtsamkeit_im_detail: {
                label: "Achtsamkeit im Detail",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach PrÃ¤zision und Perfektion in kleinen Dingen â€“ Sorgfalt im AlltÃ¤glichen.",
                quelle: "Robert M. Pirsig â€“ Care",
                quelleDetail: "QualitÃ¤t zeigt sich im Detail, in der Aufmerksamkeit fÃ¼r das Kleine."
            },
            meditation_im_alltag: {
                label: "Meditation im Alltag",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, alltÃ¤gliche TÃ¤tigkeiten meditativ zu verrichten â€“ Kochen, Putzen, Gehen als Praxis.",
                quelle: "Osho â€“ Alltagsmeditation",
                quelleDetail: "Osho lehrte, dass jede TÃ¤tigkeit zur Meditation werden kann."
            },
            gesundheit_durch_bewusstsein: {
                label: "Gesundheit durch Bewusstsein",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach natÃ¼rlicher Gesundheit durch Bewusstheit â€“ KÃ¶rperbewusstsein statt Pillen.",
                quelle: "Osho â€“ KÃ¶rper",
                quelleDetail: "Bewusstsein heilt â€“ der KÃ¶rper weiÃŸ, was er braucht, wenn wir ihm zuhÃ¶ren."
            },
            dynamische_meditation: {
                label: "Dynamische Meditation",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach kÃ¶rperlicher Bewegung als Meditation â€“ Oshos aktive Meditationstechniken.",
                quelle: "Osho â€“ Dynamische Meditation",
                quelleDetail: "Oshos bekannteste Technik: Kathartische Bewegung fÃ¼hrt zu Stille."
            },
            vipassana_im_leben: {
                label: "Vipassana im Leben",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis, im Alltag beobachtend und urteilsfrei zu sein â€“ Achtsamkeit in jeder Situation.",
                quelle: "Osho â€“ Vipassana",
                quelleDetail: "Beobachten ohne Urteilen, im Alltag integriert, nicht nur auf dem Kissen."
            },
            natuerliches_leben: {
                label: "NatÃ¼rliches Leben",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach naturnahem, einfachem Leben â€“ Bio-ErnÃ¤hrung, Naturkontakt, Reduktion.",
                quelle: "Osho â€“ NatÃ¼rlichkeit",
                quelleDetail: "ZurÃ¼ck zur Natur, weg von kÃ¼nstlicher KomplexitÃ¤t."
            },
            lachen_therapie: {
                label: "Lachen-Therapie",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach Humor als Heilung â€“ Lachen als tÃ¤gliche Medizin.",
                quelle: "Osho â€“ Lachen",
                quelleDetail: "Osho integrierte Lachen als spirituelle Praxis in viele seiner Meditationen."
            },
            no_mind: {
                label: "No-Mind",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach gedankenfreien Momenten im Alltag â€“ Stille im Kopf, PrÃ¤senz ohne Denken.",
                quelle: "Osho â€“ No-Mind",
                quelleDetail: "No-Mind ist der Zustand jenseits des Denkens, aber mit voller Wachheit."
            },
            zorba_der_geniesser: {
                label: "Zorba der GenieÃŸer",
                kategorie: "Praktisches Leben",
                kategorieColor: "#14B8A6",
                definition: "Das BedÃ¼rfnis nach sinnlichem Genuss â€“ gutes Essen, Trinken, Komfort und Lebensfreude.",
                quelle: "Osho â€“ Zorba",
                quelleDetail: "Zorba steht fÃ¼r die volle Bejahung des weltlichen Lebens in all seiner Sinnlichkeit."
            }
        };

        /**
         * Hilfsfunktion: Perspektive fÃ¼r Kategorie ermitteln
         */
        function getPerspektiveForKategorieModal(katId) {
            // GFK-Kern (#K1-#K10) â†’ #P1 (Statistik/GFK)
            // Dynamik (#K11) â†’ #P4 (SexPositiv)
            // Lebensthemen (#K12-#K18) â†’ #P1
            const katNum = parseInt(katId.replace('#K', ''));
            if (katNum === 11) return '#P4';
            return '#P1';
        }

        /**
         * Ã–ffnet das BedÃ¼rfnis-Definition Modal
         * @param {string} needId - Die ID des BedÃ¼rfnisses
         * @param {string} context - Kontext: 'resonance' fÃ¼r Match-Resonanz-Anzeige, 'info' fÃ¼r Standard (default)
         * @param {object} resonanceData - Optionale Resonanz-Daten {wert1, wert2, ichName, partnerName}
         */
        function openNeedDefinitionModal(needId, context, resonanceData) {
            console.log('[NEEDS] openNeedDefinitionModal called with:', needId, 'context:', context);
            const modal = document.getElementById('needDefinitionModal');
            const body = document.getElementById('needDefinitionModalBody');
            const title = document.getElementById('needDefinitionModalTitle');

            if (!modal || !body) {
                console.error('[NEEDS] Modal elements not found! modal:', modal, 'body:', body);
                return;
            }

            // Katalog prÃ¼fen
            const katalog = window.BeduerfnisKatalog;
            if (!katalog) {
                body.innerHTML = '<p style="color: var(--text-muted);">Katalog nicht geladen.</p>';
                modal.classList.add('active');
                return;
            }

            // Need-ID ermitteln (kann #B-ID oder string-key sein)
            let bId = needId;
            if (needId && !needId.startsWith('#B') && typeof BeduerfnisIds !== 'undefined') {
                bId = BeduerfnisIds.toId(needId) || needId;
            }

            // Need aus Katalog holen
            const need = katalog.beduerfnisse[bId];
            if (!need) {
                body.innerHTML = '<p style="color: var(--text-muted);">BedÃ¼rfnis ' + needId + ' nicht gefunden.</p>';
                modal.classList.add('active');
                return;
            }

            // Titel setzen
            title.textContent = need.label;

            // Kategorie, Dimension, Perspektive aus Katalog holen
            const kategorie = katalog.kategorien[need.kategorie];
            const dimension = katalog.dimensionen[need.dimension];
            const perspektive = kategorie ? katalog.perspektiven[getPerspektiveForKategorieModal(need.kategorie)] : null;

            // HTML aufbauen
            let html = '<div class="need-modal-content">';

            // ID Badge
            html += '\
                <div class="need-modal-id-row">\
                    <span class="need-modal-id">' + need.id + '</span>\
                    ' + (need.frageTyp ? '<span class="need-modal-type need-modal-type-' + need.frageTyp + '">' + (need.frageTyp === 'haupt' ? 'ğŸ“‹ Hauptfrage' : 'ğŸ“‘ Nuance') + '</span>' : '') + '\
                </div>\
            ';

            // Kategorie & Dimension
            html += '<div class="need-modal-meta-grid">';

            if (kategorie) {
                html += '\
                    <div class="need-modal-meta-item">\
                        <span class="need-modal-meta-label">Kategorie</span>\
                        <span class="need-modal-meta-value" style="color: ' + kategorie.color + '">\
                            <span class="need-modal-dot" style="background: ' + kategorie.color + '"></span>\
                            ' + kategorie.label + '\
                        </span>\
                    </div>\
                ';
            }

            if (dimension) {
                html += '\
                    <div class="need-modal-meta-item">\
                        <span class="need-modal-meta-label">Dimension</span>\
                        <span class="need-modal-meta-value" style="color: ' + dimension.color + '">\
                            <span class="need-modal-badge" style="background: ' + dimension.color + '">' + dimension.kurzform + '</span>\
                            ' + dimension.label + '\
                        </span>\
                    </div>\
                ';
            }

            if (perspektive) {
                html += '\
                    <div class="need-modal-meta-item">\
                        <span class="need-modal-meta-label">Perspektive</span>\
                        <span class="need-modal-meta-value">\
                            ' + perspektive.id + ' ' + perspektive.label + '\
                        </span>\
                    </div>\
                ';
            }

            html += '</div>';

            // Frage (wenn vorhanden)
            if (need.frage) {
                html += '\
                    <div class="need-modal-question">\
                        <span class="need-modal-question-icon">â“</span>\
                        <span class="need-modal-question-text">' + need.frage + '</span>\
                    </div>\
                ';
            }

            // Kontext (bei Nuancen)
            if (need.kontext) {
                html += '\
                    <div class="need-modal-context">\
                        <span class="need-modal-context-label">Kontext:</span>\
                        <span class="need-modal-context-text">' + need.kontext + '</span>\
                    </div>\
                ';
            }

            // HauptbedÃ¼rfnis-Referenz (bei Nuancen)
            if (need.hauptbeduerfnis) {
                const hauptNeed = katalog.beduerfnisse[need.hauptbeduerfnis];
                if (hauptNeed) {
                    html += '\
                        <div class="need-modal-parent">\
                            <span class="need-modal-parent-label">GehÃ¶rt zu:</span>\
                            <span class="need-modal-parent-link" onclick="openNeedWithResonance(\'' + need.hauptbeduerfnis + '\')">' + hauptNeed.label + ' (' + need.hauptbeduerfnis + ')</span>\
                        </div>\
                    ';
                }
            }

            // Nuancen (bei Hauptfragen)
            if (need.nuancen && need.nuancen.length > 0) {
                html += '\
                    <div class="need-modal-nuancen">\
                        <span class="need-modal-nuancen-label">Nuancen:</span>\
                        <div class="need-modal-nuancen-list">\
                            ' + need.nuancen.map(function(nId) {
                                const n = katalog.beduerfnisse[nId];
                                return n ? '<span class="need-modal-nuance-tag" onclick="openNeedWithResonance(\'' + nId + '\')">' + n.label + '</span>' : '';
                            }).join('') + '\
                        </div>\
                    </div>\
                ';
            }

            // Match-Resonanz Anzeige (nur bei TiageSynthese mit Resonanz-Daten)
            if (context === 'resonance' && resonanceData) {
                const matchPercent = 100 - Math.abs(resonanceData.wert1 - resonanceData.wert2);
                const rValue = (matchPercent / 100 * 1.1).toFixed(2);
                html += '\
                    <div class="need-modal-resonance">\
                        <div class="need-modal-resonance-header">\
                            <span class="need-modal-resonance-icon">ğŸ¯</span>\
                            <span class="need-modal-resonance-label">Match-Resonanz</span>\
                        </div>\
                        <div class="need-modal-resonance-content">\
                            <div class="need-modal-resonance-values">\
                                <span class="need-modal-resonance-person">' + resonanceData.ichName + ': <strong>' + resonanceData.wert1 + '</strong></span>\
                                <span class="need-modal-resonance-vs">vs</span>\
                                <span class="need-modal-resonance-person">' + resonanceData.partnerName + ': <strong>' + resonanceData.wert2 + '</strong></span>\
                            </div>\
                            <div class="need-modal-resonance-match">\
                                <span class="need-modal-resonance-percent">Match: <strong>' + Math.round(matchPercent) + '%</strong></span>\
                                <span class="need-modal-resonance-r">R = ' + rValue + '</span>\
                            </div>\
                        </div>\
                    </div>\
                ';
            }

            // Aktueller Wert ermitteln (aus resonanceData oder TiageState)
            let displayValue = 50; // Fallback
            if (context === 'resonance' && resonanceData && resonanceData.wert1 !== undefined) {
                displayValue = resonanceData.wert1;
            } else if (typeof TiageState !== 'undefined') {
                // Versuche aus TiageState.flatNeeds zu holen
                const flatNeeds = TiageState.get('flatNeeds.ich');
                if (flatNeeds) {
                    const needKey = typeof BeduerfnisIds !== 'undefined' ? BeduerfnisIds.toKey(bId) : null;
                    if (flatNeeds[bId] !== undefined) {
                        displayValue = flatNeeds[bId];
                    } else if (needKey && flatNeeds[needKey] !== undefined) {
                        displayValue = flatNeeds[needKey];
                    }
                }
            }

            // "Dein aktueller Wert" Anzeige (wie in needs-editor.html)
            html += '\
                <div class="need-modal-value" data-need-id="' + bId + '">\
                    <div class="need-modal-value-header">\
                        <span class="need-modal-value-label">Dein aktueller Wert</span>\
                        <span class="need-modal-value-number">' + displayValue + '</span>\
                    </div>\
                    <div class="need-modal-value-bar">\
                        <div class="need-modal-value-fill" style="width: ' + displayValue + '%"></div>\
                    </div>\
                </div>\
            ';

            // Statistische Daten berechnen (80% Konfidenzintervall)
            let statisticsHtml = '';
            const sigma = (kategorie && kategorie.sigma) || (typeof TiageStatistics !== 'undefined' ? TiageStatistics.DEFAULT_SIGMA : 14);

            // Typischen Wert aus Archetyp-Umfragedaten holen (statt hardcoded 50)
            let typicalValue = 50; // Fallback
            let archetypForStats = null;

            // 1. Versuche Archetyp aus TiageState zu holen
            if (typeof TiageState !== 'undefined') {
                archetypForStats = TiageState.get('archetypes.ich.primary');
            }
            // 2. Fallback: window.mobileIchArchetype
            if (!archetypForStats && typeof window.mobileIchArchetype !== 'undefined') {
                archetypForStats = window.mobileIchArchetype;
            }

            // 3. Hole typischen Wert aus BaseArchetypProfile
            if (archetypForStats && typeof window.BaseArchetypProfile !== 'undefined') {
                const baseProfil = window.BaseArchetypProfile[archetypForStats];
                if (baseProfil && baseProfil.umfrageWerte && baseProfil.umfrageWerte[needId] !== undefined) {
                    typicalValue = baseProfil.umfrageWerte[needId];
                }
            }

            if (typeof TiageStatistics !== 'undefined') {
                const interval = TiageStatistics.calculateConfidenceInterval(typicalValue, sigma, 80);
                statisticsHtml = '\
                    <div class="need-modal-statistics">\
                        <div class="need-modal-statistics-header">\
                            <span class="need-modal-statistics-icon">ğŸ“Š</span>\
                            <span class="need-modal-statistics-label">Statistischer Hintergrund</span>\
                        </div>\
                        <div class="need-modal-statistics-content">\
                            <div class="need-modal-statistics-text">\
                                80% der Befragten antworteten mit <strong>' + Math.round(interval.lower) + '-' + Math.round(interval.upper) + '</strong>\
                            </div>\
                            <div class="need-modal-statistics-sub">\
                                (Normalverteilung, Ïƒ=' + sigma + ', Konfidenzintervall Â±' + Math.round(interval.margin) + ')\
                            </div>\
                        </div>\
                    </div>\
                ';
            }

            html += statisticsHtml;
            html += '</div>';
            body.innerHTML = html;

            modal.classList.add('active');
        }

        /**
         * SchlieÃŸt das BedÃ¼rfnis-Definition Modal
         */
        function closeNeedDefinitionModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('needDefinitionModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Holt Resonanz-Daten fÃ¼r ein BedÃ¼rfnis aus dem aktuellen Matching
         * @param {string} needId - Die ID des BedÃ¼rfnisses
         * @returns {object|null} Resonanz-Daten {wert1, wert2, ichName, partnerName} oder null
         */
        function getResonanceDataForNeed(needId) {
            if (!lastGfkMatchingResult || !lastGfkMatchingResult.details) {
                return null;
            }

            // In allen Kategorien suchen (uebereinstimmend, komplementaer, konflikt)
            const allNeeds = [
                ...(lastGfkMatchingResult.details.uebereinstimmend || []),
                ...(lastGfkMatchingResult.details.komplementaer || []),
                ...(lastGfkMatchingResult.details.konflikt || [])
            ];

            const found = allNeeds.find(n => n.id === needId);
            if (!found) return null;

            // Namen holen
            const ichName = archetypeDescriptions[currentArchetype]?.name || 'Du';
            const partnerName = archetypeDescriptions[selectedPartner]?.name || 'Partner';

            return {
                wert1: found.wert1 || 0,
                wert2: found.wert2 || 0,
                ichName: ichName,
                partnerName: partnerName
            };
        }

        /**
         * Ã–ffnet das BedÃ¼rfnis-Detail-Modal
         * Diese Funktion wird von der AttributeSummaryCard aufgerufen
         * @param {string} needId - Die ID des BedÃ¼rfnisses
         */
        function openNeedWithResonance(needId) {
            // Resonanz-Daten aus lastGfkMatchingResult sammeln
            let resonanceData = null;
            if (lastGfkMatchingResult && lastGfkMatchingResult.details) {
                const allNeeds = [
                    ...(lastGfkMatchingResult.details.uebereinstimmend || []),
                    ...(lastGfkMatchingResult.details.komplementaer || []),
                    ...(lastGfkMatchingResult.details.konflikt || [])
                ];

                const ichName = archetypeDescriptions[currentArchetype]?.name || 'Du';
                const partnerName = archetypeDescriptions[selectedPartner]?.name || 'Partner';

                // Resonanz-Daten fÃ¼r dieses Need suchen (unterstÃ¼tzt verschiedene ID-Formate)
                let needData = allNeeds.find(function(n) {
                    return n.id === needId;
                });

                // Falls nicht gefunden, versuche alternative ID-Formate
                if (!needData && typeof BeduerfnisIds !== 'undefined') {
                    const altId = needId.startsWith('#B')
                        ? BeduerfnisIds.toKey(needId)
                        : BeduerfnisIds.toId(needId);
                    if (altId) {
                        needData = allNeeds.find(function(n) {
                            return n.id === altId || n.key === altId;
                        });
                    }
                }

                if (needData) {
                    resonanceData = {
                        wert1: needData.wert1 || 0,
                        wert2: needData.wert2 || 0,
                        ichName: ichName,
                        partnerName: partnerName
                    };
                }
            }

            // Modal Ã¶ffnen (mit Resonanz-Daten wenn vorhanden)
            openNeedDefinitionModal(needId, resonanceData ? 'resonance' : 'info', resonanceData);
        }

        /**
         * Ã–ffnet das GFK-BegriffserklÃ¤rung Modal
         */
        function openGfkExplanationModal(event) {
            if (event) event.stopPropagation();
            const modal = document.getElementById('gfkExplanationModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        /**
         * SchlieÃŸt das GFK-BegriffserklÃ¤rung Modal
         */
        function closeGfkExplanationModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('gfkExplanationModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Ã–ffnet das Paarung-BegriffserklÃ¤rung Modal
         */
        function openPaarungExplanationModal(event) {
            if (event) event.stopPropagation();
            const modal = document.getElementById('paarungExplanationModal');
            if (modal) {
                modal.classList.add('active');
            }
        }

        /**
         * SchlieÃŸt das Paarung-BegriffserklÃ¤rung Modal
         */
        function closePaarungExplanationModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('paarungExplanationModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        /**
         * Ã–ffnet das Attribut-Definition Modal (fÃ¼r Profile-Review Attribute)
         * @param {string} attrId - Die ID des Attributs (z.B. 'pr-kinder')
         */
        function openAttributeDefinitionModal(attrId) {
            const modal = document.getElementById('attributeDefinitionModal');
            const body = document.getElementById('attributeDefinitionModalBody');
            const title = document.getElementById('attributeDefinitionModalTitle');

            if (!modal || !body) return;

            // Attribut-Definition mit Kategorie suchen
            const attr = typeof ProfileReviewConfig !== 'undefined'
                ? ProfileReviewConfig.findAttributeWithCategory(attrId)
                : null;

            if (!attr) {
                body.innerHTML = '<p style="color: var(--text-muted);">Keine Definition verfÃ¼gbar.</p>';
                modal.classList.add('active');
                return;
            }

            // Titel setzen
            title.textContent = attr.label;

            // Optionen als Badges formatieren
            const optionsBadges = (attr.options || []).map(opt =>
                `<span style="display: inline-block; padding: 4px 10px; background: rgba(255,255,255,0.08); border-radius: 12px; font-size: 11px; color: var(--text-secondary);">${opt}</span>`
            ).join(' ');

            // Inhalt erstellen (Ã¤hnlich wie needDefinitionModal)
            body.innerHTML = `
                <div style="display: flex; flex-direction: column; gap: 16px;">
                    <!-- Kategorie-Badge -->
                    <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="width: 12px; height: 12px; border-radius: 50%; background: ${attr.kategorieColor};"></span>
                        <span style="font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;">${attr.kategorie}</span>
                    </div>

                    <!-- Beschreibung -->
                    <div style="background: rgba(255,255,255,0.03); border-radius: 12px; padding: 16px; border-left: 3px solid ${attr.kategorieColor};">
                        <p style="font-size: 14px; line-height: 1.7; color: var(--text-primary); margin: 0;">${attr.description || 'Keine Beschreibung verfÃ¼gbar.'}</p>
                    </div>

                    <!-- Optionen -->
                    <div style="padding: 12px; background: rgba(139,92,246,0.08); border-radius: 8px; border: 1px solid rgba(139,92,246,0.2);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <strong style="font-size: 12px; color: #8B5CF6;">MÃ¶gliche AusprÃ¤gungen</strong>
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 8px;">
                            ${optionsBadges}
                        </div>
                    </div>

                    <!-- Beziehungs-Bezug -->
                    <div style="padding: 12px; background: rgba(232,67,147,0.08); border-radius: 8px; border: 1px solid rgba(232,67,147,0.2);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                            <strong style="font-size: 12px; color: #E84393;">Paarung</strong>
                            <button onclick="openPaarungExplanationModal(event)" style="background: none; border: none; cursor: pointer; color: #E84393; font-size: 14px; padding: 2px 6px; border-radius: 4px; transition: background 0.2s;" title="Was bedeutet Paarung?">â“˜</button>
                        </div>
                        <p style="font-size: 11px; color: var(--text-secondary); margin: 0; line-height: 1.5;">
                            Unterschiedliche PrÃ¤ferenzen bei <strong>${attr.label}</strong> kÃ¶nnen Kompromisse erfordern â€“ offene Kommunikation hilft dabei, gemeinsame LÃ¶sungen zu finden.
                        </p>
                    </div>
                </div>
            `;

            modal.classList.add('active');
        }

        /**
         * SchlieÃŸt das Attribut-Definition Modal
         */
        function closeAttributeDefinitionModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('attributeDefinitionModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }
        window.openAttributeDefinitionModal = openAttributeDefinitionModal;
        window.closeAttributeDefinitionModal = closeAttributeDefinitionModal;

        /**
         * Ã–ffnet das Resonanzfaktor-Hilfe Modal
         * @param {string} rKey - Optional: Spezifischer R-Faktor (R1-R4) fÃ¼r Kurzform
         */
        function openResonanzHelpModal(rKey) {
            const modal = document.getElementById('resonanzHelpModal');
            const body = document.getElementById('resonanzHelpModalBody');
            const title = document.getElementById('resonanzHelpModalTitle');

            if (!modal || !body) return;

            // Hole Hilfe-Texte (check if TiageHelpTexts is loaded)
            if (typeof TiageHelpTexts === 'undefined') {
                console.warn('[TiageHelpTexts] nicht geladen - kann Resonanz-Hilfe nicht anzeigen');
                return;
            }

            let content = '';

            if (rKey && (rKey === 'R1' || rKey === 'R2' || rKey === 'R3' || rKey === 'R4')) {
                // Kurzform fÃ¼r einzelnen R-Faktor
                const quickHelp = TiageHelpTexts.getResonanzQuickHelp(rKey);
                title.textContent = quickHelp.titel;

                content = `
                    <div style="font-size: 14px; line-height: 1.7; color: var(--text-primary);">
                        <p style="margin: 0 0 16px 0; padding: 12px; background: rgba(139,92,246,0.1); border-left: 3px solid #8B5CF6; border-radius: 4px;">
                            ${quickHelp.beschreibung}
                        </p>

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">Berechnungsformel</h3>
                        <pre style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; font-size: 12px; overflow-x: auto; margin: 0 0 16px 0;">${quickHelp.formel}</pre>

                        <p style="margin: 0 0 16px 0; font-size: 13px; color: var(--text-secondary);">
                            Ã˜ = Durchschnitt Ã¼ber alle 4 Perspektiven (#P1 GFK, #P2 Osho, #P3 Pirsig, #P4 Kink)
                        </p>

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">Einfluss auf Endscore</h3>
                        <pre style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; font-size: 12px; overflow-x: auto; margin: 0 0 16px 0;">${quickHelp.einfluss}</pre>

                        <div style="margin: 20px 0 0 0; padding: 12px; background: rgba(234,179,8,0.1); border-left: 3px solid #eab308; border-radius: 4px; font-size: 13px;">
                            <strong>ğŸ’¡ Tipp:</strong> Klicke auf "Alle Details" unten, um die vollstÃ¤ndige ErklÃ¤rung mit Praxisbeispielen zu sehen.
                        </div>

                        <button class="profile-review-triple-btn" onclick="openResonanzHelpModal()" style="margin-top: 16px; width: 100%;">
                            ğŸ“š Alle Details anzeigen
                        </button>
                    </div>
                `;
            } else {
                // VollstÃ¤ndige ErklÃ¤rung
                const help = TiageHelpTexts.getResonanzCalculationExplanation();
                title.textContent = help.title;

                content = `
                    <div style="font-size: 14px; line-height: 1.7; color: var(--text-primary);">
                        <p style="margin: 0 0 8px 0; font-size: 13px; color: var(--text-secondary);">
                            ${help.subtitle}
                        </p>

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">Ãœbersicht</h3>
                        <p style="margin: 0 0 12px 0;">
                            ${help.overview.description}
                        </p>
                        <pre style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; font-size: 12px; overflow-x: auto; margin: 0 0 8px 0;">${help.overview.formula}</pre>
                        <ul style="font-size: 13px; margin: 0 0 16px 0; padding-left: 20px; color: var(--text-secondary);">
                            <li>${help.overview.range.min}</li>
                            <li>${help.overview.range.neutral}</li>
                            <li>${help.overview.range.max}</li>
                        </ul>

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">${help.perspektiven.title}</h3>
                        <p style="margin: 0 0 12px 0; font-size: 13px; color: var(--text-secondary);">
                            ${help.perspektiven.description}
                        </p>
                        ${help.perspektiven.list.map(p => `
                            <div style="margin: 0 0 12px 0; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 6px; border-left: 3px solid rgba(139,92,246,0.5);">
                                <div style="font-weight: 600; margin-bottom: 4px;">${p.id} ${p.name}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">${p.beschreibung}</div>
                                <div style="font-size: 12px; color: var(--text-tertiary);"><em>Beispiele: ${p.beispiele}</em></div>
                            </div>
                        `).join('')}

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">${help.calculation.title}</h3>
                        ${help.calculation.steps.map(step => `
                            <div style="margin: 0 0 16px 0; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                                <div style="font-weight: 600; margin-bottom: 8px;">Schritt ${step.nr}: ${step.titel}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 8px;">${step.beschreibung}</div>
                                ${step.formel ? `<pre style="background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; font-size: 11px; overflow-x: auto; margin: 0 0 8px 0;">${step.formel}</pre>` : ''}
                                ${step.beispiel && typeof step.beispiel === 'string' ? `
                                    <div style="font-size: 12px; padding: 8px; background: rgba(234,179,8,0.1); border-radius: 4px; color: var(--text-tertiary);">
                                        <strong>Beispiel:</strong> ${step.beispiel}
                                    </div>
                                ` : ''}
                                ${step.beispiel && typeof step.beispiel === 'object' && step.beispiel.titel ? `
                                    <div style="font-size: 12px; padding: 8px; background: rgba(234,179,8,0.1); border-radius: 4px;">
                                        <div style="font-weight: 600; margin-bottom: 4px;">${step.beispiel.titel}</div>
                                        ${Object.keys(step.beispiel.perspektiveScores || {}).map(k => `
                                            <div style="margin: 2px 0; color: var(--text-tertiary);">${k}: ${step.beispiel.perspektiveScores[k]}</div>
                                        `).join('')}
                                        ${step.beispiel.durchschnitt ? `<div style="margin: 4px 0 2px 0; font-weight: 600;">â†’ ${step.beispiel.durchschnitt}</div>` : ''}
                                        ${step.beispiel.rWert ? `<div style="margin: 2px 0; font-weight: 600; color: #8B5CF6;">â†’ ${step.beispiel.rWert}</div>` : ''}
                                        ${step.beispiel.person1 ? `<div style="margin: 2px 0; color: var(--text-tertiary);">Person 1: ${step.beispiel.person1}</div>` : ''}
                                        ${step.beispiel.person2 ? `<div style="margin: 2px 0; color: var(--text-tertiary);">Person 2: ${step.beispiel.person2}</div>` : ''}
                                        ${step.beispiel.kombiniert ? `<div style="margin: 4px 0 0 0; font-weight: 600; color: #8B5CF6;">â†’ ${step.beispiel.kombiniert}</div>` : ''}
                                    </div>
                                ` : ''}
                                ${step.interpretation ? `
                                    <div style="font-size: 12px; margin-top: 8px; color: var(--text-secondary); font-style: italic;">
                                        ğŸ’¡ ${step.interpretation}
                                    </div>
                                ` : ''}
                            </div>
                        `).join('')}

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">${help.faktoren.title}</h3>
                        <p style="margin: 0 0 12px 0; font-size: 13px; color: var(--text-secondary);">
                            ${help.faktoren.description}
                        </p>
                        ${help.faktoren.list.map(f => `
                            <div style="margin: 0 0 12px 0; padding: 12px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                                <div style="font-weight: 600; margin-bottom: 4px;">${f.id} ${f.name} ${f.sourceLabel}</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 4px;">
                                    Kategorien: ${f.kategorien.join(', ')}
                                </div>
                                <pre style="background: rgba(255,255,255,0.05); padding: 8px; border-radius: 4px; font-size: 11px; overflow-x: auto; margin: 0;">${f.einfluss}</pre>
                            </div>
                        `).join('')}

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">${help.praxisbeispiel.title}</h3>
                        <div style="padding: 12px; background: rgba(234,179,8,0.1); border-left: 3px solid #eab308; border-radius: 4px; margin-bottom: 16px;">
                            <div style="font-weight: 600; margin-bottom: 8px;">${help.praxisbeispiel.situation}</div>
                            ${help.praxisbeispiel.bedÃ¼rfnisse.map(b => `
                                <div style="margin: 4px 0; font-size: 12px; color: var(--text-tertiary);">
                                    â€¢ ${b.key} (${b.perspektive}): Archetyp ${b.solopoly}, Dein Wert ${b.dein} â†’ Î” ${b.diff}
                                </div>
                            `).join('')}
                            <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(234,179,8,0.3);">
                                <div style="font-weight: 600; margin-bottom: 4px;">Auswirkung:</div>
                                <div style="font-size: 13px; color: var(--text-secondary); margin-bottom: 8px;">${help.praxisbeispiel.auswirkung.beschreibung}</div>
                                ${Object.keys(help.praxisbeispiel.auswirkung.perspektivenAuswertung).map(k => `
                                    <div style="margin: 2px 0; font-size: 12px; color: var(--text-tertiary);">
                                        â€¢ ${k}: ${help.praxisbeispiel.auswirkung.perspektivenAuswertung[k]}
                                    </div>
                                `).join('')}
                                <div style="margin-top: 8px; padding: 8px; background: rgba(255,255,255,0.05); border-radius: 4px; font-size: 12px;">
                                    <strong>ğŸ’¡ Empfehlung:</strong> ${help.praxisbeispiel.auswirkung.empfehlung}
                                </div>
                            </div>
                        </div>

                        <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #8B5CF6;">Wichtige Hinweise</h3>
                        <ul style="font-size: 13px; margin: 0; padding-left: 20px; color: var(--text-secondary);">
                            ${help.wichtigeHinweise.map(h => `<li style="margin-bottom: 8px;">${h}</li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            body.innerHTML = content;
            modal.classList.add('active');
        }

        /**
         * SchlieÃŸt das Resonanzfaktor-Hilfe Modal
         */
        function closeResonanzHelpModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('resonanzHelpModal');
            if (modal) {
                modal.classList.remove('active');
            }
        }

        window.openResonanzHelpModal = openResonanzHelpModal;
        window.closeResonanzHelpModal = closeResonanzHelpModal;

        // Aktueller Tab fÃ¼r das vollstÃ¤ndige Modal
        let needsFullModalCurrentTab = 'gemeinsam';
        // Sortierung: 'duo' oder 'ra', und Richtung: 'asc' oder 'desc'
        let needsFullModalSortBy = null;
        let needsFullModalSortDir = 'desc';

        /**
         * Ã–ffnet das vollstÃ¤ndige BedÃ¼rfnis-Modal mit Toggle
         */
        function openNeedsFullModal() {
            needsFullModalCurrentTab = 'gemeinsam';
            needsFullModalSortBy = null;
            needsFullModalSortDir = 'desc';
            renderNeedsFullModal();
        }

        /**
         * Ã–ffnet das Modal mit der ErklÃ¤rung zur BedÃ¼rfnis-Score-Berechnung
         */
        function openNeedsScoreExplanation() {
            const modal = document.getElementById('needsScoreExplanationModal');
            const body = document.getElementById('needsScoreExplanationBody');

            if (!modal || !body) return;

            // ErklÃ¤rungstext als HTML
            const explanationHTML = `
                <div style="font-size: 14px; line-height: 1.7; color: var(--text-primary);">
                    <h3 style="font-size: 16px; font-weight: 600; margin: 0 0 12px 0; color: #22c55e;">Was bedeutet die Zahl?</h3>
                    <p style="margin: 0 0 16px 0;">
                        Die Prozentanzeige zeigt die <strong>gewichtete Ãœbereinstimmung Ã¼ber alle 224 BedÃ¼rfnisse</strong> zwischen beiden Profilen.
                    </p>
                    <p style="margin: 0 0 20px 0; padding: 12px; background: rgba(34,197,94,0.1); border-left: 3px solid #22c55e; border-radius: 4px; font-size: 13px;">
                        <strong>Nicht:</strong> Eine SchÃ¤tzung oder theoretischer Wert<br>
                        <strong>Sondern:</strong> Empirisch berechnet aus euren tatsÃ¤chlichen BedÃ¼rfnis-Profilen
                    </p>

                    <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #22c55e;">Wie wird sie berechnet?</h3>
                    <p style="margin: 0 0 12px 0;">
                        <strong>Formel</strong> (identisch mit individueller BedÃ¼rfnis-Berechnung):
                    </p>
                    <pre style="background: rgba(255,255,255,0.05); padding: 12px; border-radius: 6px; font-size: 12px; overflow-x: auto; margin: 0 0 12px 0; line-height: 1.6;">FÃ¼r JEDES der 224 BedÃ¼rfnisse:
    Ã„hnlichkeit = 100 - |Wert Person 1 - Wert Person 2|
    Gewicht = (Wert Person 1 + Wert Person 2) / 2
    Beitrag = Ã„hnlichkeit Ã— Gewicht

Gesamt-Score = Î£(Beitrag) / Î£(Gewicht)</pre>

                    <p style="margin: 0 0 16px 0; padding: 12px; background: rgba(234,179,8,0.1); border-left: 3px solid #eab308; border-radius: 4px; font-size: 13px;">
                        <strong>Beispiel #B90 Kinderwunsch:</strong><br>
                        Person 1 = 85, Person 2 = 40<br>
                        â†’ Ã„hnlichkeit = 100 - |85 - 40| = <strong>55</strong><br>
                        â†’ Gewicht = (85 + 40) / 2 = <strong>62.5</strong><br>
                        â†’ Beitrag = 55 Ã— 62.5 = <strong>3437.5</strong>
                    </p>

                    <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #22c55e;">Alle 224 BedÃ¼rfnisse</h3>
                    <table style="width: 100%; font-size: 12px; border-collapse: collapse; margin: 0 0 20px 0;">
                        <thead>
                            <tr style="background: rgba(255,255,255,0.05);">
                                <th style="padding: 8px; text-align: left; border-bottom: 1px solid rgba(255,255,255,0.1);">Kategorie</th>
                                <th style="padding: 8px; text-align: right; border-bottom: 1px solid rgba(255,255,255,0.1);">Anzahl</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr><td style="padding: 6px 8px;">#B1-#B88: GFK-Kern</td><td style="padding: 6px 8px; text-align: right;">88</td></tr>
                            <tr><td style="padding: 6px 8px;">#B90-#B126: Lebensplanung</td><td style="padding: 6px 8px; text-align: right;">37</td></tr>
                            <tr><td style="padding: 6px 8px;">#B127-#B148: Finanzen & Karriere</td><td style="padding: 6px 8px; text-align: right;">22</td></tr>
                            <tr><td style="padding: 6px 8px;">#B149-#B176: Kommunikationsstil</td><td style="padding: 6px 8px; text-align: right;">28</td></tr>
                            <tr><td style="padding: 6px 8px;">#B177-#B203: Soziales Leben</td><td style="padding: 6px 8px; text-align: right;">27</td></tr>
                            <tr><td style="padding: 6px 8px;">#B204-#B208: IntimitÃ¤t & Romantik</td><td style="padding: 6px 8px; text-align: right;">5</td></tr>
                            <tr><td style="padding: 6px 8px;">#B209-#B224: Dynamik & Genussmittel erweitert</td><td style="padding: 6px 8px; text-align: right;">16</td></tr>
                            <tr style="border-top: 2px solid rgba(34,197,94,0.3); font-weight: 600;">
                                <td style="padding: 8px;"><strong>Total</strong></td>
                                <td style="padding: 8px; text-align: right;"><strong>224</strong></td>
                            </tr>
                        </tbody>
                    </table>

                    <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #22c55e;">Farbliche Bewertung</h3>
                    <div style="display: flex; flex-direction: column; gap: 8px; margin: 0 0 20px 0;">
                        <div style="display: flex; align-items: center; gap: 12px; padding: 8px; background: rgba(34,197,94,0.1); border-radius: 4px;">
                            <span style="font-size: 20px;">ğŸŸ¢</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">60-100% - Hoch</div>
                                <div style="font-size: 12px; opacity: 0.8;">Starke Ãœbereinstimmung</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px; padding: 8px; background: rgba(234,179,8,0.1); border-radius: 4px;">
                            <span style="font-size: 20px;">ğŸŸ¡</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">40-59% - Mittel</div>
                                <div style="font-size: 12px; opacity: 0.8;">Moderate Ãœbereinstimmung</div>
                            </div>
                        </div>
                        <div style="display: flex; align-items: center; gap: 12px; padding: 8px; background: rgba(239,68,68,0.1); border-radius: 4px;">
                            <span style="font-size: 20px;">ğŸ”´</span>
                            <div style="flex: 1;">
                                <div style="font-weight: 600;">0-39% - Niedrig</div>
                                <div style="font-size: 12px; opacity: 0.8;">Geringe Ãœbereinstimmung</div>
                            </div>
                        </div>
                    </div>

                    <h3 style="font-size: 16px; font-weight: 600; margin: 20px 0 12px 0; color: #22c55e;">Vorteile der Berechnung</h3>
                    <div style="display: flex; flex-direction: column; gap: 6px; font-size: 13px;">
                        <div style="display: flex; align-items: start; gap: 8px;">
                            <span style="color: #22c55e; font-weight: 600;">âœ…</span>
                            <div><strong>Empirisch statt willkÃ¼rlich</strong> - Basiert auf tatsÃ¤chlichen BedÃ¼rfnis-Profilen</div>
                        </div>
                        <div style="display: flex; align-items: start; gap: 8px;">
                            <span style="color: #22c55e; font-weight: 600;">âœ…</span>
                            <div><strong>Transparent</strong> - Jeder Wert ist nachvollziehbar</div>
                        </div>
                        <div style="display: flex; align-items: start; gap: 8px;">
                            <span style="color: #22c55e; font-weight: 600;">âœ…</span>
                            <div><strong>Individualisiert</strong> - BerÃ¼cksichtigt eure persÃ¶nlichen Modifikatoren</div>
                        </div>
                        <div style="display: flex; align-items: start; gap: 8px;">
                            <span style="color: #22c55e; font-weight: 600;">âœ…</span>
                            <div><strong>Konsistent</strong> - Dieselbe Formel wie die Gesamt-BedÃ¼rfnis-Berechnung</div>
                        </div>
                    </div>
                </div>
            `;

            body.innerHTML = explanationHTML;
            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        /**
         * SchlieÃŸt das Score-ErklÃ¤rungsmodal
         */
        function closeNeedsScoreExplanation(event) {
            if (event && event.target.id !== 'needsScoreExplanationModal') return;
            const modal = document.getElementById('needsScoreExplanationModal');
            if (modal) {
                modal.classList.remove('active');
                document.body.style.overflow = '';
            }
        }

        /**
         * Wechselt den Tab im vollstÃ¤ndigen Modal
         */
        function switchNeedsFullModalTab(tab) {
            needsFullModalCurrentTab = tab;
            needsFullModalSortBy = null;
            needsFullModalSortDir = 'desc';
            renderNeedsFullModal();
        }

        /**
         * Sortiert die BedÃ¼rfnis-Liste nach DUO oder RA Werten
         * @param {string} column - 'duo' oder 'ra'
         */
        function sortNeedsFullModal(column) {
            if (needsFullModalSortBy === column) {
                // Toggle direction if same column
                needsFullModalSortDir = needsFullModalSortDir === 'desc' ? 'asc' : 'desc';
            } else {
                // New column, start with descending
                needsFullModalSortBy = column;
                needsFullModalSortDir = 'desc';
            }
            renderNeedsFullModal();
        }

        /**
         * Rendert das vollstÃ¤ndige BedÃ¼rfnis-Modal
         */
        function renderNeedsFullModal() {
            const modal = document.getElementById('needsCompareModal');
            const body = document.getElementById('needsCompareModalBody');
            const title = document.getElementById('needsCompareModalTitle');

            if (!modal || !body) return;

            // Matching-Daten holen - SchlÃ¼ssel unverÃ¤ndert lassen (duo_flex, nicht duo-flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';

            if (!ichArchetyp || !partnerArchetyp) {
                body.innerHTML = '<p style="color: var(--text-muted);">Keine Daten verfÃ¼gbar.</p>';
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            const ichName = archetypeDescriptions[currentArchetype]?.name || 'ICH';
            const partnerName = archetypeDescriptions[selectedPartner]?.name || 'Partner';

            // NEU: Direkt aus TiageState.flatNeeds lesen
            let matching = null;
            let isFallback = false;

            // PrimÃ¤r: Direkt aus TiageState.flatNeeds
            const result = calculateNeedsMatchFromFlatNeeds();
            if (result) {
                // Format-Konvertierung: need â†’ { label, id, wert1, wert2, diff }
                const formatNeed = (item) => ({
                    label: formatBeduerfnisLabel(item.need),
                    id: item.need,
                    wert1: item.wert1,
                    wert2: item.wert2,
                    diff: Math.abs(item.wert1 - item.wert2)
                });

                matching = {
                    details: {
                        uebereinstimmend: result.gemeinsam.map(formatNeed),
                        komplementaer: result.komplementaer.map(formatNeed),
                        konflikt: result.unterschiedlich.map(formatNeed)
                    }
                };
                console.log('[renderNeedsFullModal] âœ“ Verwende individualisierte Werte aus TiageState.flatNeeds');
            }

            // Fallback: Alte Methode (nur Archetyp - falls flatNeeds leer)
            if (!matching && typeof GfkBeduerfnisse !== 'undefined') {
                matching = GfkBeduerfnisse.berechneMatching(ichArchetyp, partnerArchetyp);
                isFallback = true;
                console.log('[renderNeedsFullModal] âš  Fallback: Verwende Archetyp-basierte BedÃ¼rfniswerte');
            }

            if (!matching) {
                body.innerHTML = '<p style="color: var(--text-muted);">Keine Daten verfÃ¼gbar.</p>';
                modal.classList.add('active');
                document.body.style.overflow = 'hidden';
                return;
            }

            // Titel setzen
            title.textContent = 'BedÃ¼rfnis-Vergleich';

            // VollstÃ¤ndige Listen aus details holen
            const type = needsFullModalCurrentTab;
            let items;
            if (type === 'gemeinsam') {
                // Combine uebereinstimmend + komplementaer for "gemeinsam" tab
                const uebereinstimmend = matching.details?.uebereinstimmend || [];
                const komplementaer = matching.details?.komplementaer || [];
                items = [...uebereinstimmend, ...komplementaer];
                // Sort by average importance if not already sorted
                if (items.length > 0 && !needsFullModalSortBy) {
                    items.sort((a, b) => ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2));
                }
                // Fallback
                if (items.length === 0) items = matching.topUebereinstimmungen || [];
            } else {
                items = matching.details?.konflikt || matching.topKonflikte || [];
            }

            // Sortieren falls aktiv
            if (needsFullModalSortBy && items.length > 0) {
                items = [...items].sort((a, b) => {
                    let valA, valB;
                    if (needsFullModalSortBy === 'duo') {
                        valA = a.wert1 || 0;
                        valB = b.wert1 || 0;
                    } else if (needsFullModalSortBy === 'diff') {
                        valA = Math.abs((a.wert1 || 0) - (a.wert2 || 0));
                        valB = Math.abs((b.wert1 || 0) - (b.wert2 || 0));
                    } else {
                        valA = a.wert2 || 0;
                        valB = b.wert2 || 0;
                    }
                    return needsFullModalSortDir === 'desc' ? valB - valA : valA - valB;
                });
            }

            // Explanation HTML
            const explanationHtml = `
                <div style="background: rgba(34,197,94,0.08); border-left: 3px solid #22c55e; border-radius: 4px; padding: 10px 12px; margin-bottom: 16px; font-size: 12px; line-height: 1.6;">
                    <div style="display: flex; align-items: start; gap: 8px;">
                        <div style="flex: 1;">
                            <div style="font-weight: 600; margin-bottom: 4px; color: #22c55e;">Berechnung Ã¼ber alle 224 BedÃ¼rfnisse</div>
                            <div style="color: var(--text-secondary); font-size: 11px;">
                                Gewichtete Ãœbereinstimmung basierend auf euren tatsÃ¤chlichen Profilen.
                                <span onclick="openNeedsScoreExplanation();" style="color: #22c55e; cursor: pointer; text-decoration: underline; margin-left: 4px;">Mehr erfahren â“˜</span>
                            </div>
                        </div>
                    </div>
                </div>
            `;

            // Toggle-Button HTML
            const toggleHtml = `
                <div style="display: flex; gap: 0; margin-bottom: 16px; background: rgba(255,255,255,0.05); border-radius: 8px; padding: 4px;">
                    <button onclick="switchNeedsFullModalTab('gemeinsam')" style="flex: 1; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s; ${type === 'gemeinsam' ? 'background: #22c55e; color: white;' : 'background: transparent; color: var(--text-muted);'}">
                        Gemeinsame & Kompatible
                    </button>
                    <button onclick="switchNeedsFullModalTab('unterschiedlich')" style="flex: 1; padding: 10px 16px; border: none; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s; ${type === 'unterschiedlich' ? 'background: #ef4444; color: white;' : 'background: transparent; color: var(--text-muted);'}">
                        Unterschiedliche PrioritÃ¤ten
                    </button>
                </div>
            `;

            // Sort-Icons
            const duoSortIcon = needsFullModalSortBy === 'duo'
                ? (needsFullModalSortDir === 'desc' ? 'â–¼' : 'â–²')
                : 'â‡…';
            const diffSortIcon = needsFullModalSortBy === 'diff'
                ? (needsFullModalSortDir === 'desc' ? 'â–¼' : 'â–²')
                : 'â‡…';
            const raSortIcon = needsFullModalSortBy === 'ra'
                ? (needsFullModalSortDir === 'desc' ? 'â–¼' : 'â–²')
                : 'â‡…';
            const duoActive = needsFullModalSortBy === 'duo';
            const diffActive = needsFullModalSortBy === 'diff';
            const raActive = needsFullModalSortBy === 'ra';

            // Header mit Namen und Sortier-Buttons
            const headerHtml = `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <button onclick="sortNeedsFullModal('duo')" style="display: flex; align-items: center; justify-content: center; gap: 6px; background: ${duoActive ? 'rgba(34, 197, 94, 0.15)' : 'transparent'}; border: 1px solid ${duoActive ? 'rgba(34, 197, 94, 0.4)' : 'transparent'}; border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: all 0.2s;">
                        <span style="font-weight: 600; color: var(--success); font-size: 11px; text-transform: uppercase; letter-spacing: 1px;">${ichName}</span>
                        <span style="color: ${duoActive ? 'var(--success)' : 'var(--text-muted)'}; font-size: 10px;">${duoSortIcon}</span>
                    </button>
                    <button onclick="sortNeedsFullModal('diff')" style="display: flex; align-items: center; justify-content: center; gap: 4px; background: ${diffActive ? 'rgba(234, 179, 8, 0.15)' : 'transparent'}; border: 1px solid ${diffActive ? 'rgba(234, 179, 8, 0.4)' : 'transparent'}; border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: all 0.2s; min-width: 60px;">
                        <span style="font-weight: 600; color: var(--warning, #eab308); font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px;">Diff</span>
                        <span style="color: ${diffActive ? 'var(--warning, #eab308)' : 'var(--text-muted)'}; font-size: 10px;">${diffSortIcon}</span>
                    </button>
                    <button onclick="sortNeedsFullModal('ra')" style="display: flex; align-items: center; justify-content: center; gap: 6px; background: ${raActive ? 'rgba(239, 68, 68, 0.15)' : 'transparent'}; border: 1px solid ${raActive ? 'rgba(239, 68, 68, 0.4)' : 'transparent'}; border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: all 0.2s;">
                        <span style="font-weight: 600; color: var(--danger); font-size: 11px; text-transform: uppercase; letter-spacing: 1px;">${partnerName}</span>
                        <span style="color: ${raActive ? 'var(--danger)' : 'var(--text-muted)'}; font-size: 10px;">${raSortIcon}</span>
                    </button>
                </div>
            `;

            let listHtml = '';
            if (items.length === 0) {
                listHtml = '<p style="color: var(--text-muted); text-align: center; padding: 20px;">Keine EintrÃ¤ge vorhanden.</p>';
            } else {
                listHtml = '<div style="display: flex; flex-direction: column; gap: 6px; max-height: calc(70vh - 180px); overflow-y: auto;">';

                items.forEach(item => {
                    // item.id ist jetzt #B-ID, item.label ist der Display-Name
                    const label = item.label;
                    const wert1 = item.wert1 || 0;
                    const wert2 = item.wert2 || 0;
                    const diff = Math.abs(wert1 - wert2);

                    // Status-Icon und Farbe
                    let statusColor;
                    if (diff <= 15) {
                        statusColor = '#22c55e';
                    } else if (diff <= 35) {
                        statusColor = '#eab308';
                    } else {
                        statusColor = '#ef4444';
                    }

                    listHtml += `
                        <div style="background: rgba(255,255,255,0.03); border-radius: 6px; padding: 10px 12px; border-left: 3px solid ${statusColor};">
                            <div onclick="openNeedWithResonance('${item.id}')" style="font-weight: 500; color: var(--text-primary); font-size: 13px; margin-bottom: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s;" onmouseover="this.style.color='var(--primary)'" onmouseout="this.style.color='var(--text-primary)'">
                                ${label}
                                <span style="font-size: 10px; opacity: 0.5;">â“˜</span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div style="flex: 1; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert1}%; height: 100%; background: var(--success); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 32px; text-align: right;">${wert1}</span>
                                </div>
                                <div style="display: flex; align-items: center; justify-content: center; min-width: 50px;">
                                    <span style="font-size: 11px; font-weight: 600; color: ${statusColor}; background: ${statusColor}22; padding: 2px 6px; border-radius: 4px;">${diff}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    <div style="flex: 1; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert2}%; height: 100%; background: var(--danger); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 32px; text-align: right;">${wert2}</span>
                                </div>
                            </div>
                        </div>
                    `;
                });

                listHtml += '</div>';
            }

            // Anzahl anzeigen
            const countHtml = `
                <div style="margin-top: 12px; text-align: center; font-size: 11px; color: var(--text-muted);">
                    ${items.length} ${type === 'gemeinsam' ? 'gemeinsame & kompatible BedÃ¼rfnisse' : 'unterschiedliche PrioritÃ¤ten'}
                </div>
            `;

            // Fallback Banner
            let fallbackBannerHtml = '';
            if (isFallback) {
                fallbackBannerHtml = `
                    <div style="
                        background: rgba(234, 179, 8, 0.1);
                        border: 1px solid rgba(234, 179, 8, 0.3);
                        border-radius: 6px;
                        padding: 8px 12px;
                        margin-bottom: 16px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    ">
                        <span style="font-size: 14px;">â„¹ï¸</span>
                        <div style="flex: 1;">
                            <div style="font-size: 11px; font-weight: 600; color: #eab308; margin-bottom: 2px;">Archetyp-Basis-Werte</div>
                            <div style="font-size: 10px; color: var(--text-muted); line-height: 1.4;">
                                Individualisierte Werte nicht verfÃ¼gbar. Es werden Standard-Archetyp-Werte angezeigt.
                            </div>
                        </div>
                    </div>
                `;
            }

            body.innerHTML = explanationHtml + toggleHtml + fallbackBannerHtml + headerHtml + listHtml + countHtml;

            modal.classList.add('active');
            document.body.style.overflow = 'hidden';
        }

        /**
         * Sync GFK UI across all views
         */
        function syncGfkUI(person) {
            const selected = personDimensions[person].gfk;

            // All GFK button selectors for this person
            const selectors = [
                `.gfk-grid[data-person="${person}"] .gfk-btn`,
                `#${person}-gfk-grid .gfk-btn`,
                `#mobile-${person}-gfk-grid .gfk-btn`
            ];

            selectors.forEach(selector => {
                document.querySelectorAll(selector).forEach(btn => {
                    const value = btn.dataset.value;

                    // Remove selection state
                    btn.classList.remove('selected', 'primary-selected');

                    // Add selected state if this is the chosen value
                    if (value === selected) {
                        btn.classList.add('selected', 'primary-selected');
                    }
                });
            });

            // Update summary text
            updateGfkSummary(person);
        }

        /**
         * Get GFK summary text
         */
        function getGfkSummary(person) {
            const gfk = personDimensions[person].gfk;
            if (!gfk) return 'GFK fehlt';
            return `GFK: ${gfk}`;
        }

        /**
         * Update GFK summary display
         */
        function updateGfkSummary(person) {
            const gfk = personDimensions[person].gfk;
            const isMissing = !gfk;

            // Update header element
            const headerId = `${person}-header-gfk`;
            const header = document.getElementById(headerId);
            if (header) {
                header.textContent = getGfkSummary(person);
                header.classList.toggle('missing', isMissing);
            }

            // Update grid collapsed-summary
            ['', 'mobile-'].forEach(prefix => {
                const summaryId = `${prefix}${person}-gfk-summary`;
                const summary = document.getElementById(summaryId);
                if (summary) {
                    summary.textContent = gfk ? `âœ“ ${gfk}` : '';
                    summary.classList.toggle('has-selection', !isMissing);
                }
            });
        }

        // Helper: Check if GFK is selected
        function hasGfkSelected(person) {
            return personDimensions[person].gfk !== null;
        }

        // ========================================
        // GFK-BedÃ¼rfnis-Matching (nach Marshall Rosenberg)
        // ========================================

        // Globale Variable fÃ¼r das letzte GFK-Matching-Ergebnis
        let lastGfkMatchingResult = null;

        /**
         * Berechnet das GFK-BedÃ¼rfnis-Matching zwischen den ausgewÃ¤hlten Profilen.
         * NEU v2.0: BerÃ¼cksichtigt Archetyp + Dominanz + Geschlecht + Orientierung + Status
         *
         * Verwendet BeduerfnisModifikatoren fÃ¼r dynamische Profil-Berechnung
         */
        function updateGfkFromArchetypes() {
            if (typeof GfkBeduerfnisse === 'undefined') {
                console.warn('GFK: GfkBeduerfnisse nicht geladen');
                return;
            }

            const ichArchetype = currentArchetype;
            const partnerArchetype = selectedPartner;

            if (!ichArchetype || !partnerArchetype) return;

            // Archetyp-IDs unverÃ¤ndert verwenden (duo_flex bleibt duo_flex)
            const ichNormalized = ichArchetype;
            const partnerNormalized = partnerArchetype;

            // PrÃ¼fen ob BeduerfnisModifikatoren verfÃ¼gbar ist
            if (typeof BeduerfnisModifikatoren !== 'undefined' && GfkBeduerfnisse.archetypProfile) {
                // NEU: Dynamische Berechnung mit allen Dimensionen
                const matching = calculateDynamicBeduerfnisMatch(ichNormalized, partnerNormalized);
                if (matching) {
                    lastGfkMatchingResult = matching;
                    console.log(`GFK BedÃ¼rfnis-Matching (dynamisch): ${ichNormalized} + ${partnerNormalized} â†’ Score=${matching.score}`);
                    console.log(`  Faktoren: Dominanz, Geschlecht, Orientierung berÃ¼cksichtigt`);

                    // GFK-Level setzen (basierend auf BedÃ¼rfnis-Ãœbereinstimmung)
                    personDimensions.ich.gfk = matching.level;
                    personDimensions.partner.gfk = matching.level;

                    // UI synchronisieren
                    syncGfkUI('ich');
                    syncGfkUI('partner');

                    // BedÃ¼rfnis-Details anzeigen
                    updateGfkBeduerfnisDisplay(matching);
                    return;
                }
            }

            // Fallback: Altes System (nur Archetyp)
            const matching = GfkBeduerfnisse.berechneMatching(ichNormalized, partnerNormalized);

            if (matching.fehler) {
                console.warn('GFK Matching Fehler:', matching.fehler);
                return;
            }

            lastGfkMatchingResult = matching;

            console.log(`GFK BedÃ¼rfnis-Matching (statisch): ${matching.archetyp1} + ${matching.archetyp2} â†’ Score=${matching.score} (${matching.level})`);

            // GFK-Level setzen (basierend auf BedÃ¼rfnis-Ãœbereinstimmung)
            personDimensions.ich.gfk = matching.level;
            personDimensions.partner.gfk = matching.level;

            // UI synchronisieren
            syncGfkUI('ich');
            syncGfkUI('partner');

            // BedÃ¼rfnis-Details anzeigen
            updateGfkBeduerfnisDisplay(matching);
        }

        /**
         * Berechnet dynamisches BedÃ¼rfnis-Matching unter BerÃ¼cksichtigung aller Dimensionen
         * @param {string} ichArchetyp - Normalisierter Archetyp-ID fÃ¼r "ich"
         * @param {string} partnerArchetyp - Normalisierter Archetyp-ID fÃ¼r "partner"
         * @returns {object|null} Matching-Ergebnis oder null bei Fehler
         */
        function calculateDynamicBeduerfnisMatch(ichArchetyp, partnerArchetyp) {
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEU: KONSISTENTE BERECHNUNG - Nutze individualisierte BedÃ¼rfnisse
            // Verwendet flatNeeds (Archetyp + D/G/O Modifikatoren) + lockedNeeds
            // Dies stellt sicher, dass der Score hier identisch ist mit dem
            // Score in der Tiagesynthese-Ansicht (EINE QUELLE DER WAHRHEIT)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof TiageState !== 'undefined' && typeof calculateNeedsMatchFromFlatNeeds === 'function') {
                console.log('[GFK] Verwende calculateNeedsMatchFromFlatNeeds fÃ¼r konsistente Berechnung (individualisierte Daten)');
                const result = calculateNeedsMatchFromFlatNeeds();

                if (result && result.score !== undefined) {

                    // Level basierend auf Score bestimmen
                    let level = 'niedrig';
                    if (result.score >= 70) level = 'hoch';
                    else if (result.score >= 40) level = 'mittel';

                    // Format fÃ¼r BedÃ¼rfnis-Labels
                    const formatLabel = (need) => {
                        if (typeof formatBeduerfnisLabel === 'function') {
                            return formatBeduerfnisLabel(need);
                        }
                        // Fallback fÃ¼r #B-IDs
                        if (need && need.startsWith('#B') && typeof GfkBeduerfnisse !== 'undefined' && GfkBeduerfnisse.getLabel) {
                            return GfkBeduerfnisse.getLabel(need);
                        }
                        return need.charAt(0).toUpperCase() + need.slice(1).replace(/_/g, ' ');
                    };

                    // Ergebnis im erwarteten Format
                    const allGemeinsam = (result.gemeinsam || []).map(b => ({
                        label: formatLabel(b.need),
                        id: b.need,
                        key: b.need,
                        wert1: b.wert1,
                        wert2: b.wert2
                    }));
                    const allUnterschiedlich = (result.unterschiedlich || []).map(b => ({
                        label: formatLabel(b.need),
                        id: b.need,
                        key: b.need,
                        wert1: b.wert1,
                        wert2: b.wert2
                    }));
                    const allKomplementaer = (result.komplementaer || []).map(b => ({
                        label: formatLabel(b.need),
                        id: b.need,
                        key: b.need,
                        wert1: b.wert1,
                        wert2: b.wert2
                    }));

                    const allGemeinsamUndKompatibel = [...allGemeinsam, ...allKomplementaer].sort((a, b) =>
                        ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2)
                    );

                    return {
                        score: result.score,
                        level: level,
                        archetyp1: ichArchetyp,
                        archetyp2: partnerArchetyp,
                        topUebereinstimmungen: allGemeinsamUndKompatibel.slice(0, 5),
                        topKonflikte: allUnterschiedlich.slice(0, 5),
                        komplementaer: allKomplementaer.slice(0, 5),
                        alleGemeinsam: allGemeinsamUndKompatibel,
                        alleUnterschiedlich: allUnterschiedlich,
                        alleKomplementaer: allKomplementaer,
                        // FIX: details-Eigenschaft fÃ¼r openNeedWithResonance() - ermÃ¶glicht Werte-Vergleich im Detail-Modal
                        details: {
                            uebereinstimmend: allGemeinsam,
                            komplementaer: allKomplementaer,
                            konflikt: allUnterschiedlich
                        },
                        source: 'calculateNeedsMatchFromFlatNeeds'  // Markierung: Individualisierte BedÃ¼rfnisse (flatNeeds + lockedNeeds)
                    };
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FALLBACK: Alter Weg mit BeduerfnisModifikatoren
            // Wird verwendet wenn profile.needs nicht verfÃ¼gbar
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // Basis-BedÃ¼rfnisse laden
            const ichBasis = GfkBeduerfnisse.archetypProfile[ichArchetyp];
            const partnerBasis = GfkBeduerfnisse.archetypProfile[partnerArchetyp];

            if (!ichBasis || !ichBasis.umfrageWerte || !partnerBasis || !partnerBasis.umfrageWerte) {
                console.warn('Archetyp-Basis nicht gefunden:', ichArchetyp, partnerArchetyp);
                return null;
            }

            // Helper: Geschlecht extrahieren (primary)
            const extractGeschlecht = (g) => {
                if (!g) return 'divers';
                if (typeof g === 'string') return g;
                if (typeof g === 'object') return g.primary || 'divers';
                return 'divers';
            };

            // Helper: Geschlecht Secondary extrahieren
            const extractGeschlechtSecondary = (g) => {
                if (!g || typeof g !== 'object') return null;
                return g.secondary || null;
            };

            // Helper: Dominanz extrahieren
            const extractDominanz = (d) => {
                if (!d) return 'ausgeglichen';
                if (typeof d === 'string') return d;
                if (typeof d === 'object') return d.primary || 'ausgeglichen';
                return 'ausgeglichen';
            };

            // Helper: Orientierung extrahieren
            const extractOrientierung = (o) => {
                if (!o) return 'heterosexuell';
                if (typeof o === 'string') return o;
                if (typeof o === 'object') return o.primary || 'heterosexuell';
                return 'heterosexuell';
            };

            // Dimensionen fÃ¼r "ich" sammeln
            const ichDims = personDimensions.ich;
            const ichParams = {
                basisBedÃ¼rfnisse: ichBasis.umfrageWerte,
                dominanz: extractDominanz(ichDims.dominanz),
                dominanzStatus: ichDims.dominanzStatus || 'gelebt',
                geschlechtPrimary: extractGeschlecht(ichDims.geschlecht),
                geschlechtPrimaryStatus: 'gelebt',
                geschlechtSecondary: extractGeschlechtSecondary(ichDims.geschlecht),
                geschlechtSecondaryStatus: 'gelebt',
                orientierung: extractOrientierung(ichDims.orientierung),
                orientierungStatus: ichDims.orientierungStatus || 'gelebt'
            };

            // Dimensionen fÃ¼r "partner" sammeln
            const partnerDims = personDimensions.partner;
            const partnerParams = {
                basisBedÃ¼rfnisse: partnerBasis.umfrageWerte,
                dominanz: extractDominanz(partnerDims.dominanz),
                dominanzStatus: partnerDims.dominanzStatus || 'gelebt',
                geschlechtPrimary: extractGeschlecht(partnerDims.geschlecht),
                geschlechtPrimaryStatus: 'gelebt',
                geschlechtSecondary: extractGeschlechtSecondary(partnerDims.geschlecht),
                geschlechtSecondaryStatus: 'gelebt',
                orientierung: extractOrientierung(partnerDims.orientierung),
                orientierungStatus: partnerDims.orientierungStatus || 'gelebt'
            };

            // Debug-Log
            console.log('BedÃ¼rfnis-Berechnung mit Dimensionen:', {
                ich: { archetyp: ichArchetyp, dominanz: ichParams.dominanz, geschlecht: ichParams.geschlechtPrimary, orientierung: ichParams.orientierung },
                partner: { archetyp: partnerArchetyp, dominanz: partnerParams.dominanz, geschlecht: partnerParams.geschlechtPrimary, orientierung: partnerParams.orientierung }
            });

            // VollstÃ¤ndige BedÃ¼rfnis-Profile berechnen
            const ichProfil = BeduerfnisModifikatoren.berechneVollstÃ¤ndigesBedÃ¼rfnisProfil(ichParams);
            const partnerProfil = BeduerfnisModifikatoren.berechneVollstÃ¤ndigesBedÃ¼rfnisProfil(partnerParams);

            // Ãœbereinstimmung berechnen
            const result = BeduerfnisModifikatoren.berechneÃœbereinstimmung(ichProfil, partnerProfil);

            // Level basierend auf Score bestimmen
            let level = 'niedrig';
            if (result.score >= 70) level = 'hoch';
            else if (result.score >= 40) level = 'mittel';

            // Ergebnis im erwarteten Format zurÃ¼ckgeben
            // Alle BedÃ¼rfnisse speichern (nicht limitiert)
            const allGemeinsam = result.gemeinsam.map(b => ({
                label: formatBeduerfnisLabel(b.bedÃ¼rfnis),
                id: b.bedÃ¼rfnis,
                key: b.bedÃ¼rfnis,
                wert1: b.wert1,
                wert2: b.wert2
            }));
            const allUnterschiedlich = result.unterschiedlich.map(b => ({
                label: formatBeduerfnisLabel(b.bedÃ¼rfnis),
                id: b.bedÃ¼rfnis,
                key: b.bedÃ¼rfnis,
                wert1: b.wert1,
                wert2: b.wert2
            }));
            const allKomplementaer = result.komplementaer.map(b => ({
                label: formatBeduerfnisLabel(b.bedÃ¼rfnis),
                id: b.bedÃ¼rfnis,
                key: b.bedÃ¼rfnis,
                wert1: b.wert1,
                wert2: b.wert2
            }));

            // Combine gemeinsam + komplementaer for shared/compatible needs
            const allGemeinsamUndKompatibel = [...allGemeinsam, ...allKomplementaer].sort((a, b) =>
                ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2)
            );

            return {
                score: result.score,
                level: level,
                archetyp1: ichArchetyp,
                archetyp2: partnerArchetyp,
                // Top 5 fÃ¼r kompakte Anzeige (Hauptseite) - now includes komplementaer
                topUebereinstimmungen: allGemeinsamUndKompatibel.slice(0, 5),
                topKonflikte: allUnterschiedlich.slice(0, 5),
                komplementaer: allKomplementaer.slice(0, 5),
                // Alle BedÃ¼rfnisse fÃ¼r vollstÃ¤ndige Anzeige (Modal)
                alleGemeinsam: allGemeinsamUndKompatibel,
                alleUnterschiedlich: allUnterschiedlich,
                alleKomplementaer: allKomplementaer,
                // FIX: details-Eigenschaft fÃ¼r openNeedWithResonance() - ermÃ¶glicht Werte-Vergleich im Detail-Modal
                details: {
                    uebereinstimmend: allGemeinsam,
                    komplementaer: allKomplementaer,
                    konflikt: allUnterschiedlich
                },
                // ZusÃ¤tzliche Details
                profile: {
                    ich: ichProfil,
                    partner: partnerProfil
                },
                dynamisch: true
            };
        }

        /**
         * Formatiert BedÃ¼rfnis-Keys in lesbare Labels
         * UnterstÃ¼tzt #B-IDs (z.B. '#B21') und String-Keys (z.B. 'liebe')
         */
        function formatBeduerfnisLabel(key) {
            if (!key) return '';

            // #B-ID: Nutze GfkBeduerfnisse.getLabel() fÃ¼r korrekte Umwandlung
            if (key.startsWith('#B')) {
                if (typeof GfkBeduerfnisse !== 'undefined' && GfkBeduerfnisse.getLabel) {
                    return GfkBeduerfnisse.getLabel(key);
                }
                // Fallback: Versuche Ã¼ber BeduerfnisIds den String-Key zu holen
                if (typeof BeduerfnisIds !== 'undefined' && BeduerfnisIds.toKey) {
                    const stringKey = BeduerfnisIds.toKey(key);
                    if (stringKey) {
                        return stringKey.replace(/_/g, ' ')
                            .replace(/ae/g, 'Ã¤')
                            .replace(/oe/g, 'Ã¶')
                            .replace(/ue/g, 'Ã¼')
                            .split(' ')
                            .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                            .join(' ');
                    }
                }
            }

            // String-Key: Underscore zu Leerzeichen, erster Buchstabe groÃŸ
            return key.replace(/_/g, ' ')
                      .replace(/ae/g, 'Ã¤')
                      .replace(/oe/g, 'Ã¶')
                      .replace(/ue/g, 'Ã¼')
                      .split(' ')
                      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
                      .join(' ');
        }

        /**
         * Zeigt die BedÃ¼rfnis-Matching-Details in der UI an
         */
        function updateGfkBeduerfnisDisplay(matching) {
            const container = document.getElementById('gfk-beduerfnis-display');
            const mobileContainer = document.getElementById('mobile-gfk-beduerfnis-display');

            // Mindestens ein Container muss existieren
            if (!container && !mobileContainer) return;

            // Container sichtbar machen
            if (container) container.style.display = 'block';
            if (mobileContainer) mobileContainer.style.display = 'block';

            // Score-Farbe basierend auf Level
            const scoreColor = matching.level === 'hoch' ? '#22c55e' :
                              matching.level === 'mittel' ? '#eab308' : '#ef4444';

            // HTML generieren
            const beduerfnisLabel = TiageI18n.t('synthesisSection.beduerfnisUebereinstimmung', 'BedÃ¼rfnis-Ãœbereinstimmung');
            let html = `
                <div class="gfk-matching-header" onclick="openNeedsFullModal()" style="cursor: pointer;" title="Klicken fÃ¼r vollstÃ¤ndige Liste">
                    <div class="gfk-score-display">
                        <span class="gfk-score" style="color: ${scoreColor}">${matching.score}</span>
                        <span onclick="event.stopPropagation(); openNeedsScoreExplanation();" style="cursor: help; margin-left: 6px; opacity: 0.6; font-size: 0.85em;" title="Wie wird dieser Wert berechnet?">â“˜</span>
                        <span class="gfk-level-label">${beduerfnisLabel}</span>
                    </div>
                </div>
            `;

            // Top Ãœbereinstimmungen (now includes gemeinsam + komplementaer)
            if (matching.topUebereinstimmungen && matching.topUebereinstimmungen.length > 0) {
                const gemeinsameLabel = TiageI18n.t('synthesisSection.gemeinsameBeduerfnisse', 'Gemeinsame & Kompatible BedÃ¼rfnisse');
                html += `
                    <div class="gfk-section gfk-matches">
                        <div class="gfk-section-title" style="color: #22c55e;">${TiageI18n.t('needs.sharedTitle', 'GEMEINSAME BEDÃœRFNISSE')}</div>
                        <div class="gfk-tags">
                            ${matching.topUebereinstimmungen.map(b => {
                                // b.id ist jetzt bereits #B-ID (z.B. "#B34"), b.label ist der Display-Name
                                const bidDisplay = b.id && b.id.startsWith('#B') ? `<span style="opacity: 0.6; font-size: 0.85em; margin-right: 4px;">${b.id}</span>` : '';
                                return `<span class="gfk-tag gfk-tag-match gfk-tag-clickable" onclick="openNeedWithResonance('${b.id}')" title="Klicken fÃ¼r Definition">${bidDisplay}${b.label}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Konflikte
            if (matching.topKonflikte && matching.topKonflikte.length > 0) {
                const unterschiedlicheLabel = TiageI18n.t('synthesisSection.unterschiedlichePrioritaeten', 'Unterschiedliche PrioritÃ¤ten');
                html += `
                    <div class="gfk-section gfk-conflicts">
                        <div class="gfk-section-title" style="color: #ef4444;">${TiageI18n.t('needs.differentTitle', 'UNTERSCHIEDLICHE PRIORITÃ„TEN')}</div>
                        <div class="gfk-tags">
                            ${matching.topKonflikte.map(b => {
                                // b.id ist jetzt bereits #B-ID (z.B. "#B34"), b.label ist der Display-Name
                                const bidDisplay = b.id && b.id.startsWith('#B') ? `<span style="opacity: 0.6; font-size: 0.85em; margin-right: 4px;">${b.id}</span>` : '';
                                return `<span class="gfk-tag gfk-tag-conflict gfk-tag-clickable" onclick="openNeedWithResonance('${b.id}')" title="Klicken fÃ¼r Definition | ${matching.archetyp1}: ${b.wert1} | ${matching.archetyp2}: ${b.wert2}">${bidDisplay}${b.label}</span>`;
                            }).join('')}
                        </div>
                    </div>
                `;
            }

            // Desktop und Mobile Container aktualisieren
            if (container) container.innerHTML = html;
            if (mobileContainer) mobileContainer.innerHTML = html;
        }

        /**
         * Gibt die Top-BedÃ¼rfnisse fÃ¼r einen Archetyp zurÃ¼ck
         */
        function getArchetypBeduerfnisse(archetyp) {
            if (typeof GfkBeduerfnisse === 'undefined') return [];
            // Archetyp-SchlÃ¼ssel unverÃ¤ndert verwenden (duo_flex bleibt duo_flex)
            return GfkBeduerfnisse.getTopBeduerfnisse(archetyp, 5);
        }

        // ========================================
        // Desktop Selection Info Message
        // ========================================
        // Helper function to get geschlecht value from both string and object formats
        function getGeschlechtValue(g) {
            if (!g) return null;
            if (typeof g === 'string') return g;
            if (typeof g === 'object' && g.primary) return g.primary;
            return null;
        }

        function updateSelectionInfoMessage() {
            const infoElement = document.getElementById('desktopSelectionInfo');
            if (!infoElement) return;

            const missing = [];

            // Check ICH
            const ichMissing = [];
            if (!getGeschlechtValue(personDimensions.ich.geschlecht)) ichMissing.push('Geschlecht');
            if (!hasAnyDominanzSelected('ich')) ichMissing.push('Dominanz');
            if (!hasAnyOrientierungSelected('ich')) ichMissing.push('Orientierung');
            if (ichMissing.length > 0) {
                missing.push('DU: ' + ichMissing.join(', '));
            }

            // Check Partner
            const partnerMissing = [];
            if (!getGeschlechtValue(personDimensions.partner.geschlecht)) partnerMissing.push('Geschlecht');
            if (!hasAnyDominanzSelected('partner')) partnerMissing.push('Dominanz');
            if (!hasAnyOrientierungSelected('partner')) partnerMissing.push('Orientierung');
            if (partnerMissing.length > 0) {
                missing.push('PARTNER: ' + partnerMissing.join(', '));
            }

            // Update display
            if (missing.length > 0) {
                infoElement.textContent = 'Fehlende Auswahl - ' + missing.join(' | ');
                infoElement.classList.add('visible');
            } else {
                infoElement.textContent = '';
                infoElement.classList.remove('visible');
            }
        }

        function handleDimensionChange(person, dimension, value, element) {
            // Update state
            personDimensions[person][dimension] = value;

            // Remove needs-selection class from the parent group
            if (element) {
                const dimensionGroup = element.closest('.dimension-group, .dimension-status-group');
                if (dimensionGroup) {
                    dimensionGroup.classList.remove('needs-selection');
                }
            }

            // Visual feedback - highlight animation
            if (element) {
                const label = element.nextElementSibling;
                if (label) {
                    label.classList.add('highlight-change');
                    setTimeout(() => label.classList.remove('highlight-change'), 300);
                }
            }

            // Update overview box
            updateAnalysisOverview();

            // Re-run compatibility checks when dimensions change
            if (data) {
                updatePartnerView();
            }

            // WICHTIG: Speichere Ã„nderungen sofort, um Datenverlust zu verhindern
            // (Fix fÃ¼r GOD-Einstellungen die bei Navigation verloren gingen)
            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }
        }

        function getGeschlechtKurz(geschlecht) {
            if (!geschlecht) return '?';

            // Neues Format: { primary, secondary }
            let primary = geschlecht;
            let secondary = null;
            if (typeof geschlecht === 'object') {
                primary = geschlecht.primary;
                secondary = geschlecht.secondary;
            }

            if (!primary) return '?';

            // Nutze TiageConfig wenn verfÃ¼gbar
            const getShort = (g) => {
                if (typeof TiageConfig !== 'undefined' && TiageConfig.GESCHLECHT_SHORT) {
                    return TiageConfig.GESCHLECHT_SHORT[g] || g;
                }
                // Fallback-Map
                const map = {
                    'cis_mann': 'CM',
                    'cis_frau': 'CF',
                    'trans_mann': 'TM',
                    'trans_frau': 'TF',
                    'nonbinaer': 'NB',
                    'genderfluid': 'GF',
                    'agender': 'AG',
                    'intersex': 'IS',
                    'divers': 'DI',
                    // Legacy-Support
                    'mÃ¤nnlich': 'M',
                    'weiblich': 'W',
                    'non-binÃ¤r': 'NB'
                };
                return map[g] || g;
            };

            // PrimÃ¤r + optional SekundÃ¤r anzeigen
            let result = getShort(primary);
            if (secondary) {
                result += '/' + getShort(secondary);
            }
            return result;
        }

        function getGeschlechtVoll(geschlecht) {
            if (!geschlecht) return null;

            let primary = geschlecht;
            let secondary = null;
            if (typeof geschlecht === 'object') {
                primary = geschlecht.primary;
                secondary = geschlecht.secondary;
            }

            if (!primary) return null;

            // Nutze i18n wenn verfÃ¼gbar, sonst Fallback-Map
            const getName = (g) => {
                if (typeof TiageI18n !== 'undefined') {
                    return TiageI18n.t(`geschlecht.types.${g}`, g);
                }
                // Fallback-Map
                const map = {
                    'cis_mann': 'Cis Mann',
                    'cis_frau': 'Cis Frau',
                    'trans_mann': 'Trans Mann',
                    'trans_frau': 'Trans Frau',
                    'nonbinaer': 'NonbinÃ¤r',
                    'genderfluid': 'Genderfluid',
                    'agender': 'Agender',
                    'intersex': 'Intersex',
                    'divers': 'Divers',
                    'mÃ¤nnlich': 'Mann',
                    'weiblich': 'Frau',
                    'non-binÃ¤r': 'NonbinÃ¤r'
                };
                return map[g] || g;
            };

            let result = getName(primary);
            if (secondary) {
                result += ' (' + getName(secondary) + ')';
            }
            return result;
        }

        function getGeschlechtCategory(geschlecht) {
            // Extract primary gender from object format { primary: 'cis_mann', secondary: null }
            if (geschlecht && typeof geschlecht === 'object' && 'primary' in geschlecht) {
                geschlecht = geschlecht.primary;
            }
            // Gibt die Kategorie fÃ¼r Orientierungslogik zurÃ¼ck
            if (typeof TiageConfig !== 'undefined' && TiageConfig.GESCHLECHT_CATEGORY) {
                return TiageConfig.GESCHLECHT_CATEGORY[geschlecht] || 'andere';
            }
            const map = {
                'cis_mann': 'maennlich',
                'cis_frau': 'weiblich',
                'trans_mann': 'maennlich',
                'trans_frau': 'weiblich',
                'nonbinaer': 'nonbinaer',
                'genderfluid': 'fluid',
                'agender': 'agender',
                // Legacy-Support
                'mÃ¤nnlich': 'maennlich',
                'weiblich': 'weiblich',
                'non-binÃ¤r': 'nonbinaer',
                // Einfache Geschlechter (fÃ¼r R4 Hybrid)
                'mann': 'maennlich',
                'frau': 'weiblich',
                'inter': 'nonbinaer',
                'fluid': 'fluid'
            };
            return map[geschlecht] || 'andere';
        }

        function getDominanzKurz(dominanz) {
            // Handle multi-select object
            if (dominanz && typeof dominanz === 'object') {
                const parts = [];
                const map = { 'dominant': 'dom', 'submissiv': 'sub', 'switch': 'sw', 'ausgeglichen': 'ausg' };

                // New Primary/Secondary structure
                if ('primary' in dominanz) {
                    if (dominanz.primary) {
                        parts.push(map[dominanz.primary] || dominanz.primary);
                    }
                    if (dominanz.secondary) {
                        parts.push((map[dominanz.secondary] || dominanz.secondary) + '?');
                    }
                    return parts.length > 0 ? parts.join('+') : '?';
                }

                // Old format: { dominant: 'gelebt', submissiv: 'interessiert' }
                for (const [type, status] of Object.entries(dominanz)) {
                    if (status) {
                        let kurz = map[type] || type;
                        if (status === 'interessiert') kurz += '?';
                        parts.push(kurz);
                    }
                }

                return parts.length > 0 ? parts.join('+') : '?';
            }

            // Old single-value format (backwards compatibility)
            if (!dominanz) return '?';
            const map = {
                'dominant': 'dom',
                'submissiv': 'sub',
                'switch': 'sw',
                'ausgeglichen': 'ausg'
            };
            return map[dominanz] || dominanz;
        }

        function getOrientierungKurz(orientierung, status) {
            // Handle multi-select orientierung object
            if (orientierung && typeof orientierung === 'object') {
                const map = {
                    'heterosexuell': 'het',
                    'homosexuell': 'hom',
                    'bisexuell': 'bi'
                };
                const parts = [];
                // New Primary/Secondary structure
                if (orientierung.primary) {
                    parts.push(map[orientierung.primary] || orientierung.primary);
                }
                if (orientierung.secondary) {
                    parts.push(map[orientierung.secondary] || orientierung.secondary);
                }
                return parts.length > 0 ? parts.join('/') : '?';
            }

            // Backwards compatibility for old single-value format
            if (!orientierung) return '?';
            const map = {
                'heterosexuell': 'hetero',
                'homosexuell': 'homo',
                'bisexuell': 'bi'
            };
            let kurz = map[orientierung] || orientierung;
            if (status === 'interessiert') {
                kurz += '(?)';
            }
            return kurz;
        }

        function updateAnalysisOverview() {
            const ichType = data?.archetypes[currentArchetype]?.name || currentArchetype;
            const partnerType = data?.archetypes[selectedPartner]?.name || selectedPartner;

            const ichDims = personDimensions.ich;
            const partnerDims = personDimensions.partner;

            // Voller Geschlechtsname mit sekundÃ¤rem in Klammern
            const ichGeschlecht = getGeschlechtVoll(ichDims.geschlecht);
            const partnerGeschlecht = getGeschlechtVoll(partnerDims.geschlecht);

            const ichInfo = `(${getDominanzKurz(ichDims.dominanz)}, ${getOrientierungKurz(ichDims.orientierung, ichDims.orientierungStatus)})`;
            const partnerInfo = `(${getDominanzKurz(partnerDims.dominanz)}, ${getOrientierungKurz(partnerDims.orientierung, partnerDims.orientierungStatus)})`;

            const content = document.getElementById('analysisOverviewContent');
            if (content) {
                // Nutze i18n fÃ¼r "Du:" / "You:"
                const youALabel = typeof TiageI18n !== 'undefined' ? TiageI18n.t('analysisOverview.youA', 'Du:') : 'Du:';
                const ichGeschlechtHtml = ichGeschlecht ? `<span class="geschlecht-info">${youALabel} ${ichGeschlecht}</span>` : '';
                const partnerGeschlechtHtml = partnerGeschlecht ? `<span class="geschlecht-info">${partnerGeschlecht}</span>` : '';

                content.innerHTML = `
                    <span class="type-name">${ichType}</span> ${ichGeschlechtHtml} <span class="dim-info">${ichInfo}</span>
                    <span> Ã— </span>
                    <span class="type-name">${partnerType}</span> ${partnerGeschlechtHtml} <span class="dim-info">${partnerInfo}</span>
                `;
            }
        }

        // Make function globally available for i18n updates
        window.updateAnalysisOverview = updateAnalysisOverview;

        function initDimensionListeners() {
            // ICH dimensions
            document.querySelectorAll('input[name="ich-geschlecht"]').forEach(radio => {
                radio.addEventListener('change', (e) => handleDimensionChange('ich', 'geschlecht', e.target.value, e.target));
            });
            document.querySelectorAll('input[name="ich-dominanz"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const dimensionGroup = e.target.closest('.dimension-group');
                    if (dimensionGroup) dimensionGroup.classList.remove('needs-selection');
                    handleDominanzClick('ich', e.target.value);
                });
            });
            document.querySelectorAll('input[name="ich-dominanz-status"]').forEach(radio => {
                radio.addEventListener('change', (e) => handleDimensionChange('ich', 'dominanzStatus', e.target.value, e.target));
            });

            // PARTNER dimensions
            document.querySelectorAll('input[name="partner-geschlecht"]').forEach(radio => {
                radio.addEventListener('change', (e) => handleDimensionChange('partner', 'geschlecht', e.target.value, e.target));
            });
            document.querySelectorAll('input[name="partner-dominanz"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    const dimensionGroup = e.target.closest('.dimension-group');
                    if (dimensionGroup) dimensionGroup.classList.remove('needs-selection');
                    handleDominanzClick('partner', e.target.value);
                });
            });
            document.querySelectorAll('input[name="partner-dominanz-status"]').forEach(radio => {
                radio.addEventListener('change', (e) => handleDimensionChange('partner', 'dominanzStatus', e.target.value, e.target));
            });
        }

        // ========================================
        // Pathos/Logos Check System
        // ========================================
        // NOTE: Logic extracted to /js/compatibility/ modules
        // These wrapper functions maintain backward compatibility

        /**
         * SSOT v3.7: Holt den Konfidenz-Multiplikator fÃ¼r physische KompatibilitÃ¤t
         *
         * PrimÃ¤re Matches (confidence: 'hoch') werden bevorzugt gegenÃ¼ber sekundÃ¤ren (confidence: 'mittel').
         * Dies stellt sicher, dass ein hetero Mann primÃ¤r Frauen sieht, nicht MÃ¤nner Ã¼ber seine sekundÃ¤re Bi-Orientierung.
         *
         * @param {string} confidence - 'hoch', 'mittel', oder 'niedrig'
         * @returns {number} Multiplikator (1.0 fÃ¼r hoch, 0.85 fÃ¼r mittel, 0.70 fÃ¼r niedrig)
         */
        function getConfidenceMultiplier(confidence) {
            // SSOT: TiageSynthesis.Constants.PHYSICAL_COMPATIBILITY.CONFIDENCE_MULTIPLIER
            if (typeof TiageSynthesis !== 'undefined' &&
                TiageSynthesis.Constants &&
                TiageSynthesis.Constants.PHYSICAL_COMPATIBILITY &&
                TiageSynthesis.Constants.PHYSICAL_COMPATIBILITY.CONFIDENCE_MULTIPLIER) {
                return TiageSynthesis.Constants.PHYSICAL_COMPATIBILITY.CONFIDENCE_MULTIPLIER[confidence] || 1.0;
            }
            // Fallback wenn SSOT nicht verfÃ¼gbar
            const defaults = { 'hoch': 1.0, 'mittel': 0.85, 'niedrig': 0.70 };
            return defaults[confidence] || 1.0;
        }

        function checkPhysicalCompatibility(person1, person2) {
            // Delegate to extracted module
            if (typeof TiageCompatibility !== 'undefined' && TiageCompatibility.Physical) {
                return TiageCompatibility.Physical.check(person1, person2);
            }
            // Fallback: inline implementation for backwards compatibility
            // Extract effective gender identity (handles Trans transformation)
            const extractEffectiveGender = (geschlecht) => {
                if (!geschlecht) return null;
                if (typeof geschlecht === 'object' && 'primary' in geschlecht) {
                    const primary = geschlecht.primary;
                    const secondary = geschlecht.secondary;
                    if (secondary) {
                        if (secondary === 'cis') return primary;
                        if (secondary === 'trans') {
                            if (primary === 'mann') return 'frau';
                            if (primary === 'frau') return 'mann';
                            return primary;
                        }
                        if (['nonbinaer', 'fluid', 'suchend'].includes(secondary)) return secondary;
                        return secondary;
                    }
                    return primary || null;
                }
                if (typeof geschlecht === 'string') return geschlecht;
                return null;
            };

            let g1 = extractEffectiveGender(person1.geschlecht);
            let g2 = extractEffectiveGender(person2.geschlecht);

            // Get orientierung as multi-select object
            const ori1 = person1.orientierung;
            const ori2 = person2.orientierung;

            // Collect all missing items
            const missingItems = [];

            if (!g1) missingItems.push('Ich: Geschlecht');
            if (!g2) missingItems.push('Partner: Geschlecht');

            // Handle multi-select orientierung
            const oriList1 = [];
            const oriList2 = [];

            // v4.0: Array-Format
            if (Array.isArray(ori1)) {
                ori1.forEach(o => oriList1.push({ type: o, status: 'gelebt' }));
            } else if (ori1 && typeof ori1 === 'object') {
                // New format: { primary: 'homosexuell', secondary: 'heterosexuell' }
                if ('primary' in ori1) {
                    if (ori1.primary) oriList1.push({ type: ori1.primary, status: 'gelebt' });
                    if (ori1.secondary) oriList1.push({ type: ori1.secondary, status: 'interessiert' });
                } else {
                    // Old format: { heterosexuell: 'gelebt', homosexuell: 'interessiert' }
                    if (ori1.heterosexuell) oriList1.push({ type: 'heterosexuell', status: ori1.heterosexuell });
                    if (ori1.homosexuell) oriList1.push({ type: 'homosexuell', status: ori1.homosexuell });
                    if (ori1.bisexuell) oriList1.push({ type: 'bisexuell', status: ori1.bisexuell });
                }
            } else if (ori1 && typeof ori1 === 'string') {
                // Backwards compatibility for old single-value format
                oriList1.push({ type: ori1, status: person1.orientierungStatus || 'gelebt' });
            }

            // v4.0: Array-Format
            if (Array.isArray(ori2)) {
                ori2.forEach(o => oriList2.push({ type: o, status: 'gelebt' }));
            } else if (ori2 && typeof ori2 === 'object') {
                // New format: { primary: 'homosexuell', secondary: 'heterosexuell' }
                if ('primary' in ori2) {
                    if (ori2.primary) oriList2.push({ type: ori2.primary, status: 'gelebt' });
                    if (ori2.secondary) oriList2.push({ type: ori2.secondary, status: 'interessiert' });
                } else {
                    // Old format: { heterosexuell: 'gelebt', homosexuell: 'interessiert' }
                    if (ori2.heterosexuell) oriList2.push({ type: 'heterosexuell', status: ori2.heterosexuell });
                    if (ori2.homosexuell) oriList2.push({ type: 'homosexuell', status: ori2.homosexuell });
                    if (ori2.bisexuell) oriList2.push({ type: 'bisexuell', status: ori2.bisexuell });
                }
            } else if (ori2 && typeof ori2 === 'string') {
                // Backwards compatibility for old single-value format
                oriList2.push({ type: ori2, status: person2.orientierungStatus || 'gelebt' });
            }

            // Check if orientierung is missing
            if (oriList1.length === 0) missingItems.push('Ich: Orientierung');
            if (oriList2.length === 0) missingItems.push('Partner: Orientierung');

            // Return incomplete if any items are missing
            if (missingItems.length > 0) {
                return {
                    result: 'unvollstÃ¤ndig',
                    reason: 'Dimensionen unvollstÃ¤ndig',
                    explanation: 'Es fehlt noch: ' + missingItems.join(', '),
                    missingItems: missingItems
                };
            }

            // Check all combinations
            let hasPossible = false;
            let hasUnsicher = false;
            let hasInteressiert = false;

            for (const o1 of oriList1) {
                for (const o2 of oriList2) {
                    const result = checkSingleOrientationPair(o1.type, o1.status, o2.type, o2.status, g1, g2);

                    if (result === 'mÃ¶glich') {
                        hasPossible = true;
                    } else if (result === 'unsicher') {
                        hasUnsicher = true;
                    }

                    if (o1.status === 'interessiert' || o2.status === 'interessiert') {
                        hasInteressiert = true;
                    }
                }
            }

            // Return best result
            if (hasPossible && !hasInteressiert) {
                return { result: 'mÃ¶glich', confidence: 'hoch' };
            }

            if (hasPossible && hasInteressiert) {
                return {
                    result: 'unsicher',
                    confidence: 'mittel',
                    explanation: 'Anziehung mÃ¶glich, aber mindestens eine Person ist in der Explorationsphase.',
                    note: 'Status "Interessiert" bedeutet Exploration'
                };
            }

            if (hasUnsicher) {
                return {
                    result: 'unsicher',
                    confidence: 'niedrig',
                    explanation: 'Anziehung ist theoretisch mÃ¶glich, aber unsicher.',
                    note: 'Exploration-Phase'
                };
            }

            return {
                result: 'unmÃ¶glich',
                reason: 'Inkompatible Orientierungen',
                explanation: 'Die sexuellen Orientierungen schlieÃŸen gegenseitige Anziehung aus.'
            };
        }

        // Helper: Check if gender is male category (includes cis and trans)
        function isMaleGender(gender) {
            if (!gender) return false;
            const g = gender.toLowerCase();
            return g === 'mÃ¤nnlich' || g === 'cis_mann' || g === 'trans_mann' ||
                   g === 'mann' || g === 'male' || g === 'm';
        }

        // Helper: Check if gender is female category (includes cis and trans)
        function isFemaleGender(gender) {
            if (!gender) return false;
            const g = gender.toLowerCase();
            return g === 'weiblich' || g === 'cis_frau' || g === 'trans_frau' ||
                   g === 'frau' || g === 'female' || g === 'w' || g === 'f';
        }

        // Helper: Check if two genders are in the same category
        function isSameGenderCategory(g1, g2) {
            if (isMaleGender(g1) && isMaleGender(g2)) return true;
            if (isFemaleGender(g1) && isFemaleGender(g2)) return true;
            // Non-binary/other: compare directly
            return g1 === g2;
        }

        // Helper: Check if two genders are in different binary categories (male vs female)
        function isDifferentBinaryGender(g1, g2) {
            return (isMaleGender(g1) && isFemaleGender(g2)) ||
                   (isFemaleGender(g1) && isMaleGender(g2));
        }

        // Helper: Check single pair of orientations
        function checkSingleOrientationPair(type1, status1, type2, status2, g1, g2) {
            const isUnsicher = status1 === 'interessiert' || status2 === 'interessiert';

            // Helper: Can this orientation be attracted to the other person's gender?
            const canBeAttractedTo = (orientation, myGender, theirGender) => {
                if (orientation === 'bisexuell') return true; // Bi can be attracted to any gender
                if (orientation === 'heterosexuell') return isDifferentBinaryGender(myGender, theirGender);
                if (orientation === 'homosexuell') return isSameGenderCategory(myGender, theirGender);
                return false;
            };

            // BOTH persons must be able to be attracted to each other's gender
            const person1CanBeAttracted = canBeAttractedTo(type1, g1, g2);
            const person2CanBeAttracted = canBeAttractedTo(type2, g2, g1);

            if (person1CanBeAttracted && person2CanBeAttracted) {
                return isUnsicher ? 'unsicher' : 'mÃ¶glich';
            }

            // If only one person is exploring, there might be potential
            if (isUnsicher && (person1CanBeAttracted || person2CanBeAttracted)) {
                return 'unsicher';
            }

            return 'unmÃ¶glich';
        }

        function calculatePhilosophyCompatibility(type1, type2) {
            // Delegate to extracted module
            if (typeof TiageCompatibility !== 'undefined' && TiageCompatibility.Philosophy) {
                return TiageCompatibility.Philosophy.calculate(type1, type2, data);
            }
            // Fallback: inline implementation for backwards compatibility
            // Get the philosophy score (Category A) from the matrix
            const key = `${type1}_${type2}`;
            const interaction = data?.interactions[key];

            if (interaction && interaction.scores && interaction.scores.A) {
                return {
                    score: interaction.scores.A.value,
                    note: interaction.scores.A.note
                };
            }

            // Fallback if not found
            return { score: 50, note: 'Keine spezifischen Daten verfÃ¼gbar' };
        }

        // Helper function to format orientierung object to string
        function formatOrientierung(orientierung) {
            if (!orientierung) return '?';
            if (typeof orientierung === 'object') {
                const parts = [];
                if (orientierung.primary) {
                    parts.push(orientierung.primary + ' (P)');
                }
                if (orientierung.secondary) {
                    parts.push(orientierung.secondary + ' (S)');
                }
                return parts.length > 0 ? parts.join(', ') : '?';
            }
            // Backwards compatibility for old single-value format
            return orientierung;
        }

        function formatPersonSummary(person) {
            // Extract primary gender from object format { primary: 'cis_mann', secondary: null }
            let geschlecht = person.geschlecht || '?';
            if (geschlecht && typeof geschlecht === 'object' && 'primary' in geschlecht) {
                geschlecht = geschlecht.primary || '?';
            }

            // Handle Primary/Secondary orientierung structure
            const orientierungStr = formatOrientierung(person.orientierung);

            return `${geschlecht}, ${orientierungStr}`;
        }

        function runCompatibilityChecks() {
            const person1 = {
                archetyp: currentArchetype,
                ...personDimensions.ich
            };
            const person2 = {
                archetyp: selectedPartner,
                ...personDimensions.partner
            };

            // Reset all warnings
            document.getElementById('pathosBlocker').classList.remove('active');
            document.getElementById('logosWarning').classList.remove('active');
            document.getElementById('pathosUncertain').classList.remove('active');
            document.getElementById('doubleWarning').classList.remove('active');
            document.getElementById('compatibilityContent').style.display = 'block';

            // 1. PATHOS CHECK
            const pathosCheck = checkPhysicalCompatibility(person1, person2);

            if (pathosCheck.result === 'unvollstÃ¤ndig') {
                // Show Pathos Uncertain with incomplete message
                document.getElementById('pathosUncertain').classList.add('active');
                document.getElementById('pathosUncertainText').textContent =
                    pathosCheck.explanation;
                // Continue showing compatibility content since it's just incomplete
            }

            if (pathosCheck.result === 'unmÃ¶glich') {
                // SANFTER HINWEIS statt K.O.-Blocker
                // Zeige Warnung, aber blockiere nicht mehr
                document.getElementById('pathosBlocker').classList.add('active');
                // Content wird NICHT mehr versteckt - zeige den (niedrigen) Score
                // document.getElementById('compatibilityContent').style.display = 'none';

                document.getElementById('pathosBlockerReason').textContent =
                    `Hinweis: ${pathosCheck.reason} â€“ Resonanz ist sehr niedrig, aber nicht unmÃ¶glich.`;
                document.getElementById('pathosBlockerPerson1').textContent =
                    formatPersonSummary(person1);
                document.getElementById('pathosBlockerPerson2').textContent =
                    formatPersonSummary(person2);

                // Kein return mehr - weitermachen mit niedriger Resonanz!
                // return { blocked: true, reason: 'pathos' };
            }

            // 2. LOGOS CHECK
            const logosCheck = calculatePhilosophyCompatibility(person1.archetyp, person2.archetyp);
            const hasLogosWarning = logosCheck.score < 50;
            const hasPathosUncertain = pathosCheck.result === 'unsicher';

            // Handle different warning combinations
            if (hasPathosUncertain && hasLogosWarning) {
                // Double Warning
                document.getElementById('doubleWarning').classList.add('active');
                document.getElementById('doubleWarningPathos').textContent =
                    `${formatOrientierung(person2.orientierung)} (${person2.orientierungStatus}) â†’ Exploration-Phase`;
                document.getElementById('doubleWarningLogos').textContent =
                    `Beziehungsphilosophie: ${logosCheck.score} â†’ ${data?.archetypes[person1.archetyp]?.name || person1.archetyp} vs. ${data?.archetypes[person2.archetyp]?.name || person2.archetyp}`;
            } else {
                // Single warnings
                if (hasLogosWarning) {
                    document.getElementById('logosWarning').classList.add('active');
                    const warningTitle = logosCheck.score < 30
                        ? 'Verstandsebene-Warnung: Fundamentale philosophische Unterschiede'
                        : 'Verstandsebene-Hinweis: Unterschiedliche philosophische AnsÃ¤tze';
                    document.getElementById('logosWarningTitle').textContent = warningTitle;
                    document.getElementById('logosWarningSubtitle').textContent =
                        `Beziehungsphilosophie: ${logosCheck.score}`;
                    document.getElementById('logosWarningScore').textContent = `${logosCheck.score}`;
                    document.getElementById('logosWarningText').textContent = logosCheck.score < 30
                        ? 'Eure GrundÃ¼berzeugungen Ã¼ber Beziehungen sind sehr unterschiedlich. Dies erfordert intensive Kommunikation und Kompromissbereitschaft.'
                        : 'Ihr habt verschiedene Vorstellungen von Beziehungen. Offene Kommunikation ist wichtig.';
                }

                if (hasPathosUncertain) {
                    document.getElementById('pathosUncertain').classList.add('active');
                    document.getElementById('pathosUncertainText').textContent =
                        `Mindestens eine Person ist in der Explorationsphase (Status: "Interessiert"). Die tatsÃ¤chliche kÃ¶rperliche Anziehung ist noch unklar.`;
                }
            }

            // 3. DISPLAY DIMENSION MODIFIERS
            const modifierSummaries = getModifierSummary(person1, person2);
            const modifierSummaryEl = document.getElementById('modifierSummary');
            const modifierContentEl = document.getElementById('modifierSummaryContent');

            if (modifierSummaries.length > 0) {
                modifierSummaryEl.classList.add('active');
                modifierContentEl.innerHTML = modifierSummaries.map(mod => {
                    const sign = mod.modifier > 0 ? '+' : '';
                    const modClass = mod.modifier > 0 ? 'positive' : (mod.modifier < 0 ? 'negative' : 'neutral');
                    const icon = mod.modifier > 0 ? 'â†‘' : (mod.modifier < 0 ? 'â†“' : 'â†’');
                    return `
                        <div class="modifier-summary-item">
                            <span class="modifier-icon">${icon}</span>
                            <span>${mod.description}</span>
                            <span class="modifier-badge ${modClass}">${sign}${mod.modifier}%</span>
                        </div>
                    `;
                }).join('');
            } else {
                modifierSummaryEl.classList.remove('active');
            }

            return {
                blocked: false,
                pathosCheck,
                logosCheck,
                warnings: { hasLogosWarning, hasPathosUncertain },
                modifiers: modifierSummaries
            };
        }

        function toggleLogosWarning() {
            const warning = document.getElementById('logosWarning');
            warning.classList.toggle('expanded');
        }

        function showPathosLogosInfo() {
            // Show info modal about Pathos vs Logos
            const title = 'Pathos vs. Logos';
            const content = `
                <div style="line-height: 1.6;">
                    <h4 style="color: var(--primary); margin-bottom: 10px;">GEFÃœHLSEBENE (Emotion/KÃ¶rper)</h4>
                    <ul style="margin-bottom: 15px; padding-left: 20px;">
                        <li>KÃ¶rperliche und emotionale Anziehung</li>
                        <li>Sexuelle Orientierung</li>
                        <li>Nicht durch Lernen oder Kommunikation verÃ¤nderbar</li>
                        <li><strong>Ohne GefÃ¼hlsebene:</strong> Keine romantische Beziehung mÃ¶glich</li>
                    </ul>

                    <h4 style="color: var(--warning); margin-bottom: 10px;">VERSTANDSEBENE (Philosophie/Ãœberzeugungen)</h4>
                    <ul style="margin-bottom: 15px; padding-left: 20px;">
                        <li>Beziehungsphilosophie und rationale Ãœberzeugungen</li>
                        <li>Ãœberzeugungen und Werte</li>
                        <li>Kann durch Kommunikation und Lernen verÃ¤ndert werden</li>
                        <li><strong>Ohne Verstandsebene:</strong> Schwierige, aber mÃ¶gliche Beziehung</li>
                    </ul>

                    <p style="font-style: italic; color: var(--text-muted);">
                        "Die GefÃ¼hlsebene ist das Fundament - ohne kÃ¶rperliche Anziehung kann keine romantische Beziehung entstehen. Die Verstandsebene ist das Dach - es schÃ¼tzt und strukturiert, kann aber umgebaut werden."
                    </p>
                </div>
            `;

            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalBody').innerHTML = content;
            document.getElementById('categoryModal').classList.add('active');
        }

        // ========================================
        // Dimensions Modifiers System
        // ========================================

        // Tag dimension relevance mapping
        const tagDimensionRelevance = {
            // KATEGORIE A: Beziehungsphilosophie - KEINE Dimensions-EinflÃ¼sse!
            "exklusivitaets-erwartung": [],
            "offenheit-fuer-alternative-modelle": [],
            "beziehung-als-lebensinhalt": [],
            "primaerbeziehung-konzept": [],
            "commitment-tiefe": [],

            // KATEGORIE B: Werte-Alignment
            "fuehrung-und-initiative": ["dominanz"],
            "macht-balance": ["dominanz"],
            "emotionale-reziprozitaet": [],
            "eifersucht-umgang": [],
            "konfliktloesung": ["dominanz"],
            "emotionale-tiefe": [],

            // KATEGORIE C: NÃ¤he-Distanz
            "entscheidungsfindung": ["dominanz"],
            "alltags-organisation": ["dominanz"],
            "autonomie-vs-gemeinsame-zeit": [],
            "finanzielle-organisation": ["dominanz"],
            "wohnform-flexibilitaet": [],
            "zeitmanagement": ["dominanz"],

            // KATEGORIE D: Autonomie
            "koerperliche-anziehung": ["geschlecht", "orientierung", "orientierungStatus"],
            "sexuelle-dominanz-dynamik": ["dominanz"],
            "experimentierfreude": ["orientierungStatus"],
            "intimitaets-frequenz": [],
            "koerperliche-naehe": [],
            "sexuelle-offenheit": ["orientierungStatus"],

            // KATEGORIE E: Kommunikation
            "kommunikations-stil": ["dominanz"],
            "konflikt-kommunikation": ["dominanz"],
            "beduerfnis-artikulation": [],
            "feedback-kultur": [],

            // KATEGORIE F: Soziale KompatibilitÃ¤t
            "philosophische-entwicklung": [],
            "anpassungsfaehigkeit": ["dominanz"],
            "krisenresilienz": ["dominanz"],
            "gemeinsame-vision": [],
            "soziales-umfeld": [],
            "gesellschaftliche-akzeptanz": []
        };

        // Calculate dominanz modifier
        // NOTE: Logic extracted to /js/dimensions/dominanzModifier.js
        function getDominanzModifier(dom1, dom2) {
            // Delegate to extracted module
            if (typeof TiageDimensions !== 'undefined' && TiageDimensions.Dominanz) {
                return TiageDimensions.Dominanz.getModifier(dom1, dom2);
            }
            // Fallback: inline implementation for backwards compatibility
            // Return 0 if either is null/undefined
            if (!dom1 || !dom2) return 0;

            // KOMPLEMENTÃ„R
            if ((dom1 === "dominant" && dom2 === "submissiv") ||
                (dom1 === "submissiv" && dom2 === "dominant")) {
                return 8;
            }
            // BEIDE GLEICH
            if (dom1 === dom2) {
                if (dom1 === "ausgeglichen") return 5;
                if (dom1 === "switch") return 3;
                if (dom1 === "dominant") return -5;
                if (dom1 === "submissiv") return -5;
            }
            // EINER FLEXIBEL
            if (dom1 === "switch" || dom2 === "switch" ||
                dom1 === "ausgeglichen" || dom2 === "ausgeglichen") {
                return 2;
            }
            return 0;
        }

        // Get dominanz modifier description
        // Basiert auf Forschung: Sadikaj et al. (2017), Tiedens & Fragale (2003)
        // NOTE: Logic extracted to /js/dimensions/dominanzModifier.js
        function getDominanzDescription(dom1, dom2, modifier) {
            // Delegate to extracted module
            if (typeof TiageDimensions !== 'undefined' && TiageDimensions.Dominanz) {
                return TiageDimensions.Dominanz.getDescription(dom1, dom2, modifier);
            }
            // Fallback: inline implementation for backwards compatibility
            if (modifier === 8) return `KomplementÃ¤r (${dom1} Ã— ${dom2}): Optimale Rollenverteilung - Forschung zeigt hÃ¶here Sympathie und Komfort`;
            if (modifier === 5) return `Beide ausgeglichen: Flexible Dynamik ohne starre Hierarchie`;
            if (modifier === 3) return `Beide switch: Wechselnde Dynamik mit situativer Anpassung`;
            if (modifier === -5 && dom1 === "dominant") return `Beide dominant: Machtkampf-Risiko - bewusste Kommunikationsregeln empfohlen`;
            if (modifier === -5 && dom1 === "submissiv") return `Beide submissiv: FÃ¼hrungsvakuum - klare Aufgabenteilung empfohlen`;
            if (modifier === 2) return `FlexibilitÃ¤t: Ein Partner passt sich situativ an`;
            return "Neutral";
        }

        // Map tag to category
        // NOTE: Logic extracted to /js/dimensions/tagDimensionRelevance.js
        function getTagCategory(tagId) {
            // Delegate to extracted module
            if (typeof TiageDimensions !== 'undefined' && TiageDimensions.TagRelevance) {
                return TiageDimensions.TagRelevance.getTagCategory(tagId);
            }
            // Fallback: inline implementation for backwards compatibility
            const mapping = {
                "exklusivitaets-erwartung": "A", "offenheit-fuer-alternative-modelle": "A",
                "beziehung-als-lebensinhalt": "A", "primaerbeziehung-konzept": "A", "commitment-tiefe": "A",
                "fuehrung-und-initiative": "B", "macht-balance": "B", "emotionale-reziprozitaet": "B",
                "eifersucht-umgang": "B", "konfliktloesung": "B", "emotionale-tiefe": "B",
                "entscheidungsfindung": "C", "alltags-organisation": "C", "autonomie-vs-gemeinsame-zeit": "C",
                "finanzielle-organisation": "C", "wohnform-flexibilitaet": "C", "zeitmanagement": "C",
                "koerperliche-anziehung": "D", "sexuelle-dominanz-dynamik": "D", "experimentierfreude": "D",
                "intimitaets-frequenz": "D", "koerperliche-naehe": "D", "sexuelle-offenheit": "D",
                "kommunikations-stil": "E", "konflikt-kommunikation": "E",
                "beduerfnis-artikulation": "E", "feedback-kultur": "E",
                "philosophische-entwicklung": "F", "anpassungsfaehigkeit": "F", "krisenresilienz": "F",
                "gemeinsame-vision": "F", "soziales-umfeld": "F", "gesellschaftliche-akzeptanz": "F"
            };
            return mapping[tagId] || null;
        }

        // Calculate tag score with modifiers
        // NOTE: Logic extracted to /js/dimensions/tagCalculator.js
        function calculateTagWithModifiers(tagId, person1, person2, pathosCheck) {
            // Delegate to extracted module
            if (typeof TiageDimensions !== 'undefined' && TiageDimensions.TagCalculator) {
                return TiageDimensions.TagCalculator.calculateTagWithModifiers(tagId, person1, person2, pathosCheck, data);
            }
            // Fallback: inline implementation for backwards compatibility
            const interactionKey = `${person1.archetyp}_${person2.archetyp}`;
            const interaction = data?.interactions[interactionKey];
            const tagCategory = getTagCategory(tagId);
            let baseScore = interaction?.scores?.[tagCategory]?.value || 50;

            const relevantDims = tagDimensionRelevance[tagId] || [];
            if (relevantDims.length === 0) {
                return { score: baseScore, baseScore, modifier: 0, dims: [], desc: "Archetyp-basiert" };
            }

            let modifier = 0;
            let descriptions = [];

            // Dominanz modifier
            if (relevantDims.includes("dominanz")) {
                const domMod = getDominanzModifier(person1.dominanz, person2.dominanz);
                modifier += domMod;
                if (domMod !== 0) descriptions.push(getDominanzDescription(person1.dominanz, person2.dominanz, domMod));
            }

            // Physical compatibility (Pathos uncertainty)
            if (relevantDims.some(d => ["geschlecht", "orientierung", "orientierungStatus"].includes(d))) {
                if (pathosCheck?.result === "unsicher") {
                    modifier -= 10;
                    descriptions.push("Unsichere kÃ¶rperliche Anziehung");
                }
            }

            // Orientation status (exploration bonus)
            if (relevantDims.includes("orientierungStatus")) {
                if (person1.orientierungStatus === "interessiert" || person2.orientierungStatus === "interessiert") {
                    if (tagId === "experimentierfreude" || tagId === "sexuelle-offenheit") {
                        modifier += 5;
                        descriptions.push("Explorationsbonus");
                    }
                }
            }

            const finalScore = Math.round(baseScore + modifier);
            return {
                score: finalScore,
                baseScore,
                modifier,
                dims: relevantDims,
                desc: descriptions.length > 0 ? descriptions.join("; ") : "Keine Anpassung"
            };
        }

        // Calculate category with modifiers
        // NOTE: Logic extracted to /js/dimensions/tagCalculator.js
        function calculateCategoryWithModifiers(catLetter, person1, person2, pathosCheck) {
            // Delegate to extracted module
            if (typeof TiageDimensions !== 'undefined' && TiageDimensions.TagCalculator) {
                return TiageDimensions.TagCalculator.calculateCategoryWithModifiers(catLetter, person1, person2, pathosCheck, data);
            }
            // Fallback: inline implementation for backwards compatibility
            const categoryTags = Object.keys(tagDimensionRelevance).filter(t => getTagCategory(t) === catLetter);

            if (categoryTags.length === 0) {
                const interactionKey = `${person1.archetyp}_${person2.archetyp}`;
                const interaction = data?.interactions[interactionKey];
                return { score: interaction?.scores?.[catLetter]?.value || 50, modifier: 0, tags: [] };
            }

            let totalScore = 0, totalMod = 0;
            const tagDetails = [];

            for (const tagId of categoryTags) {
                const result = calculateTagWithModifiers(tagId, person1, person2, pathosCheck);
                totalScore += result.score;
                totalMod += result.modifier;
                tagDetails.push({ id: tagId, ...result });
            }

            return {
                score: Math.round(totalScore / categoryTags.length),
                modifier: Math.round(totalMod / categoryTags.length),
                tags: tagDetails
            };
        }

        // ========================================
        // NEW: 4-Factor Relationship Quality Model
        // ========================================

        // Factor 1: Archetype Match (40%) - SSOT aus BedÃ¼rfnis-Profilen
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SSOT: Nutzt ArchetypeMatrixCalculator.getScore() fÃ¼r Live-Berechnung
        // KEINE Fallback-Matrix - Werte werden aus BedÃ¼rfnis-Profilen berechnet
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function getArchetypeScore(type1, type2) {
            // SSOT: Nutze ArchetypeMatrixCalculator.getScore() direkt
            if (typeof TiageSynthesis !== 'undefined' &&
                TiageSynthesis.ArchetypeMatrixCalculator &&
                typeof TiageSynthesis.ArchetypeMatrixCalculator.getScore === 'function') {
                const score = TiageSynthesis.ArchetypeMatrixCalculator.getScore(type1, type2);
                console.log('[getArchetypeScore] SSOT:', type1, type2, 'â†’', score);
                return score;
            }

            // Fallback: TiageSynthesis.Factors.Archetyp (nutzt auch SSOT intern)
            if (typeof TiageSynthesis !== 'undefined' &&
                TiageSynthesis.Factors &&
                TiageSynthesis.Factors.Archetyp &&
                typeof TiageSynthesis.Factors.Archetyp.calculate === 'function') {
                const result = TiageSynthesis.Factors.Archetyp.calculate(type1, type2, data);
                console.log('[getArchetypeScore] Via Factors.Archetyp:', type1, type2, 'â†’', result.score);
                return result.score;
            }

            // Letzte Fallback: Matrix-Interaction
            const key = `${type1}_${type2}`;
            const interaction = data?.interactions?.[key];
            if (interaction?.overall) {
                return interaction.overall;
            }

            console.warn('[getArchetypeScore] SSOT nicht verfÃ¼gbar fÃ¼r:', type1, type2);
            return 50; // Neutraler Default
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Factor 2: Dominance Harmony (20% Gewichtung - Pathos/GefÃ¼hl)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Philosophische Grundlage: OSHO + Metaphysik der QualitÃ¤t (Pirsig)
        //
        // OSHO: "Nur Extreme kÃ¶nnen sich wirklich verlieben. Nur Extreme ziehen
        //        sich an. Je weiter sie voneinander entfernt sind, desto tiefer
        //        wird die Anziehung."
        //
        // OSHO: "Es gibt nur eine Energie - Tao. Sie funktioniert auf zwei Arten.
        //        Du kannst Konflikt ODER Harmonie zwischen beiden erschaffen."
        //
        // MOQ (Pirsig): Dynamische QualitÃ¤t entsteht durch Spannung zwischen
        //               Polen. Statische QualitÃ¤t bewahrt funktionierende Muster.
        //
        // Werte-Logik:
        // - 100%: KomplementÃ¤re PolaritÃ¤t (Domâ†”Sub) = maximale dynamische QualitÃ¤t
        // -  95%: Tao-Balance (Ausgeglichenâ†”Ausgeglichen) = harmonische Einheit
        // -  90%: Flexible Dynamik (Switchâ†”Switch) = spielerische Anpassung
        // -  85%: Pol + Balance = stabile ErgÃ¤nzung
        // -  80%: Switch + Pol = Anpassung mÃ¶glich, aber Spannung
        // -  60%: Gleiche Pole (Domâ†”Dom, Subâ†”Sub) = Konflikt, fehlende Spannung
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DOMINANZ HARMONY MATRIX - SSOT: Referenziert Constants.DOMINANCE_MATRIX
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function getDominanzHarmonyMatrix() {
            if (typeof TiageSynthesis !== 'undefined' &&
                TiageSynthesis.Constants &&
                TiageSynthesis.Constants.DOMINANCE_MATRIX) {
                return TiageSynthesis.Constants.DOMINANCE_MATRIX;
            }
            // Fallback (sollte nicht erreicht werden)
            console.warn('[getDominanzHarmonyMatrix] SSOT nicht verfÃ¼gbar, nutze Fallback');
            return {
                "dominant-submissiv": 100, "submissiv-dominant": 100,
                "ausgeglichen-ausgeglichen": 100, "switch-switch": 100,
                "switch-ausgeglichen": 100, "ausgeglichen-switch": 100,
                "dominant-ausgeglichen": 93, "ausgeglichen-dominant": 93,
                "submissiv-ausgeglichen": 93, "ausgeglichen-submissiv": 93,
                "switch-dominant": 93, "dominant-switch": 93,
                "switch-submissiv": 93, "submissiv-switch": 93,
                "dominant-dominant": 55, "submissiv-submissiv": 55
            };
        }
        const dominanzHarmonyMatrix = getDominanzHarmonyMatrix();

        // Calculate harmony between two single dominanz types
        function calculateSingleDominanzHarmony(type1, status1, type2, status2) {
            const key = `${type1}-${type2}`;
            let baseScore = dominanzHarmonyMatrix[key] || dominanzHarmonyMatrix[`${type2}-${type1}`] || 75;

            // STATUS-MODIFIER: Reduzierte Konfidenz bei "interessiert"
            if (status1 === 'interessiert' || status2 === 'interessiert') {
                baseScore = Math.round(baseScore * 0.7);
            }

            return baseScore;
        }

        // Calculate best dominanz harmony for multi-select (finds best combination)
        function calculateDominanceHarmony(domObj1, domObj2) {
            // Handle old single-value format (backwards compatibility)
            if (typeof domObj1 === 'string' || typeof domObj2 === 'string') {
                return calculateSingleDominanzHarmony(domObj1, 'gelebt', domObj2, 'gelebt');
            }

            // Get selected dominanz preferences for each person (Primary/Secondary structure)
            const list1 = [];
            const list2 = [];

            if (domObj1) {
                if (domObj1.primary) list1.push({ type: domObj1.primary, status: 'primary' });
                if (domObj1.secondary) list1.push({ type: domObj1.secondary, status: 'secondary' });
            }

            if (domObj2) {
                if (domObj2.primary) list2.push({ type: domObj2.primary, status: 'primary' });
                if (domObj2.secondary) list2.push({ type: domObj2.secondary, status: 'secondary' });
            }

            // Default if no selections
            if (list1.length === 0 || list2.length === 0) return 75;

            // Find best combination
            let bestScore = 0;
            for (const d1 of list1) {
                for (const d2 of list2) {
                    const score = calculateSingleDominanzHarmony(d1.type, d1.status, d2.type, d2.status);
                    if (score > bestScore) {
                        bestScore = score;
                    }
                }
            }

            return bestScore;
        }

        // Factor 3: Orientation Compatibility (25%) - uses existing checkPhysicalCompatibility
        function calculateOrientationScore(person1, person2) {
            const pathosCheck = checkPhysicalCompatibility(person1, person2);

            console.log('[calculateOrientationScore] pathosCheck.result:', pathosCheck.result,
                        'reason:', pathosCheck.reason || '-',
                        'missingItems:', pathosCheck.missingItems || '-');

            if (pathosCheck.result === "unmÃ¶glich") {
                console.log('[calculateOrientationScore] K.O. - returning 0');
                return 0;  // K.O.-Kriterium!
            }

            if (pathosCheck.result === "unsicher") {
                console.log('[calculateOrientationScore] Unsicher - returning 70');
                return 70;  // Exploration-Phase
            }

            console.log('[calculateOrientationScore] MÃ¶glich - returning 100');
            return 100;  // Kompatibel
        }

        // Factor 4: Gender Attraction (15%)
        function calculateGenderAttraction(p1, p2) {
            // Extract primary gender from object format { primary: 'mann', secondary: 'cis' }
            let g1 = p1.geschlecht;
            let g2 = p2.geschlecht;
            let identity1 = null;
            let identity2 = null;

            if (g1 && typeof g1 === 'object' && 'primary' in g1) {
                identity1 = g1.secondary;  // cis, trans, suchend, nonbinaer, fluid
                g1 = g1.primary;           // mann, frau, inter
            }
            if (g2 && typeof g2 === 'object' && 'primary' in g2) {
                identity2 = g2.secondary;
                g2 = g2.primary;
            }

            // Handle Primary/Secondary orientierung structure
            const oriList1 = [];
            const oriList2 = [];

            if (p1.orientierung && typeof p1.orientierung === 'object') {
                if (p1.orientierung.primary) oriList1.push(p1.orientierung.primary);
                if (p1.orientierung.secondary) oriList1.push(p1.orientierung.secondary);
            } else if (p1.orientierung) {
                oriList1.push(p1.orientierung);
            }

            if (p2.orientierung && typeof p2.orientierung === 'object') {
                if (p2.orientierung.primary) oriList2.push(p2.orientierung.primary);
                if (p2.orientierung.secondary) oriList2.push(p2.orientierung.secondary);
            } else if (p2.orientierung) {
                oriList2.push(p2.orientierung);
            }

            // Return default if values missing
            if (!g1 || !g2 || oriList1.length === 0 || oriList2.length === 0) return 75;

            // Check best combination for base score
            let bestScore = 0;

            for (const o1 of oriList1) {
                for (const o2 of oriList2) {
                    const score = calculateSingleGenderAttraction(g1, o1, g2, o2);
                    if (score > bestScore) {
                        bestScore = score;
                    }
                }
            }

            // Apply Identity Resonance (cis/trans/suchend) if both identities are set
            if (identity1 && identity2) {
                const identityFactor = calculateIdentityResonance(identity1, identity2);
                // Combine: 70% base attraction + 30% identity resonance
                bestScore = Math.round(bestScore * 0.7 + identityFactor * 0.3);
            }

            return bestScore;
        }

        // Calculate Identity Resonance using IDENTITY_MATRIX from constants
        function calculateIdentityResonance(id1, id2) {
            // Use TiageSynthesis constants if available
            const IDENTITY_MATRIX = (typeof TiageSynthesis !== 'undefined' && TiageSynthesis.Constants?.IDENTITY_MATRIX) || {
                "cis-cis": 100,
                "cis-trans": 85,
                "cis-suchend": 70,
                "trans-cis": 85,
                "trans-trans": 100,
                "trans-suchend": 75,
                "nonbinaer-nonbinaer": 100,
                "nonbinaer-fluid": 90,
                "nonbinaer-suchend": 80,
                "fluid-nonbinaer": 90,
                "fluid-fluid": 100,
                "fluid-suchend": 85,
                "suchend-cis": 70,
                "suchend-trans": 75,
                "suchend-nonbinaer": 80,
                "suchend-fluid": 85,
                "suchend-suchend": 100,
                "cis-nonbinaer": 65,
                "cis-fluid": 55,
                "trans-nonbinaer": 75,
                "trans-fluid": 65,
                "nonbinaer-cis": 65,
                "nonbinaer-trans": 75,
                "fluid-cis": 55,
                "fluid-trans": 65
            };

            const IDENTITY_OPENNESS = (typeof TiageSynthesis !== 'undefined' && TiageSynthesis.Constants?.IDENTITY_OPENNESS) || {
                "cis": 0,
                "trans": 30,
                "nonbinaer": 50,
                "fluid": 80,
                "suchend": 100
            };

            // Get base score from matrix
            const key = `${id1}-${id2}`;
            let baseScore = IDENTITY_MATRIX[key];

            // Fallback for unknown combinations
            if (baseScore === undefined) {
                baseScore = 75;
            }

            // Calculate openness bonus
            const openness1 = IDENTITY_OPENNESS[id1] || 0;
            const openness2 = IDENTITY_OPENNESS[id2] || 0;
            const opennessBonus = Math.round((openness1 + openness2) / 200 * 10); // Max 10 points

            // Keine Obergrenze - Score kann Ã¼ber 100 gehen (z.B. durch Openness-Bonus)
            return baseScore + opennessBonus;
        }

        // Helper for single orientierung pair - nutzt Geschlechts-Kategorien
        function calculateSingleGenderAttraction(g1, o1, g2, o2) {
            // Konvertiere Geschlechter zu Kategorien fÃ¼r die Logik
            const cat1 = getGeschlechtCategory(g1);
            const cat2 = getGeschlechtCategory(g2);

            // Bi = immer 100% (angezogen von mÃ¤nnlich und weiblich)
            if (o1 === "bisexuell" || o2 === "bisexuell") return 100;

            // Hetero: Angezogen vom "anderen" Geschlecht
            if (o1 === "heterosexuell" && o2 === "heterosexuell") {
                if ((cat1 === "maennlich" && cat2 === "weiblich") ||
                    (cat1 === "weiblich" && cat2 === "maennlich")) return 100;
                // NonbinÃ¤r, Fluid, Agender - partielle KompatibilitÃ¤t
                if (cat1 === "nonbinaer" || cat2 === "nonbinaer" ||
                    cat1 === "fluid" || cat2 === "fluid") return 80;
                if (cat1 === "agender" || cat2 === "agender") return 60;
                return 0;
            }

            // Homo: Angezogen vom "gleichen" Geschlecht
            if (o1 === "homosexuell" && o2 === "homosexuell") {
                if (cat1 === cat2 && cat1 !== "nonbinaer" && cat1 !== "fluid" && cat1 !== "agender") return 100;
                // NonbinÃ¤r mit Homo - angezogen von Ã¤hnlichen
                if ((cat1 === "nonbinaer" && cat2 === "nonbinaer") ||
                    (cat1 === "fluid" && cat2 === "fluid")) return 90;
                if (cat1 === "nonbinaer" || cat2 === "nonbinaer" ||
                    cat1 === "fluid" || cat2 === "fluid") return 75;
                if (cat1 === "agender" || cat2 === "agender") return 60;
                return 0;
            }

            return 75;  // Gemischte Orientierungen
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // R4 HYBRID: BIDIREKTIONALE ATTRAKTION MIT P/S GEWICHTUNG
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Berechnet gegenseitige Attraktion unter BerÃ¼cksichtigung von:
        // - PrimÃ¤re Orientierung (70% Gewicht)
        // - SekundÃ¤re Orientierung (30% Gewicht, Bonus nicht Override)
        // - Bidirektional: ICHâ†’Partner UND Partnerâ†’ICH
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Berechnet die Attraktion in EINE Richtung (Person A â†’ Person B)
         * BerÃ¼cksichtigt PrimÃ¤r/SekundÃ¤r Orientierung mit Gewichtung
         *
         * @param {string} genderA - Geschlecht von A (effektiv, nach Cis/Trans)
         * @param {object} orientierungA - { primary, secondary } von A
         * @param {string} genderB - Geschlecht von B (effektiv)
         * @returns {number} Attraktion 0-100
         */
        function calculateDirectionalAttraction(genderA, orientierungA, genderB) {
            const PRIMARY_WEIGHT = 0.70;
            const SECONDARY_WEIGHT = 0.30;

            // Extrahiere P/S Orientierungen
            let primaryOri = null;
            let secondaryOri = null;

            if (orientierungA && typeof orientierungA === 'object') {
                primaryOri = orientierungA.primary || null;
                secondaryOri = orientierungA.secondary || null;
            } else if (typeof orientierungA === 'string') {
                primaryOri = orientierungA;
            }

            if (!primaryOri || !genderA || !genderB) {
                return 75; // Neutral bei fehlenden Daten
            }

            // Konvertiere zu Kategorien
            const catA = getGeschlechtCategory(genderA);
            const catB = getGeschlechtCategory(genderB);

            // Hilfsfunktion: PrÃ¼ft ob Orientierung zu Geschlecht passt
            const checkAttraction = (ori, fromCat, toCat) => {
                if (!ori) return 0;

                if (ori === 'bisexuell' || ori === 'pansexuell') {
                    return 100; // Bi/Pan = offen fÃ¼r alle
                }

                if (ori === 'heterosexuell') {
                    // Hetero: Angezogen vom "anderen" Geschlecht
                    if ((fromCat === 'maennlich' && toCat === 'weiblich') ||
                        (fromCat === 'weiblich' && toCat === 'maennlich')) {
                        return 100;
                    }
                    // NonbinÃ¤r/Fluid - partielle KompatibilitÃ¤t
                    if (toCat === 'nonbinaer' || toCat === 'fluid') return 60;
                    // Gleiches Geschlecht = keine Attraktion
                    return 0;
                }

                if (ori === 'homosexuell') {
                    // Homo: Angezogen vom "gleichen" Geschlecht
                    if (fromCat === toCat && fromCat !== 'nonbinaer' && fromCat !== 'fluid') {
                        return 100;
                    }
                    // NonbinÃ¤r mit Ã¤hnlichen
                    if ((fromCat === 'nonbinaer' || fromCat === 'fluid') &&
                        (toCat === 'nonbinaer' || toCat === 'fluid')) {
                        return 85;
                    }
                    // Verschiedene binÃ¤re Geschlechter = keine Attraktion
                    if ((fromCat === 'maennlich' && toCat === 'weiblich') ||
                        (fromCat === 'weiblich' && toCat === 'maennlich')) {
                        return 0;
                    }
                    return 50; // Unsicher
                }

                return 50; // Unbekannte Orientierung
            };

            // Berechne Attraktion fÃ¼r PrimÃ¤r und SekundÃ¤r
            const primaryAttraction = checkAttraction(primaryOri, catA, catB);
            const secondaryAttraction = secondaryOri
                ? checkAttraction(secondaryOri, catA, catB)
                : 0;

            // Gewichtete Kombination
            // Wenn kein Secondary: nur Primary zÃ¤hlt (100%)
            if (!secondaryOri) {
                return primaryAttraction;
            }

            // Mit Secondary: P Ã— 0.70 + S Ã— 0.30
            return Math.round(primaryAttraction * PRIMARY_WEIGHT + secondaryAttraction * SECONDARY_WEIGHT);
        }

        /**
         * Berechnet BIDIREKTIONALE Attraktion zwischen zwei Personen
         * Beide Richtungen mÃ¼ssen passen!
         *
         * @param {object} person1 - { geschlecht: {primary, secondary}, orientierung: {primary, secondary} }
         * @param {object} person2 - { geschlecht: {primary, secondary}, orientierung: {primary, secondary} }
         * @returns {object} { score, direction1to2, direction2to1, details }
         */
        function calculateBidirectionalAttraction(person1, person2) {
            // Extrahiere effektive Geschlechter (nach Cis/Trans Transformation)
            const getEffectiveGender = (geschlecht) => {
                if (!geschlecht) return null;
                if (typeof geschlecht === 'string') return geschlecht;

                const primary = geschlecht.primary;   // KÃ¶rper: mann, frau, inter
                const secondary = geschlecht.secondary; // IdentitÃ¤t: cis, trans, nonbinaer

                if (!secondary || secondary === 'cis') return primary;
                if (secondary === 'trans') {
                    if (primary === 'mann') return 'frau';
                    if (primary === 'frau') return 'mann';
                    return primary;
                }
                if (secondary === 'nonbinaer') return 'nonbinaer';
                if (secondary === 'fluid') return 'fluid';

                return primary || secondary;
            };

            const gender1 = getEffectiveGender(person1.geschlecht);
            const gender2 = getEffectiveGender(person2.geschlecht);

            // Berechne beide Richtungen
            const attraction1to2 = calculateDirectionalAttraction(gender1, person1.orientierung, gender2);
            const attraction2to1 = calculateDirectionalAttraction(gender2, person2.orientierung, gender1);

            // Bidirektional: Durchschnitt beider Richtungen
            // Alternativ: Minimum (strenger) - aber Durchschnitt ist fairer
            const bidirectionalScore = Math.round((attraction1to2 + attraction2to1) / 2);

            return {
                score: bidirectionalScore,
                direction1to2: attraction1to2,
                direction2to1: attraction2to1,
                details: {
                    gender1,
                    gender2,
                    orientierung1: person1.orientierung,
                    orientierung2: person2.orientierung
                }
            };
        }

        /**
         * Berechnet R4 HYBRID: Kombination aus IdentitÃ¤t + Bidirektionaler Attraktion
         *
         * Formel: R4 = 0.5 + (identity Ã— 0.30 + attraction Ã— 0.70) / 100
         *
         * @param {object} person1 - VollstÃ¤ndiges Profil
         * @param {object} person2 - VollstÃ¤ndiges Profil
         * @returns {object} { R4, identityScore, attractionScore, details }
         */
        function calculateR4Hybrid(person1, person2) {
            const IDENTITY_WEIGHT = 0.30;
            const ATTRACTION_WEIGHT = 0.70;

            // 1. IdentitÃ¤ts-Resonanz (Cisâ†”Cis, Transâ†”Trans, etc.)
            const identity1 = person1.geschlecht?.secondary || 'cis';
            const identity2 = person2.geschlecht?.secondary || 'cis';
            const identityScore = calculateIdentityResonance(identity1, identity2);

            // 2. Bidirektionale Attraktion
            const attractionResult = calculateBidirectionalAttraction(person1, person2);
            const attractionScore = attractionResult.score;

            // 3. Hybrid-Kombination
            // v3.7: R4 = (combinedScore / 100)Â² - keine Obergrenze
            const combinedScore = identityScore * IDENTITY_WEIGHT + attractionScore * ATTRACTION_WEIGHT;
            const normalized = combinedScore / 100;
            const R4 = normalized * normalized;

            // v3.7: Keine Obergrenze - R4 kann > 1.0 sein wenn combinedScore > 100
            const R4Final = Math.max(0, R4);

            console.log('[calculateR4Hybrid] Ergebnis:', {
                identityScore,
                attractionScore,
                combinedScore: Math.round(combinedScore),
                R4: Math.round(R4Final * 1000) / 1000,
                attraction1to2: attractionResult.direction1to2,
                attraction2to1: attractionResult.direction2to1
            });

            return {
                R4: Math.round(R4Final * 1000) / 1000,
                identityScore,
                attractionScore,
                combinedScore: Math.round(combinedScore),
                attractionDetails: attractionResult
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RESONANZ-BERECHNUNG (Meta-Dimension)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // R = 0.9 + [(M/100 Ã— 0.5) + (B Ã— 0.5)] Ã— 0.2
        // wobei:
        //   M = Profil-Match (0-100%): Ãœbereinstimmung der 30 Attribute
        //   B = Balance (0-1): Harmonie zwischen Logos und Pathos
        // Ergebnis: R zwischen 0.9 und 1.1
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Die 30 Profil-Attribute in 3 Kategorien
        const PROFILE_ATTRIBUTES = {
            D: ['kinderWunsch', 'eheWunsch', 'wohnform', 'religion', 'karrierePrioritaet',
                'finanzPhilosophie', 'lebensstil', 'umzugsbereitschaft', 'zukunftsplanung', 'traditionenWichtigkeit'],
            E: ['kommunikationsstil', 'konfliktverhalten', 'emotionaleOffenheit', 'gespraechsBedÃ¼rfnis', 'feedbackStil',
                'entschuldigungen', 'streitVerhalten', 'versoehnung', 'kritikAnnehmen', 'humorKonflikte'],
            F: ['introExtro', 'familieWichtigkeit', 'freundeskreis', 'oeffentlichkeit', 'alleinzeit',
                'events', 'reisen', 'hobbys', 'wochenende', 'netzwerkGroesse']
        };

        /**
         * Berechnet den Profil-Match-Score (M)
         * Vergleicht die 30 Attribute zweier psychologischer Profile
         * Nutzt TiageProfileStore fÃ¼r 648 P/S-basierte Profile
         * @returns {number} Match-Prozent 0-100
         */
        function calculateProfilMatch(person1, person2) {
            // TiageProfileStore verfÃ¼gbar?
            if (typeof TiageProfileStore === 'undefined') {
                // Fallback: SchÃ¤tze Match basierend auf Archetyp-Ã„hnlichkeit
                return estimateProfilMatch(person1, person2);
            }

            // Profile aus TiageProfileStore laden (synchron)
            const profile1 = getProfileFromStore(person1);
            const profile2 = getProfileFromStore(person2);

            if (!profile1 || !profile2) {
                return estimateProfilMatch(person1, person2);
            }

            // ZÃ¤hle Ã¼bereinstimmende Attribute
            let matches = 0;
            const allAttributes = [...PROFILE_ATTRIBUTES.D, ...PROFILE_ATTRIBUTES.E, ...PROFILE_ATTRIBUTES.F];
            const attrs1 = profile1.attributes || profile1;
            const attrs2 = profile2.attributes || profile2;

            for (const attr of allAttributes) {
                if (attrs1[attr] && attrs2[attr]) {
                    if (attrs1[attr] === attrs2[attr]) {
                        matches++;
                    } else if (areAttributesCompatible(attr, attrs1[attr], attrs2[attr])) {
                        matches += 0.5; // Partielle Ãœbereinstimmung
                    }
                }
            }

            return Math.round((matches / 30) * 100);
        }

        /**
         * LÃ¤dt ein Profil aus TiageProfileStore basierend auf Person-Daten
         */
        /**
         * Berechnet BedÃ¼rfnis-Matching direkt aus TiageState.flatNeeds
         * Verwendet die individualisierten Werte (Archetyp + Modifikatoren)
         * und berÃ¼cksichtigt manuell gelockte Werte (lockedNeeds)
         *
         * @returns {Object|null} { score, gemeinsam, komplementaer, unterschiedlich } oder null
         */
        function calculateNeedsMatchFromFlatNeeds() {
            if (typeof TiageState === 'undefined') {
                return null;
            }

            // flatNeeds aus TiageState holen (Archetyp + D/G/O Modifikatoren)
            const ichFlatNeeds = TiageState.getFlatNeeds('ich') || {};
            const partnerFlatNeeds = TiageState.getFlatNeeds('partner') || {};

            // PrÃ¼fen ob Daten vorhanden
            const ichKeys = Object.keys(ichFlatNeeds);
            const partnerKeys = Object.keys(partnerFlatNeeds);

            // DEBUG: Log flatNeeds fÃ¼r beide Personen
            console.log('[calculateNeedsMatchFromFlatNeeds] Vergleich:', {
                ichCount: ichKeys.length,
                partnerCount: partnerKeys.length,
                ichSample: ichKeys.slice(0, 5).reduce((o, k) => ({ ...o, [k]: ichFlatNeeds[k] }), {}),
                partnerSample: partnerKeys.slice(0, 5).reduce((o, k) => ({ ...o, [k]: partnerFlatNeeds[k] }), {}),
                ichDimensions: TiageState.get('personDimensions.ich'),
                partnerDimensions: TiageState.get('personDimensions.partner')
            });

            if (ichKeys.length === 0 || partnerKeys.length === 0) {
                return null; // Keine Daten verfÃ¼gbar
            }

            // lockedNeeds holen (Ã¼berschreiben flatNeeds)
            const ichLockedNeeds = TiageState.getLockedNeeds('ich') || {};
            const partnerLockedNeeds = TiageState.getLockedNeeds('partner') || {};

            // DEBUG: Log lockedNeeds
            const ichLockedCount = Object.keys(ichLockedNeeds).length;
            const partnerLockedCount = Object.keys(partnerLockedNeeds).length;
            if (ichLockedCount > 0 || partnerLockedCount > 0) {
                console.log('[calculateNeedsMatchFromFlatNeeds] LockedNeeds:', {
                    ichLocked: ichLockedCount,
                    partnerLocked: partnerLockedCount
                });
            }

            // Finale Werte: lockedNeeds Ã¼berschreiben flatNeeds
            const getFinalValue = (person, needId) => {
                const locked = person === 'ich' ? ichLockedNeeds[needId] : partnerLockedNeeds[needId];
                const flat = person === 'ich' ? ichFlatNeeds[needId] : partnerFlatNeeds[needId];

                // lockedNeeds haben PrioritÃ¤t
                if (locked !== undefined && locked !== null) return locked;
                if (flat !== undefined && flat !== null) return flat;
                return null;
            };

            // Alle BedÃ¼rfnis-IDs sammeln (Union von beiden)
            const allNeedIds = new Set([...ichKeys, ...partnerKeys]);

            const gemeinsam = [];
            const komplementaer = [];
            const unterschiedlich = [];

            // Matching berechnen
            allNeedIds.forEach(needId => {
                const wert1 = getFinalValue('ich', needId);
                const wert2 = getFinalValue('partner', needId);

                // Skip wenn einer der Werte fehlt
                if (wert1 === null || wert2 === null) return;

                const diff = Math.abs(wert1 - wert2);

                const item = {
                    need: needId,       // '#B1', '#B2', etc.
                    wert1: wert1,
                    wert2: wert2
                };

                // Kategorisierung basierend auf Differenz
                if (diff <= 15) {
                    gemeinsam.push(item);           // Ãœbereinstimmung (0-15)
                } else if (diff <= 35) {
                    komplementaer.push(item);       // KomplementÃ¤r (16-35)
                } else {
                    unterschiedlich.push(item);     // Konflikt (36+)
                }
            });

            // Score berechnen (gewichtet)
            const totalItems = gemeinsam.length + komplementaer.length + unterschiedlich.length;
            if (totalItems === 0) return null;

            const score = Math.round(
                ((gemeinsam.length * 100) + (komplementaer.length * 60) + (unterschiedlich.length * 20)) / totalItems
            );

            return {
                score: score,
                gemeinsam: gemeinsam,
                komplementaer: komplementaer,
                unterschiedlich: unterschiedlich
            };
        }

        function getProfileFromStore(person) {
            // P/S-Geschlecht extrahieren
            let pGender = null;
            let sGender = null;

            if (person.geschlecht && typeof person.geschlecht === 'object') {
                pGender = person.geschlecht.primary;
                sGender = person.geschlecht.secondary;
            } else if (typeof person.geschlecht === 'string') {
                // Legacy: String direkt als P, kein S
                pGender = person.geschlecht;
            }

            // Fallback fÃ¼r sGender wenn nur pGender gesetzt ist
            // Standard-Werte basierend auf pGender:
            // - mann/frau â†’ cis
            // - inter â†’ nonbinaer
            if (pGender && !sGender) {
                if (pGender === 'inter') {
                    sGender = 'nonbinaer';
                } else if (pGender === 'mann' || pGender === 'frau') {
                    sGender = 'cis';
                }
            }

            // Dominanz extrahieren
            let dominanz = 'ausgeglichen';
            if (person.dominanz && typeof person.dominanz === 'object') {
                if ('primary' in person.dominanz) {
                    dominanz = person.dominanz.primary || 'ausgeglichen';
                }
            } else if (person.dominanz) {
                dominanz = person.dominanz;
            }

            // Orientierung extrahieren
            let orientierung = 'heterosexuell';
            if (person.orientierung && typeof person.orientierung === 'object') {
                if ('primary' in person.orientierung) {
                    orientierung = person.orientierung.primary || 'heterosexuell';
                }
            } else if (person.orientierung) {
                orientierung = person.orientierung;
            }

            // Profil aus Store holen (synchron)
            if (pGender && sGender) {
                return TiageProfileStore.getProfileSync(
                    person.archetyp,
                    pGender,
                    sGender,
                    dominanz,
                    orientierung
                );
            }

            return null;
        }

        /**
         * SchÃ¤tzt den Profil-Match wenn keine exakten Profile verfÃ¼gbar
         * Basiert auf Archetyp-Ã„hnlichkeit und Dimension-Ãœbereinstimmungen
         */
        function estimateProfilMatch(person1, person2) {
            let score = 50; // Basis

            // Gleicher Archetyp = +30
            if (person1.archetyp === person2.archetyp) {
                score += 30;
            } else {
                // Ã„hnliche Archetypen (aus Matrix ableitbar)
                const archetypeScore = getArchetypeScore(person1.archetyp, person2.archetyp);
                score += Math.round((archetypeScore - 50) * 0.3);
            }

            // Gleiche Dominanz-Orientierung = +10
            const dom1 = getPrimaryDominanz(person1.dominanz);
            const dom2 = getPrimaryDominanz(person2.dominanz);
            if (dom1 === dom2) score += 10;

            // Ã„hnliche Orientierung = +10
            const ori1 = getPrimaryOrientierung(person1.orientierung);
            const ori2 = getPrimaryOrientierung(person2.orientierung);
            if (ori1 === ori2) score += 10;

            // Keine Obergrenze - nur Untergrenze bei 0
            return Math.max(0, score);
        }

        /**
         * PrÃ¼ft ob zwei Attribut-Werte kompatibel sind (partielle Ãœbereinstimmung)
         */
        function areAttributesCompatible(attr, val1, val2) {
            // KompatibilitÃ¤ts-Gruppen fÃ¼r bestimmte Attribute
            const compatGroups = {
                'wohnform': [['alleine', 'zusammen'], ['getrennt', 'zusammen']],
                'lebensstil': [['durchschnittlich', 'bescheiden'], ['durchschnittlich', 'luxuriÃ¶s']],
                'kommunikationsstil': [['direkt', 'ausgewogen'], ['indirekt', 'ausgewogen']],
                'introExtro': [['ambivert', 'introvertiert'], ['ambivert', 'extrovertiert']]
            };

            if (compatGroups[attr]) {
                for (const group of compatGroups[attr]) {
                    if (group.includes(val1) && group.includes(val2)) {
                        return true;
                    }
                }
            }

            return false;
        }

        /**
         * Helper: PrimÃ¤re Dominanz aus Objekt ermitteln
         */
        function getPrimaryDominanz(dominanz) {
            if (!dominanz || typeof dominanz !== 'object') return dominanz || 'ausgeglichen';
            // New format: { primary: 'dominant', secondary: 'submissiv' }
            if ('primary' in dominanz) {
                return dominanz.primary || 'ausgeglichen';
            }
            // Old format: { dominant: 'gelebt', submissiv: 'interessiert' }
            for (const [type, status] of Object.entries(dominanz)) {
                if (status === 'gelebt') return type;
            }
            return 'ausgeglichen';
        }

        /**
         * Helper: PrimÃ¤re Orientierung aus Objekt ermitteln
         */
        function getPrimaryOrientierung(orientierung) {
            if (!orientierung || typeof orientierung !== 'object') return orientierung || 'heterosexuell';
            // New format: { primary: 'homosexuell', secondary: 'heterosexuell' }
            if ('primary' in orientierung) {
                return orientierung.primary || 'heterosexuell';
            }
            // Old format: { heterosexuell: 'gelebt', homosexuell: 'interessiert' }
            for (const [type, status] of Object.entries(orientierung)) {
                if (status === 'gelebt') return type;
            }
            return 'heterosexuell';
        }

        /**
         * Berechnet die Logos-Pathos-Balance (B)
         * B = (100 - |Logos - Pathos|) / 100
         * @returns {number} Balance 0.0-1.0
         */
        function calculateLogosPathosBalance(archetypeScore, orientationScore, dominanceScore, genderScore) {
            // Logos = Archetyp-Score
            const logos = archetypeScore;

            // Pathos = Durchschnitt der drei Pathos-Faktoren
            const pathos = (orientationScore + dominanceScore + genderScore) / 3;

            // Differenz
            const differenz = Math.abs(logos - pathos);

            // Balance: Je geringer die Differenz, desto hÃ¶her die Balance
            const balance = (100 - differenz) / 100;

            return Math.max(0, Math.min(1, balance));
        }

        /**
         * Berechnet den Resonanz-Koeffizienten (R)
         * R = 0.9 + [(M/100 Ã— 0.35) + (B Ã— 0.35) + (K Ã— 0.30)] Ã— 0.2
         *
         * K = GFK-Kommunikationsfaktor (0-1)
         *     - Beide hoch: 1.0
         *     - Hoch+Mittel: 0.75
         *     - Beide mittel: 0.5
         *     - Asymmetrisch: 0.25
         *     - Beide niedrig: 0.0
         *
         * @returns {object} { R: 0.9-1.1, M: 0-100, B: 0-1, K: 0-1, interpretation: string }
         */
        function calculateResonanz(person1, person2, archetypeScore, orientationScore, dominanceScore, genderScore) {
            // Komponente 1: Profil-Match (M)
            const M = calculateProfilMatch(person1, person2);

            // Komponente 2: Logos-Pathos-Balance (B)
            const B = calculateLogosPathosBalance(archetypeScore, orientationScore, dominanceScore, genderScore);

            // Komponente 3: GFK-Kommunikationsfaktor (K) mit K1-K4 Subfaktoren
            const kResult = calculateGfkFactor();
            const K = kResult.K;  // Gesamt-K fÃ¼r Formel

            // Gesamtformel: R = 0.9 + [(M/100 Ã— 0.35) + (B Ã— 0.35) + (K Ã— 0.30)] Ã— 0.2
            // GFK bekommt 30% weil Kommunikation fundamental fÃ¼r Resonanz ist
            const R = 0.9 + ((M / 100 * 0.35) + (B * 0.35) + (K * 0.30)) * 0.2;

            // Interpretation
            let interpretation;
            if (R >= 1.08) {
                interpretation = 'Starke Harmonie';
            } else if (R >= 1.03) {
                interpretation = 'Leichte Harmonie';
            } else if (R >= 0.97) {
                interpretation = 'Neutral';
            } else if (R >= 0.93) {
                interpretation = 'Leichte Dissonanz';
            } else {
                interpretation = 'Starke Dissonanz';
            }

            return {
                R: Math.round(R * 100) / 100,
                M: M,
                B: Math.round(B * 100) / 100,
                K: K,
                K1: kResult.K1,  // Orientierung-BedÃ¼rfnisse
                K2: kResult.K2,  // Archetyp-BedÃ¼rfnisse
                K3: kResult.K3,  // Dominanz-BedÃ¼rfnisse
                K4: kResult.K4,  // Geschlecht-BedÃ¼rfnisse
                kompetenz: kResult.kompetenz,
                kompetenzLabel: kResult.kompetenzLabel,
                interpretation: interpretation
            };
        }

        /**
         * K-FAKTOR ZUORDNUNG: GFK-Kategorien zu den 4 Hauptfaktoren
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * Basiert auf Tiage-Modell (Pathos/Logos) + GFK (Rosenberg)
         */
        const K_FAKTOR_KATEGORIEN = {
            // K1: Orientierung (Pathos) - KÃ¶rperliche Anziehung, SexualitÃ¤t
            K1: ['existenz', 'zuneigung', 'musse'],  // 22 BedÃ¼rfnisse

            // K2: Archetyp (Logos) - Beziehungsphilosophie
            K2: ['freiheit', 'teilnahme', 'identitaet'],  // 26 BedÃ¼rfnisse

            // K3: Dominanz (Pathos) - Energetische Dynamik
            K3: ['dynamik', 'sicherheit'],  // 21 BedÃ¼rfnisse

            // K4: Geschlecht (Pathos) - Gender-Chemie, IdentitÃ¤t
            K4: ['verstaendnis', 'erschaffen', 'verbundenheit']  // 19 BedÃ¼rfnisse
        };

        /**
         * Berechnet den BedÃ¼rfnis-Match fÃ¼r eine K-Kategorie
         * @param {string} kKey - 'K1', 'K2', 'K3' oder 'K4'
         * @param {object} matching - Das Matching-Ergebnis von GfkBeduerfnisse.berechneMatching
         * @returns {number} 0-1, wobei 1 = perfekte Ãœbereinstimmung
         */
        function calculateKSubfaktor(kKey, matching) {
            if (!matching || !matching.details) return 0.5;  // Fallback

            const kategorien = K_FAKTOR_KATEGORIEN[kKey];
            if (!kategorien) return 0.5;

            let gemeinsam = 0;
            let total = 0;

            // ZÃ¤hle gemeinsame und unterschiedliche BedÃ¼rfnisse pro Kategorie
            const uebereinstimmend = matching.details.uebereinstimmend || [];
            const konflikt = matching.details.konflikt || [];

            for (const kat of kategorien) {
                const gemeinsamInKat = uebereinstimmend.filter(b => {
                    // b.stringKey fÃ¼r definitionen-Lookup verwenden
                    const def = GfkBeduerfnisse?.definitionen?.[b.stringKey || b.id];
                    return def?.kategorie === kat;
                }).length;

                const konfliktInKat = konflikt.filter(b => {
                    // b.stringKey fÃ¼r definitionen-Lookup verwenden
                    const def = GfkBeduerfnisse?.definitionen?.[b.stringKey || b.id];
                    return def?.kategorie === kat;
                }).length;

                gemeinsam += gemeinsamInKat;
                total += gemeinsamInKat + konfliktInKat;
            }

            // Wenn keine BedÃ¼rfnisse in dieser Kategorie: neutral
            if (total === 0) return 0.5;

            return gemeinsam / total;
        }

        /**
         * Berechnet den GFK-Kommunikationsfaktor (K) mit K1-K4 Subfaktoren
         * K = (K1 + K2 + K3 + K4) / 4
         *
         * Jeder Ki basiert auf dem BedÃ¼rfnis-Match der relevanten GFK-Kategorien:
         * - K1 (Orientierung): existenz, zuneigung, musse
         * - K2 (Archetyp): freiheit, teilnahme, identitaet
         * - K3 (Dominanz): dynamik, sicherheit
         * - K4 (Geschlecht): verstaendnis, erschaffen, verbundenheit
         *
         * @returns {object} { K: 0-1, K1, K2, K3, K4, details }
         */
        function calculateGfkFactor() {
            const ichGfk = personDimensions.ich?.gfk;
            const partnerGfk = personDimensions.partner?.gfk;

            // Basis-Kompetenz-Faktor (alte Logik als Fallback/Gewichtung)
            let kompetenzFaktor = 0.5;
            if (ichGfk && partnerGfk) {
                const gfkValues = { 'hoch': 3, 'mittel': 2, 'niedrig': 1 };
                const v1 = gfkValues[ichGfk] || 2;
                const v2 = gfkValues[partnerGfk] || 2;
                const sum = v1 + v2;
                const min = Math.min(v1, v2);

                if (sum === 6) kompetenzFaktor = 1.0;
                else if (sum === 5) kompetenzFaktor = 0.75;
                else if (sum === 4 && min === 2) kompetenzFaktor = 0.5;
                else if (sum === 4 && min === 1) kompetenzFaktor = 0.35;
                else if (sum === 3) kompetenzFaktor = 0.2;
                else kompetenzFaktor = 0.0;
            }

            // BedÃ¼rfnis-Matching berechnen - SchlÃ¼ssel unverÃ¤ndert (duo_flex bleibt duo_flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';

            let K1 = 0.5, K2 = 0.5, K3 = 0.5, K4 = 0.5;
            let matching = null;

            if (typeof GfkBeduerfnisse !== 'undefined' && ichArchetyp && partnerArchetyp) {
                matching = GfkBeduerfnisse.berechneMatching(ichArchetyp, partnerArchetyp);

                if (matching && !matching.fehler) {
                    K1 = calculateKSubfaktor('K1', matching);
                    K2 = calculateKSubfaktor('K2', matching);
                    K3 = calculateKSubfaktor('K3', matching);
                    K4 = calculateKSubfaktor('K4', matching);
                }
            }

            // Gesamt-K: Durchschnitt der 4 Subfaktoren, gewichtet mit Kompetenz
            // K = BedÃ¼rfnis-Match Ã— Kompetenz-Multiplikator
            const beduerfnisMatch = (K1 + K2 + K3 + K4) / 4;
            const K = beduerfnisMatch * (0.5 + kompetenzFaktor * 0.5);  // Kompetenz skaliert 0.5-1.0

            return {
                K: Math.round(K * 100) / 100,
                K1: Math.round(K1 * 100) / 100,
                K2: Math.round(K2 * 100) / 100,
                K3: Math.round(K3 * 100) / 100,
                K4: Math.round(K4 * 100) / 100,
                kompetenz: kompetenzFaktor,
                kompetenzLabel: ichGfk && partnerGfk ? `${ichGfk} + ${partnerGfk}` : 'nicht gesetzt',
                beduerfnisMatch: Math.round(beduerfnisMatch * 100) / 100
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SSOT v3.9: R-FAKTOREN HILFSFUNKTION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        /**
         * Berechnet R-Faktoren (R1-R4) aus Needs fÃ¼r eine Person
         * SSOT: Diese Funktion ist die einzige Quelle fÃ¼r Needs-basierte R-Faktoren
         *
         * @param {Object} personData - { archetyp, needs }
         * @param {Object} personData.needs - Die 220 BedÃ¼rfnis-Werte
         * @param {string} personData.archetyp - Archetyp der Person
         * @returns {Object|null} { R1, R2, R3, R4 } oder null wenn nicht berechenbar
         */
        function calculateRFactorsFromNeeds(personData) {
            if (!personData || !personData.needs) {
                return null;
            }

            // PrÃ¼fe ob TiageSynthesis verfÃ¼gbar ist
            if (typeof TiageSynthesis === 'undefined' ||
                !TiageSynthesis.NeedsIntegration ||
                typeof TiageSynthesis.NeedsIntegration.calculateDimensionalResonance !== 'function') {
                console.warn('[calculateRFactorsFromNeeds] TiageSynthesis nicht verfÃ¼gbar');
                return null;
            }

            try {
                const resonanz = TiageSynthesis.NeedsIntegration.calculateDimensionalResonance({
                    archetyp: personData.archetyp,
                    needs: personData.needs
                });

                if (!resonanz || !resonanz.enabled) {
                    return null;
                }

                // R1-R3 aus Needs, R4 benÃ¶tigt beide Personen (wird separat berechnet)
                return {
                    R1: resonanz.leben || resonanz.R1 || 1.0,
                    R2: resonanz.philosophie || resonanz.R2 || 1.0,
                    R3: resonanz.dynamik || resonanz.R3 || 1.0,
                    R4: 1.0  // R4 wird via calculateR4Hybrid berechnet (benÃ¶tigt beide Personen)
                };
            } catch (e) {
                console.warn('[calculateRFactorsFromNeeds] Fehler:', e);
                return null;
            }
        }

        // HAUPTBERECHNUNG: 5-Faktoren BeziehungsqualitÃ¤t (inkl. Resonanz)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Philosophische Grundlage: Tiage-Modell + MOQ (Pirsig) + OSHO
        //
        // GEWICHTUNG LOGOS vs. PATHOS (40:60)
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // Pirsig (MOQ): "QualitÃ¤t ist die Quelle von Subjekt und Objekt."
        //               Statische QualitÃ¤t (Logos) = Fundament, bewahrt Muster
        //               Dynamische QualitÃ¤t (Pathos) = Antrieb, erzeugt Anziehung
        //
        // OSHO: "Balance zwischen allen PolaritÃ¤ten ist Gesundheit."
        //       "GefÃ¼hl ist der Antrieb, Verstand gibt Struktur."
        //
        // Tiage: Verbindet rationale Reflexion (Logos) mit emotionaler
        //        Resonanz (Pathos) zu einem ganzheitlichen Modell.
        //
        // FAKTOR-BEGRÃœNDUNG:
        // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        // 1. Orientierung (40% - Pathos/GefÃ¼hl):
        //    â†’ KÃ¶rperliche AnziehungsmÃ¶glichkeit
        //    â†’ Dynamische QualitÃ¤t: PolaritÃ¤t der Begierde
        //    â†’ OSHO: "Extreme ziehen sich an"
        //    â†’ HÃ¶chste Gewichtung: Menschen erleben Beziehung zuerst kÃ¶rperlich
        //
        // 2. Archetyp (25% - Logos/Verstand):
        //    â†’ Fundamentale Beziehungsphilosophie
        //    â†’ Statische QualitÃ¤t: "Wie wollen wir Beziehung leben?"
        //    â†’ Die Archetyp-Frage stellt sich NACH den Pathos-Faktoren
        //
        // 3. Dominanz (20% - Pathos/GefÃ¼hl):
        //    â†’ Energetische Dynamik der Interaktion
        //    â†’ Dynamische QualitÃ¤t: FÃ¼hren/Folgen-Balance
        //    â†’ OSHO: "Tao - eine Energie, zwei Ausdrucksformen"
        //
        // 4. Geschlecht (15% - Pathos/GefÃ¼hl):
        //    â†’ Gender-Chemie als Feinabstimmung
        //    â†’ ErgÃ¤nzt Orientierung mit Nuancen (z.B. non-binÃ¤r)
        //    â†’ Niedrigste Gewichtung
        //
        // SUMME: Pathos 75% + Logos 25% = 100%
        // â†’ "Pathos vor Logos" - Das Erleben kommt vor der Interpretation
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        /**
         * Berechnet die BeziehungsqualitÃ¤t zwischen zwei Personen
         * SSOT v3.10: R-Faktoren werden IMMER aus Needs berechnet
         *
         * @param {Object} person1 - Profil Person 1 (mit .needs)
         * @param {Object} person2 - Profil Person 2 (mit .needs)
         * @param {Object} options - Optionale Einstellungen
         * @param {Object} options.rFaktoren - Explizit Ã¼bergebene R-Faktoren (nur fÃ¼r Best-Match mit fiktiven Partnern)
         */
        function calculateRelationshipQuality(person1, person2, options) {
            options = options || {};
            const explicitRFaktoren = options.rFaktoren || null;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // TIAGE RECHENMODELL v3.2 - Quadratische Resonanz mit KomplementÃ¤r-Mapping
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Formel: Score = (O Ã— wO Ã— R1) + (A Ã— wA Ã— R2) + (D Ã— wD Ã— R3) + (G Ã— wG Ã— R4)
            //
            // Ri = similarityÂ² (Range: 0 - 1)
            // â†’ 0% Match  = 0.0 (eliminiert Dimension)
            // â†’ 50% Match = 0.25 (stark reduziert)
            // â†’ 100% Match = 1.0 (neutral)

            const orientationScore = calculateOrientationScore(person1, person2);

            if (orientationScore === 0) {
                return {
                    score: 0,
                    blocked: true,
                    reason: "Keine kÃ¶rperliche Anziehung mÃ¶glich",
                    breakdown: {
                        archetyp: 0,
                        dominanz: 0,
                        orientierung: 0,
                        geschlecht: 0
                    },
                    resonanz: { R1: 0, R2: 0, R3: 0, R4: 0, GFK: 0 }
                };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SCHRITT 1: Basis-Faktoren (0-100)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const archetypeScore = getArchetypeScore(person1.archetyp, person2.archetyp);
            const dominanceScore = calculateDominanceHarmony(person1.dominanz, person2.dominanz);
            const genderScore = calculateGenderAttraction(person1, person2);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SCHRITT 2: Resonanz-Faktoren R1-R4 (0-1, v3.2 quadratisch)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SSOT v3.10: R-Faktoren werden IMMER aus Needs berechnet
            // Basierend auf 220 BedÃ¼rfnissen, aufgeteilt nach Faktor

            // SchlÃ¼ssel unverÃ¤ndert verwenden (duo_flex bleibt duo_flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';

            let R1 = 1.0, R2 = 1.0, R3 = 1.0, R4 = 1.0;  // Default: neutral
            let matching = null;
            let rFactorSource = 'default';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // v3.6: R-FAKTOREN AUS ECHTEN NEEDS (wenn verfÃ¼gbar)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Hilfsfunktion: Summe Ã— Similarity Kombination
            function combineRFactors(R_ich, R_partner) {
                const a = R_ich || 1.0;
                const b = R_partner || 1.0;
                const summe = a + b;
                const similarity = Math.min(a, b) / Math.max(a, b);
                // v3.7: Keine Obergrenze - R kann Ã¼ber 1.0 gehen fÃ¼r Score > 100
                const combined = (summe * similarity) / 2;
                return Math.round(combined * 1000) / 1000;
            }

            // Wenn echte Needs vorhanden sind, berechne R-Faktoren daraus
            if (person1.needs && person2.needs &&
                typeof TiageSynthesis !== 'undefined' &&
                TiageSynthesis.NeedsIntegration &&
                typeof TiageSynthesis.NeedsIntegration.calculateDimensionalResonance === 'function') {

                try {
                    // Berechne individuelle R-Faktoren
                    const resonanzIch = TiageSynthesis.NeedsIntegration.calculateDimensionalResonance({
                        archetyp: person1.archetyp,
                        needs: person1.needs
                    });
                    const resonanzPartner = TiageSynthesis.NeedsIntegration.calculateDimensionalResonance({
                        archetyp: person2.archetyp,
                        needs: person2.needs
                    });

                    if (resonanzIch && resonanzIch.enabled && resonanzPartner && resonanzPartner.enabled) {
                        // Kombiniere mit Summe Ã— Similarity (v3.6)
                        R1 = combineRFactors(resonanzIch.leben || resonanzIch.R1, resonanzPartner.leben || resonanzPartner.R1);
                        R2 = combineRFactors(resonanzIch.philosophie || resonanzIch.R2, resonanzPartner.philosophie || resonanzPartner.R2);
                        R3 = combineRFactors(resonanzIch.dynamik || resonanzIch.R3, resonanzPartner.dynamik || resonanzPartner.R3);
                        // R4 wird weiterhin via calculateR4Hybrid berechnet

                        rFactorSource = 'realNeeds';
                        console.log('[calculateRelationshipQuality] R1-R3 aus ECHTEN NEEDS berechnet:', {
                            R1, R2, R3,
                            resonanzIch: { R1: resonanzIch.leben || resonanzIch.R1, R2: resonanzIch.philosophie || resonanzIch.R2, R3: resonanzIch.dynamik || resonanzIch.R3 },
                            resonanzPartner: { R1: resonanzPartner.leben || resonanzPartner.R1, R2: resonanzPartner.philosophie || resonanzPartner.R2, R3: resonanzPartner.dynamik || resonanzPartner.R3 }
                        });
                    }
                } catch (e) {
                    console.warn('[calculateRelationshipQuality] Fehler bei R-Faktor-Berechnung aus Needs:', e);
                }
            }

            // NO FALLBACK: R1-R3 bleiben bei 1.0 wenn keine echten Needs verfÃ¼gbar
            // Die UI zeigt eine Warnung an, wenn rFactorSource === 'default'

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // R4 HYBRID: IdentitÃ¤t + Bidirektionale Attraktion
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // v3.2: R4 = (identity Ã— 0.30 + attraction Ã— 0.70)Â² / 10000
            // - IdentitÃ¤t: Cisâ†”Cis, Transâ†”Trans Resonanz (30%)
            // - Attraktion: Bidirektional mit P/S Gewichtung (70%)
            const r4Result = calculateR4Hybrid(person1, person2);
            R4 = r4Result.R4;
            console.log('[calculateRelationshipQuality] R4 HYBRID berechnet:', {
                R4,
                identityScore: r4Result.identityScore,
                attractionScore: r4Result.attractionScore,
                attraction1to2: r4Result.attractionDetails?.direction1to2,
                attraction2to1: r4Result.attractionDetails?.direction2to1
            });

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SSOT v3.10: R-FAKTOREN NUR AUS NEEDS
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PrioritÃ¤t 1: Explizit Ã¼bergebene rFaktoren (NUR fÃ¼r Best-Match mit fiktiven Partnern)
            // PrioritÃ¤t 2: Aus Needs berechnet (bereits oben geschehen)
            // PrioritÃ¤t 3: Default 1.0 (wenn keine Needs verfÃ¼gbar)
            //
            // KEIN ResonanzCard-Override mehr! R-Faktoren = f(Needs), immer.

            if (explicitRFaktoren && explicitRFaktoren.ich && explicitRFaktoren.partner) {
                // Best-Match: Explizit Ã¼bergebene R-Faktoren fÃ¼r fiktive Partner
                const getR = (obj, key) => (obj && obj[key] !== undefined) ? obj[key] : 1.0;

                R1 = combineRFactors(getR(explicitRFaktoren.ich, 'R1'), getR(explicitRFaktoren.partner, 'R1'));
                R2 = combineRFactors(getR(explicitRFaktoren.ich, 'R2'), getR(explicitRFaktoren.partner, 'R2'));
                R3 = combineRFactors(getR(explicitRFaktoren.ich, 'R3'), getR(explicitRFaktoren.partner, 'R3'));
                R4 = combineRFactors(getR(explicitRFaktoren.ich, 'R4'), getR(explicitRFaktoren.partner, 'R4'));

                rFactorSource = 'explicit';
                console.log('[calculateRelationshipQuality] SSOT: R-Faktoren EXPLIZIT fÃ¼r fiktiven Partner:', {
                    ich: explicitRFaktoren.ich,
                    partner: explicitRFaktoren.partner,
                    combined: { R1, R2, R3, R4 }
                });
            }
            // Sonst: R1-R4 bleiben bei den aus Needs berechneten Werten (oder Default 1.0)

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SCHRITT 3: Score-Berechnung mit Resonanz
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Score = (O Ã— wO Ã— R1) + (A Ã— wA Ã— R2) + (D Ã— wD Ã— R3) + (G Ã— wG Ã— R4)
            // SSOT: TiageState ist Single Source of Truth fÃ¼r Gewichtungen

            // Gewichte aus TiageState laden (SSOT)
            let gew = { O: 25, A: 25, D: 25, G: 25 };
            try {
                if (typeof TiageState !== 'undefined') {
                    const stored = TiageState.get('gewichtungen.ich');
                    if (stored && stored.O && typeof stored.O.value === 'number') {
                        gew = {
                            O: stored.O.value,
                            A: stored.A.value,
                            D: stored.D.value,
                            G: stored.G.value
                        };
                    }
                }
                // Fallback: GewichtungCard
                if (gew.O === 25 && gew.A === 25 && gew.D === 25 && gew.G === 25) {
                    if (typeof getGewichtungen === 'function') {
                        gew = getGewichtungen();
                    }
                }
            } catch (e) {
                if (typeof getGewichtungen === 'function') {
                    gew = getGewichtungen();
                }
            }
            // Normalisiere auf 100%
            // FIX: typeof check statt || operator, damit 0 korrekt als 0 behandelt wird
            const gewSum = (gew.O || 0) + (gew.A || 0) + (gew.D || 0) + (gew.G || 0);
            const gewDivisor = gewSum > 0 ? gewSum : 100;
            const wO = (typeof gew.O === 'number' ? gew.O : 25) / gewDivisor;
            const wA = (typeof gew.A === 'number' ? gew.A : 25) / gewDivisor;
            const wD = (typeof gew.D === 'number' ? gew.D : 25) / gewDivisor;
            const wG = (typeof gew.G === 'number' ? gew.G : 25) / gewDivisor;

            const scoreO = orientationScore * wO * R1;
            const scoreA = archetypeScore * wA * R2;
            const scoreD = dominanceScore * wD * R3;
            const scoreG = genderScore * wG * R4;

            const totalScore = scoreO + scoreA + scoreD + scoreG;

            // GFK-Kompetenz = Durchschnitt R1-R4
            const GFK = (R1 + R2 + R3 + R4) / 4;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SCHRITT 4: Meta-Faktoren (fÃ¼r UI)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const M = calculateProfilMatch(person1, person2);
            const B = calculateLogosPathosBalance(archetypeScore, orientationScore, dominanceScore, genderScore);

            // Logos/Pathos Breakdown fÃ¼r UI
            const logos = archetypeScore;
            const pathos = (orientationScore + dominanceScore + genderScore) / 3;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SSOT-VERGLEICH (async, blockiert nicht)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const result = {
                score: Math.round(totalScore * 10) / 10,  // Eine Dezimalstelle
                blocked: false,
                noRealNeeds: rFactorSource === 'default',  // Flag fÃ¼r UI-Warnung
                breakdown: {
                    archetyp: archetypeScore,
                    dominanz: dominanceScore,
                    orientierung: orientationScore,
                    geschlecht: genderScore
                },
                resonanz: {
                    R1: Math.round(R1 * 100) / 100,
                    R2: Math.round(R2 * 100) / 100,
                    R3: Math.round(R3 * 100) / 100,
                    R4: Math.round(R4 * 100) / 100,
                    GFK: Math.round(GFK * 100) / 100,
                    M: M,
                    B: Math.round(B * 100) / 100
                },
                scoreDetails: {
                    O: Math.round(scoreO * 10) / 10,
                    A: Math.round(scoreA * 10) / 10,
                    D: Math.round(scoreD * 10) / 10,
                    G: Math.round(scoreG * 10) / 10
                },
                gewichtungen: {
                    O: gew.O,
                    A: gew.A,
                    D: gew.D,
                    G: gew.G
                },
                logos: logos,
                pathos: pathos
            };

            // SSOT-Vergleich im Hintergrund (wenn aktiviert)
            if (typeof SSOTComparison !== 'undefined' && SSOTComparison.isEnabled()) {
                SSOTComparison.compare(result, person1, person2, options).catch(function(e) {
                    console.warn('[SSOT] Vergleich fehlgeschlagen:', e.message);
                });
            }

            return result;
        }

        // Calculate overall with 4-factor model + category details for UI
        // SSOT v3.10: R-Faktoren werden IMMER aus person.needs berechnet
        function calculateOverallWithModifiers(person1, person2, pathosCheck, logosCheck, options) {
            // Use new 4-factor model for overall score
            const qualityResult = calculateRelationshipQuality(person1, person2, options);

            // Calculate category scores for UI display (radar chart, category bars)
            const categories = {};

            // Category A: Philosophy score from matrix
            categories.A = { score: logosCheck.score, modifier: 0, note: "Rein archetyp-basiert" };

            // Other categories with modifiers (for UI display)
            for (const cat of ['B', 'C', 'D', 'E', 'F']) {
                const result = calculateCategoryWithModifiers(cat, person1, person2, pathosCheck);
                categories[cat] = result;
            }

            return {
                overall: qualityResult.score,  // NEW: 4-factor score
                categories,                     // Keep for UI
                breakdown: qualityResult.breakdown  // NEW: factor breakdown
            };
        }

        // Get modifier summary for UI
        function getModifierSummary(person1, person2) {
            const summaries = [];
            const domMod = getDominanzModifier(person1.dominanz, person2.dominanz);
            if (domMod !== 0) {
                summaries.push({
                    type: "Dominanz",
                    modifier: domMod,
                    description: getDominanzDescription(person1.dominanz, person2.dominanz, domMod)
                });
            }
            return summaries;
        }

        // ========================================
        // NEW: Side-by-Side Comparison Functions
        // ========================================

        // Navigate through archetypes with forward/backward buttons
        function navigateArchetype(person, direction) {
            const selectId = person === 'ich' ? 'ichSelect' : 'partnerSelect';
            const mobileSelectId = person === 'ich' ? 'mobileIchSelect' : 'mobilePartnerSelect';
            const select = document.getElementById(selectId);
            const mobileSelect = document.getElementById(mobileSelectId);

            // Use whichever select is visible/available
            const activeSelect = select || mobileSelect;
            if (!activeSelect) return;

            const currentIndex = activeSelect.selectedIndex;
            const optionsCount = activeSelect.options.length;
            let newIndex = currentIndex + direction;

            // Wrap around
            if (newIndex < 0) newIndex = optionsCount - 1;
            if (newIndex >= optionsCount) newIndex = 0;

            // Update both desktop and mobile selects
            if (select) select.selectedIndex = newIndex;
            if (mobileSelect) mobileSelect.selectedIndex = newIndex;

            // Update global state variables
            const newValue = activeSelect.options[newIndex].value;
            if (person === 'ich') {
                currentArchetype = newValue;
                mobileIchArchetype = newValue;
            } else {
                selectedPartner = newValue;
                mobilePartnerArchetype = newValue;
            }

            // Sync with TiageState for persistence (WICHTIG: Sofort speichern!)
            if (typeof TiageState !== 'undefined') {
                TiageState.setArchetype(person, newValue);
            }

            // Trigger change event on the active select
            activeSelect.dispatchEvent(new Event('change'));

            // Update archetype grid
            updateArchetypeGrid(person, newValue);
        }

        // Function to select archetype from grid click
        function selectArchetypeFromGrid(person, archetype) {
            console.log('[selectArchetypeFromGrid] Aufgerufen fÃ¼r:', person, 'archetype:', archetype);

            const selectId = person === 'ich' ? 'ichSelect' : 'partnerSelect';
            const mobileSelectId = person === 'ich' ? 'mobileIchSelect' : 'mobilePartnerSelect';
            const select = document.getElementById(selectId);
            const mobileSelect = document.getElementById(mobileSelectId);

            // Update select elements
            if (select) {
                for (let i = 0; i < select.options.length; i++) {
                    if (select.options[i].value === archetype) {
                        select.selectedIndex = i;
                        break;
                    }
                }
            }
            if (mobileSelect) {
                for (let i = 0; i < mobileSelect.options.length; i++) {
                    if (mobileSelect.options[i].value === archetype) {
                        mobileSelect.selectedIndex = i;
                        break;
                    }
                }
            }

            // Update global state variables
            if (person === 'ich') {
                currentArchetype = archetype;
                mobileIchArchetype = archetype;
            } else {
                selectedPartner = archetype;
                mobilePartnerArchetype = archetype;
            }

            // Sync with TiageState for persistence
            // SSOT: setArchetype() lÃ¶st synchron die Subscriber aus, die
            // flatNeeds UND Resonanzfaktoren automatisch neu berechnen
            if (typeof TiageState !== 'undefined') {
                TiageState.setArchetype(person, archetype);
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // SSOT: Berechne flatNeeds + Resonanzfaktoren bei Archetyp-Wechsel
            // ProfileCalculator.loadProfile() schreibt direkt in TiageState
            // WICHTIG: Muss VOR updateComparisonView() aufgerufen werden!
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                const profileData = {
                    archetyp: archetype,
                    geschlecht: TiageState.get(`personDimensions.${person}.geschlecht`),
                    dominanz: TiageState.get(`personDimensions.${person}.dominanz`),
                    orientierung: TiageState.get(`personDimensions.${person}.orientierung`)
                };
                ProfileCalculator.loadProfile(person, profileData);
                console.log(`[selectArchetypeFromGrid] Profil fÃ¼r ${person.toUpperCase()} neu berechnet:`, archetype);
            }

            // Update archetype grid highlighting
            updateArchetypeGrid(person, archetype);

            // Trigger change event - use bubbles: true to ensure it propagates
            const activeSelect = select || mobileSelect;
            if (activeSelect) {
                activeSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }

            // Update comparison view directly to ensure UI updates even without change event
            if (typeof updateComparisonView === 'function') {
                updateComparisonView();
            }

            // Update GFK from archetypes
            if (typeof updateGfkFromArchetypes === 'function') {
                updateGfkFromArchetypes();
            }

            console.log('[selectArchetypeFromGrid] Abgeschlossen fÃ¼r:', person, 'archetype:', archetype);
        }

        // Function to update archetype grid highlighting
        function updateArchetypeGrid(person, archetype) {
            // Desktop grid IDs
            const gridId = person === 'ich' ? 'ich-archetype-grid' : 'partner-archetype-grid';
            // Mobile grid IDs
            const mobileGridId = person === 'ich' ? 'mobile-ich-archetype-grid' : 'mobile-partner-archetype-grid';

            // Update all grids (desktop and mobile)
            [gridId, mobileGridId].forEach(id => {
                const grid = document.getElementById(id);
                if (!grid) return;

                // Remove active class from all items
                grid.querySelectorAll('.archetype-symbol-item').forEach(item => {
                    item.classList.remove('active');
                });

                // Add active class to selected item
                const selectedItem = grid.querySelector(`.archetype-symbol-item[data-archetype="${archetype}"]`);
                if (selectedItem) {
                    selectedItem.classList.add('active');
                }
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BEST MATCH FINDER - Findet den besten Partner-Archetyp
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        /**
         * Berechnet und wÃ¤hlt automatisch den besten Partner-Archetyp
         * basierend auf den aktuellen ICH-Einstellungen (Archetyp, Dimensionen, Gewichtungen)
         *
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * TIAGE SYNTHESE v3.1 FORMEL
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * Basis-Formel:
         *   Q = [(A Ã— wâ‚) + (O Ã— wâ‚’) + (D Ã— wáµˆ) + (G Ã— wáµ)] Ã— R
         *
         * Gewichtungen (constants.js):
         *   A (Archetyp/LOGOS)    = 15%  - Beziehungsphilosophie
         *   O (Orientierung)      = 40%  - Sexuelle Orientierung
         *   D (Dominanz)          = 20%  - Dom/Sub/Switch Dynamik
         *   G (Geschlecht)        = 25%  - Gender-Attraktion
         *
         * v3.1 Dimensionale Resonanz (wenn BedÃ¼rfnis-Profile vorhanden):
         *   Q = (A Ã— wâ‚ Ã— R_Philosophie) +
         *       (O Ã— wâ‚’ Ã— R_Leben) +
         *       (D Ã— wáµˆ Ã— R_Dynamik) +
         *       (G Ã— wáµ Ã— R_IdentitÃ¤t)
         *
         * Wobei R_dim = 0.9 + (BedÃ¼rfnis-Match Ã— 0.2), also 0.9-1.1
         *
         * Fallback (ohne Profile): Q = baseScore Ã— R_gesamt
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */
        // Hilfsfunktion: Stellt sicher, dass Geschlechts-Objekt valide Werte hat
        function ensureValidGeschlecht(geschlechtObj) {
            const g = geschlechtObj || {};
            return {
                primary: g.primary || 'mann',      // Default: mann
                secondary: g.secondary || 'cis'    // Default: cis
            };
        }

        // Hilfsfunktion: Stellt sicher, dass Dominanz-Objekt valide Werte hat
        function ensureValidDominanz(dominanzObj) {
            const d = dominanzObj || {};
            return {
                primary: d.primary || 'ausgeglichen',
                secondary: d.secondary || null
            };
        }

        // Hilfsfunktion: Stellt sicher, dass Orientierungs-Objekt valide Werte hat
        function ensureValidOrientierung(orientierungObj) {
            const o = orientierungObj || {};
            return {
                primary: o.primary || 'heterosexuell',
                secondary: o.secondary || null
            };
        }

        function findBestPartnerMatch() {
            console.log('[findBestPartnerMatch] Funktion aufgerufen');
            console.log('[findBestPartnerMatch] data geladen:', data !== null);
            console.log('[findBestPartnerMatch] personDimensions:', JSON.stringify(personDimensions));

            // PrÃ¼fe, ob data geladen ist
            if (!data) {
                console.warn('[findBestPartnerMatch] WARNUNG: data ist nicht geladen! Verwende Fallback-Matrix.');
            }

            const ALL_ARCHETYPES = ['single', 'duo', 'duo_flex', 'ra', 'lat', 'aromantisch', 'solopoly', 'polyamor'];

            // v3.6: Hole echte Needs aus TiageState fÃ¼r R-Faktor-Berechnung
            let ichNeeds = null;
            let partnerNeeds = null;
            if (typeof TiageState !== 'undefined') {
                ichNeeds = TiageState.get('flatNeeds.ich');
                partnerNeeds = TiageState.get('flatNeeds.partner');
                console.log('[findBestPartnerMatch] Echte Needs geladen:', {
                    ichNeeds: ichNeeds ? Object.keys(ichNeeds).length : 0,
                    partnerNeeds: partnerNeeds ? Object.keys(partnerNeeds).length : 0
                });
            }

            // Sammle ICH-Daten (feste Basis)
            const ichArchetype = currentArchetype || 'single';
            const ichDims = personDimensions.ich || {};

            console.log('[findBestPartnerMatch] currentArchetype:', currentArchetype, '-> verwendet:', ichArchetype);

            // Sammle Partner-Dimensionen (fÃ¼r die Berechnung)
            const partnerDims = personDimensions.partner || {};

            // Validierte Dimensionen mit Defaults fÃ¼r fehlende Werte
            const validIchGeschlecht = ensureValidGeschlecht(ichDims.geschlecht);
            const validIchDominanz = ensureValidDominanz(ichDims.dominanz);
            const validIchOrientierung = ensureValidOrientierung(ichDims.orientierung);

            // BUGFIX: Wenn Partner-Dimensionen fehlen, verwende kompatible Defaults
            // statt feste Defaults die mÃ¶glicherweise inkompatibel sind
            const partnerHasGeschlecht = partnerDims.geschlecht && partnerDims.geschlecht.primary;
            const partnerHasOrientierung = partnerDims.orientierung && partnerDims.orientierung.primary;

            let validPartnerGeschlecht;
            if (partnerHasGeschlecht) {
                validPartnerGeschlecht = ensureValidGeschlecht(partnerDims.geschlecht);
            } else {
                // Setze kompatibles Geschlecht basierend auf ICH-Orientierung
                const ichOriPrimary = validIchOrientierung.primary;
                const ichGeschPrimary = validIchGeschlecht.primary;
                if (ichOriPrimary === 'heterosexuell') {
                    // Heterosexuell: Partner sollte anderes Geschlecht haben
                    validPartnerGeschlecht = {
                        primary: ichGeschPrimary === 'mann' ? 'frau' : 'mann',
                        secondary: 'cis'
                    };
                } else {
                    // Homosexuell/bi-pansexuell: Gleiches Geschlecht ist kompatibel
                    validPartnerGeschlecht = {
                        primary: ichGeschPrimary,
                        secondary: 'cis'
                    };
                }
                console.log('[findBestPartnerMatch] Partner-Geschlecht nicht gesetzt, verwende kompatiblen Default:', validPartnerGeschlecht);
            }

            let validPartnerOrientierung;
            if (partnerHasOrientierung) {
                validPartnerOrientierung = ensureValidOrientierung(partnerDims.orientierung);
            } else {
                // Setze kompatible Orientierung basierend auf ICH
                validPartnerOrientierung = {
                    primary: validIchOrientierung.primary,
                    secondary: validIchOrientierung.secondary
                };
                console.log('[findBestPartnerMatch] Partner-Orientierung nicht gesetzt, verwende ICH-Orientierung:', validPartnerOrientierung);
            }

            // FEATURE: Dominanz-Auto-Korrelation - komplementÃ¤re Dominanz fÃ¼r beste KompatibilitÃ¤t
            const partnerHasDominanz = partnerDims.dominanz && partnerDims.dominanz.primary;
            let validPartnerDominanz;
            if (partnerHasDominanz) {
                validPartnerDominanz = ensureValidDominanz(partnerDims.dominanz);
            } else {
                // Setze komplementÃ¤re Dominanz basierend auf ICH fÃ¼r maximalen Modifier (+8)
                const ichDomPrimary = validIchDominanz.primary;
                if (ichDomPrimary === 'dominant') {
                    // dominant + submissiv = +8 Modifier (beste Kombination)
                    validPartnerDominanz = { primary: 'submissiv', secondary: null };
                } else if (ichDomPrimary === 'submissiv') {
                    // submissiv + dominant = +8 Modifier (beste Kombination)
                    validPartnerDominanz = { primary: 'dominant', secondary: null };
                } else if (ichDomPrimary === 'switch') {
                    // switch + switch = +3 Modifier
                    validPartnerDominanz = { primary: 'switch', secondary: null };
                } else {
                    // ausgeglichen + ausgeglichen = +5 Modifier
                    validPartnerDominanz = { primary: 'ausgeglichen', secondary: null };
                }
                console.log('[findBestPartnerMatch] Partner-Dominanz nicht gesetzt, verwende komplementÃ¤ren Default:', validPartnerDominanz);
            }

            // FEATURE: GFK-Auto-Korrelation - gleiche oder hÃ¶here GFK-Kompetenz
            const partnerHasGfk = partnerDims.gfk && partnerDims.gfk !== '';
            let validPartnerGfk;
            if (partnerHasGfk) {
                validPartnerGfk = partnerDims.gfk;
            } else {
                // Setze GFK basierend auf ICH - gleich oder hÃ¶her fÃ¼r beste KompatibilitÃ¤t
                const ichGfk = ichDims.gfk || 'mittel';
                // hoch-hoch = 100, mittel-mittel = 65, niedrig-niedrig = 25
                // FÃ¼r beste KompatibilitÃ¤t: Gleiche Stufe oder hÃ¶her
                if (ichGfk === 'hoch') {
                    validPartnerGfk = 'hoch'; // hoch-hoch = 100
                } else if (ichGfk === 'mittel') {
                    validPartnerGfk = 'hoch'; // mittel-hoch = 75 (besser als mittel-mittel = 65)
                } else {
                    validPartnerGfk = 'mittel'; // niedrig-mittel = 45 (besser als niedrig-niedrig = 25)
                }
                console.log('[findBestPartnerMatch] Partner-GFK nicht gesetzt, verwende optimalen Default:', validPartnerGfk);
            }

            console.log('[findBestPartnerMatch] Validierte ICH-Dimensionen:', {
                geschlecht: validIchGeschlecht,
                dominanz: validIchDominanz,
                orientierung: validIchOrientierung,
                gfk: ichDims.gfk || 'mittel'
            });
            console.log('[findBestPartnerMatch] Validierte Partner-Dimensionen:', {
                geschlecht: validPartnerGeschlecht,
                dominanz: validPartnerDominanz,
                orientierung: validPartnerOrientierung,
                gfk: validPartnerGfk
            });

            let bestMatch = null;
            let bestScore = -1;
            const results = [];

            // Berechne Score fÃ¼r jeden mÃ¶glichen Partner-Archetyp
            for (const partnerArch of ALL_ARCHETYPES) {
                try {
                    // Erstelle temporÃ¤re Person-Objekte fÃ¼r die Berechnung
                    // Person1 = ICH (die festen Einstellungen)
                    const person1 = {
                        archetyp: ichArchetype,
                        dominanz: validIchDominanz,
                        geschlecht: validIchGeschlecht,
                        orientierung: validIchOrientierung,
                        gfk: ichDims.gfk || 'mittel',
                        needs: ichNeeds  // v3.6: Echte Needs fÃ¼r R-Faktor-Berechnung
                    };

                    // Person2 = PARTNER (der Archetyp, der getestet wird)
                    const person2 = {
                        archetyp: partnerArch,
                        dominanz: validPartnerDominanz,
                        geschlecht: validPartnerGeschlecht,
                        orientierung: validPartnerOrientierung,
                        gfk: validPartnerGfk,
                        needs: partnerNeeds  // v3.6: Echte Needs fÃ¼r R-Faktor-Berechnung
                    };

                    let score = 0;

                    // WICHTIG: Verwende dieselbe Berechnung wie updateComparisonView()
                    // um konsistente Scores zu erhalten

                    // TemporÃ¤r globale Variablen setzen fÃ¼r calculateRelationshipQuality
                    const savedCurrentArchetype = currentArchetype;
                    const savedSelectedPartner = selectedPartner;
                    currentArchetype = ichArchetype;
                    selectedPartner = partnerArch;

                    try {
                        const pathosCheck = checkPhysicalCompatibility(person1, person2);
                        const logosCheck = calculatePhilosophyCompatibility(ichArchetype, partnerArch);

                        if (pathosCheck.result !== 'unmÃ¶glich' && pathosCheck.result !== 'unvollstÃ¤ndig') {
                            // SSOT v3.10: R-Faktoren aus person.needs
                            const result = calculateOverallWithModifiers(person1, person2, pathosCheck, logosCheck);
                            let baseScore = result.overall || 0;

                            // SSOT v3.7: Konfidenz-Multiplikator anwenden
                            const confidenceMultiplier = getConfidenceMultiplier(pathosCheck.confidence);
                            score = Math.round(baseScore * confidenceMultiplier * 10) / 10;
                        } else if (pathosCheck.result === 'unvollstÃ¤ndig') {
                            // Bei unvollstÃ¤ndigen Dimensionen: Fallback auf Archetyp-Matrix
                            const logosScore = logosCheck.score || 50;
                            score = logosScore;
                        }
                        // Bei 'unmÃ¶glich': score bleibt 0
                    } finally {
                        // Globale Variablen wiederherstellen
                        currentArchetype = savedCurrentArchetype;
                        selectedPartner = savedSelectedPartner;
                    }

                    results.push({ archetype: partnerArch, score: score });

                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = partnerArch;
                    }
                } catch (e) {
                    console.warn(`[findBestPartnerMatch] Fehler bei der Berechnung fÃ¼r ${partnerArch}:`, e);
                }
            }

            // Sortiere Ergebnisse nach Score
            results.sort((a, b) => b.score - a.score);
            console.log('[findBestPartnerMatch] ICH:', ichArchetype);
            console.log('[findBestPartnerMatch] Ranking:', results);

            // WÃ¤hle den besten Match aus, der NICHT derselbe Archetyp wie ICH ist
            // (nÃ¤chstbester statt identischer Archetyp)
            const bestDifferentMatch = results.find(r => r.archetype !== ichArchetype);
            if (bestDifferentMatch) {
                bestMatch = bestDifferentMatch.archetype;
                bestScore = bestDifferentMatch.score;
            }

            console.log('[findBestPartnerMatch] Bester Match (â‰  ICH):', bestMatch, 'mit Score:', bestScore);

            // WÃ¤hle den besten Match aus
            if (bestMatch) {
                selectArchetypeFromGrid('partner', bestMatch);

                // Zeige kurze Feedback-Animation auf dem Button
                const matchBtns = document.querySelectorAll('.best-match-btn');
                matchBtns.forEach(btn => {
                    btn.classList.add('match-found');
                    setTimeout(() => btn.classList.remove('match-found'), 1000);
                });
            }

            return { bestMatch, bestScore, results };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SLOT MACHINE - FINDE PASSENDEN PARTNER (ALLE KOMBINATIONEN)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Iteriert durch ALLE mÃ¶glichen Kombinationen (A, G, O, D) und findet
        // die beste Kombination basierend auf dem aktuellen ICH-Profil.
        // Bei Score-Gleichstand wird Bindungsmuster als Tie-Breaker verwendet.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Globale Variablen fÃ¼r Slot Machine
        let slotMachineResult = null;
        let slotMachineTop4Results = []; // Top 4 Ergebnisse
        let slotMachineTop10Results = []; // NEU: Top 10 Ergebnisse fÃ¼r erweiterte Ansicht
        let slotMachineExpanded = false; // NEU: Zustand der erweiterten Ansicht
        let slotMachineBindung = { primary: null, secondary: null };

        // Bindungsmuster PrÃ¤ferenzen fÃ¼r Tie-Breaker
        const BINDUNGSMUSTER_PRAEFERENZEN = {
            sicher: {
                archetypen: ['duo', 'duo_flex', 'lat', 'polyamor', 'solopoly', 'ra', 'single', 'aromantisch'],
                dominanz: ['ausgeglichen', 'switch', 'dominant', 'submissiv']
            },
            aengstlich: {
                archetypen: ['duo', 'duo_flex', 'lat', 'polyamor', 'solopoly', 'single', 'ra', 'aromantisch'],
                dominanz: ['submissiv', 'ausgeglichen', 'switch', 'dominant']
            },
            vermeidend: {
                archetypen: ['lat', 'single', 'solopoly', 'ra', 'aromantisch', 'duo_flex', 'duo', 'polyamor'],
                dominanz: ['ausgeglichen', 'dominant', 'switch', 'submissiv']
            },
            desorganisiert: {
                archetypen: ['duo_flex', 'ra', 'polyamor', 'lat', 'duo', 'solopoly', 'single', 'aromantisch'],
                dominanz: ['switch', 'ausgeglichen', 'dominant', 'submissiv']
            }
        };

        // Alle mÃ¶glichen Werte
        const ALL_ARCHETYPES_SLOT = ['single', 'duo', 'duo_flex', 'ra', 'lat', 'aromantisch', 'solopoly', 'polyamor'];
        const ALL_GESCHLECHT_COMBINATIONS = [
            { primary: 'mann', secondary: 'cis' },
            { primary: 'mann', secondary: 'trans' },
            { primary: 'mann', secondary: 'nonbinaer' },
            { primary: 'frau', secondary: 'cis' },
            { primary: 'frau', secondary: 'trans' },
            { primary: 'frau', secondary: 'nonbinaer' },
            { primary: 'inter', secondary: 'nonbinaer' },
            { primary: 'inter', secondary: 'fluid' },
            { primary: 'inter', secondary: 'suchend' }
        ];
        // v2.0: Neue Orientierungs-Struktur: hetero, bihomo, pan
        const ALL_ORIENTIERUNGEN = ['heterosexuell', 'bihomo', 'pansexuell'];
        const ALL_DOMINANZEN = ['dominant', 'submissiv', 'switch', 'ausgeglichen'];

        // Labels fÃ¼r die Anzeige
        const ARCHETYP_LABELS = {
            'single': 'Single', 'duo': 'Duo', 'duo_flex': 'Duo-Flex', 'ra': 'RA',
            'lat': 'LAT', 'aromantisch': 'Aromantisch', 'solopoly': 'Solopoly', 'polyamor': 'Polyamor'
        };
        const GESCHLECHT_LABELS = {
            'mann': 'Mann', 'frau': 'Frau', 'inter': 'Inter',
            'cis': 'Cis', 'trans': 'Trans', 'nonbinaer': 'NB', 'fluid': 'Fluid', 'suchend': 'Such.'
        };
        // v2.0: Neue Labels
        const ORIENTIERUNG_LABELS = {
            'heterosexuell': 'Hetero', 'bihomo': 'Bi/Homo', 'pansexuell': 'Pan',
            // LEGACY
            'homosexuell': 'Bi/Homo', 'bisexuell': 'Bi/Homo'
        };
        const DOMINANZ_LABELS = {
            'dominant': 'Dom', 'submissiv': 'Sub', 'switch': 'Switch', 'ausgeglichen': 'Ausg.'
        };

        /**
         * Ã–ffnet das Slot Machine Modal
         */
        function openSlotMachineModal() {
            const modal = document.getElementById('slotMachineModal');
            if (modal) {
                modal.style.display = 'flex';
                resetSlotMachine();
                // Lade gespeicherte Bindungsmuster aus TiageState
                if (typeof TiageState !== 'undefined') {
                    const saved = TiageState.get('bindungsmuster.ich');
                    if (saved && saved.primary) {
                        slotMachineBindung.primary = saved.primary;
                        slotMachineBindung.secondary = saved.secondary;
                        updateBindungsmusterUI();
                        checkStartButtonState();
                    }
                }
            }
        }
        window.openSlotMachineModal = openSlotMachineModal;

        /**
         * SchlieÃŸt das Slot Machine Modal
         */
        function closeSlotMachineModal(event) {
            if (event && event.target !== event.currentTarget) return;
            const modal = document.getElementById('slotMachineModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        window.closeSlotMachineModal = closeSlotMachineModal;

        /**
         * SchlieÃŸt Modal und Ã¶ffnet die ICH-Attribute Seite
         */
        function goToIchAttributes() {
            // Modal schlieÃŸen
            closeSlotMachineModal();
            resetSlotMachine();

            // Direkt die Attribute-Seite fÃ¼r ICH Ã¶ffnen (wie der lila ATTRIBUTE Button)
            const ichArchetyp = getSelectedArchetype ? getSelectedArchetype('ich') : (currentArchetype || 'single');
            if (typeof openNeedsEditorPage === 'function') {
                openNeedsEditorPage(ichArchetyp, 'ich');
            }
        }
        window.goToIchAttributes = goToIchAttributes;

        /**
         * Setzt das Modal zurÃ¼ck auf Phase 1
         */
        function resetSlotMachine() {
            document.getElementById('slotPhase1').style.display = 'block';
            document.getElementById('slotPhase2').style.display = 'none';
            document.getElementById('slotPhase3').style.display = 'none';
            slotMachineResult = null;
            slotMachineTop4Results = [];
            slotMachineTop10Results = []; // NEU: Top 10 zurÃ¼cksetzen
            slotMachineExpanded = false; // NEU: Expanded-Zustand zurÃ¼cksetzen
            // Bindungsmuster nicht zurÃ¼cksetzen - die bleiben erhalten
            updateBindungsmusterUI();
            checkStartButtonState();
        }
        window.resetSlotMachine = resetSlotMachine;

        /**
         * Aktualisiert die Bindungsmuster-Buttons UI
         */
        function updateBindungsmusterUI() {
            // Primary Buttons
            document.querySelectorAll('#bindungPrimaryOptions .bindung-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.value === slotMachineBindung.primary);
            });
            // Secondary Buttons
            document.querySelectorAll('#bindungSecondaryOptions .bindung-btn').forEach(btn => {
                btn.classList.toggle('selected', btn.dataset.value === slotMachineBindung.secondary);
            });
        }

        /**
         * Zeigt den Bindungsmuster-Tooltip fÃ¼r 2 Sekunden
         */
        let bindungTooltipTimeout = null;
        function showBindungTooltip(type, value) {
            const tooltip = document.getElementById('bindungTooltip');
            const iconEl = document.getElementById('bindungTooltipIcon');
            const titleEl = document.getElementById('bindungTooltipTitle');
            const textEl = document.getElementById('bindungTooltipText');

            if (!tooltip) return;

            // Tooltip-Inhalte basierend auf Typ und Wert
            const tooltipData = {
                primary: {
                    sicher: { icon: 'ğŸ›¡ï¸', title: 'Sicher', text: 'Du fÃ¼hlst dich meistens wohl mit NÃ¤he und kannst gut Grenzen setzen' },
                    aengstlich: { icon: 'ğŸ’”', title: 'Ã„ngstlich', text: 'Du suchst meistens viel NÃ¤he und hast oft Angst, verlassen zu werden' },
                    vermeidend: { icon: 'ğŸšª', title: 'Vermeidend', text: 'Du hÃ¤ltst meistens emotionale Distanz und brauchst viel Freiraum' },
                    desorganisiert: { icon: 'ğŸŒ€', title: 'Desorganisiert', text: 'Du schwankst meistens zwischen Sehnsucht nach NÃ¤he und dem Drang zu fliehen' }
                },
                secondary: {
                    sicher: { icon: 'ğŸ›¡ï¸', title: 'Sicher (Stress)', text: 'Im Stress bleibst du gelassen und kannst dich gut regulieren' },
                    aengstlich: { icon: 'ğŸ’”', title: 'Ã„ngstlich (Stress)', text: 'Im Stress wirst du klammernder und brauchst mehr BestÃ¤tigung' },
                    vermeidend: { icon: 'ğŸšª', title: 'Vermeidend (Stress)', text: 'Im Stress ziehst du dich zurÃ¼ck und machst dicht' },
                    desorganisiert: { icon: 'ğŸŒ€', title: 'Desorganisiert (Stress)', text: 'Im Stress reagierst du unberechenbar - mal nah, mal distanziert' }
                }
            };

            const data = tooltipData[type]?.[value];
            if (!data) return;

            // Vorherigen Timeout lÃ¶schen
            if (bindungTooltipTimeout) {
                clearTimeout(bindungTooltipTimeout);
            }

            // Tooltip-Inhalte setzen
            iconEl.textContent = data.icon;
            titleEl.textContent = data.title;
            textEl.textContent = data.text;

            // Tooltip anzeigen
            tooltip.classList.add('show');

            // Nach 4 Sekunden ausblenden
            bindungTooltipTimeout = setTimeout(() => {
                tooltip.classList.remove('show');
            }, 4000);
        }
        window.showBindungTooltip = showBindungTooltip;

        /**
         * WÃ¤hlt ein Bindungsmuster aus
         */
        function selectBindungsmuster(type, value) {
            // Tooltip nur anzeigen wenn neu ausgewÃ¤hlt (nicht wenn abgewÃ¤hlt)
            const isNewSelection = (type === 'primary' && slotMachineBindung.primary !== value) ||
                                   (type === 'secondary' && slotMachineBindung.secondary !== value);

            if (type === 'primary') {
                slotMachineBindung.primary = slotMachineBindung.primary === value ? null : value;
            } else {
                slotMachineBindung.secondary = slotMachineBindung.secondary === value ? null : value;
            }
            updateBindungsmusterUI();
            checkStartButtonState();

            // Tooltip nur bei neuer Auswahl anzeigen
            if (isNewSelection) {
                showBindungTooltip(type, value);
            }

            // Speichere in TiageState
            if (typeof TiageState !== 'undefined') {
                TiageState.set('bindungsmuster.ich', slotMachineBindung);
            }
        }
        window.selectBindungsmuster = selectBindungsmuster;

        /**
         * PrÃ¼ft ob der Start-Button aktiviert werden kann
         */
        function checkStartButtonState() {
            const startBtn = document.getElementById('slotStartBtn');
            if (startBtn) {
                startBtn.disabled = !(slotMachineBindung.primary && slotMachineBindung.secondary);
            }
        }

        /**
         * Startet die Slot Machine Animation und Berechnung
         */
        function startSlotMachine() {
            // Wechsel zu Phase 2
            document.getElementById('slotPhase1').style.display = 'none';
            document.getElementById('slotPhase2').style.display = 'block';

            // Starte Berechnung und Animation
            runSlotMachineAnimation();
        }
        window.startSlotMachine = startSlotMachine;

        /**
         * FÃ¼hrt die Slot Machine Animation und Berechnung durch
         */
        async function runSlotMachineAnimation() {
            const ANIMATION_DURATION = 2000; // 2 Sekunden
            const UPDATE_INTERVAL = 50; // Update alle 50ms

            // Berechne alle Kombinationen im Hintergrund
            const allResults = calculateAllCombinations();
            const totalCombinations = allResults.length;

            // Sortiere nach Score (beste zuerst)
            allResults.sort((a, b) => {
                if (b.score !== a.score) return b.score - a.score;
                // Bei Gleichstand: Tie-Breaker
                return calculateTieBreaker(a) - calculateTieBreaker(b);
            });

            const bestResult = allResults[0];
            slotMachineResult = bestResult;

            // NEU: Bester Match PRO ARCHETYP (8 Ergebnisse statt Top 10)
            const bestPerArchetype = {};
            const archetypeOrder = ['single', 'duo', 'duo_flex', 'solopoly', 'polyamor', 'ra', 'lat', 'aromantisch'];

            // Finde den besten Match fÃ¼r jeden Archetyp
            for (const result of allResults) {
                if (!bestPerArchetype[result.archetyp]) {
                    bestPerArchetype[result.archetyp] = result;
                }
                // Stoppe wenn wir fÃ¼r alle 8 Archetypen einen Match haben
                if (Object.keys(bestPerArchetype).length === 8) break;
            }

            // Sortiere nach Archetyp-Reihenfolge, dann nach Score
            const archetypeResults = archetypeOrder
                .filter(arch => bestPerArchetype[arch])
                .map(arch => bestPerArchetype[arch])
                .sort((a, b) => b.score - a.score);

            // Top 4 = die 4 besten Archetyp-Matches, Top 10 = alle 8 Archetyp-Matches
            slotMachineTop4Results = archetypeResults.slice(0, 4);
            slotMachineTop10Results = archetypeResults;

            // Animation starten
            const reelA = document.getElementById('slotReelA');
            const reelG = document.getElementById('slotReelG');
            const reelO = document.getElementById('slotReelO');
            const reelD = document.getElementById('slotReelD');
            const valueA = document.getElementById('slotValueA');
            const valueG = document.getElementById('slotValueG');
            const valueO = document.getElementById('slotValueO');
            const valueD = document.getElementById('slotValueD');
            const scoreDisplay = document.getElementById('slotScoreValue');
            const progressBar = document.getElementById('slotProgressBar');
            const progressText = document.getElementById('slotProgressText');

            // Spinning starten
            [reelA, reelG, reelO, reelD].forEach(r => r.classList.add('spinning'));

            const startTime = Date.now();
            let currentIndex = 0;

            const animationLoop = setInterval(() => {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / ANIMATION_DURATION, 1);

                // Zeige zufÃ¤llige/durchlaufende Werte
                const displayIndex = Math.floor(progress * totalCombinations);
                const currentCombo = allResults[Math.min(displayIndex, allResults.length - 1)];

                // Update Anzeige
                valueA.textContent = ARCHETYP_LABELS[currentCombo.archetyp] || currentCombo.archetyp;
                const gLabel = `${GESCHLECHT_LABELS[currentCombo.geschlecht.primary]}-${GESCHLECHT_LABELS[currentCombo.geschlecht.secondary]}`;
                valueG.textContent = gLabel;
                valueO.textContent = ORIENTIERUNG_LABELS[currentCombo.orientierung] || currentCombo.orientierung;
                valueD.textContent = DOMINANZ_LABELS[currentCombo.dominanz] || currentCombo.dominanz;

                // Score mit Animation
                scoreDisplay.textContent = currentCombo.score;
                scoreDisplay.classList.add('updating');
                setTimeout(() => scoreDisplay.classList.remove('updating'), 100);

                // Progress Bar
                progressBar.style.width = (progress * 100) + '%';
                progressText.textContent = `${Math.floor(progress * totalCombinations)} / ${totalCombinations} Kombinationen`;

                // Animation beenden
                if (progress >= 1) {
                    clearInterval(animationLoop);

                    // Finales Ergebnis anzeigen
                    [reelA, reelG, reelO, reelD].forEach(r => {
                        r.classList.remove('spinning');
                        r.classList.add('locked');
                    });

                    valueA.textContent = ARCHETYP_LABELS[bestResult.archetyp] || bestResult.archetyp;
                    const finalGLabel = `${GESCHLECHT_LABELS[bestResult.geschlecht.primary]}-${GESCHLECHT_LABELS[bestResult.geschlecht.secondary]}`;
                    valueG.textContent = finalGLabel;
                    valueO.textContent = ORIENTIERUNG_LABELS[bestResult.orientierung] || bestResult.orientierung;
                    valueD.textContent = DOMINANZ_LABELS[bestResult.dominanz] || bestResult.dominanz;
                    scoreDisplay.textContent = bestResult.score;

                    // Nach kurzer Pause zu Phase 3 wechseln
                    setTimeout(() => showSlotResult(bestResult), 500);
                }
            }, UPDATE_INTERVAL);
        }

        /**
         * Berechnet alle mÃ¶glichen Kombinationen
         */
        function calculateAllCombinations() {
            const results = [];

            // ICH-Daten (fix)
            // FIX: Hole Dimensionen aus TiageState (SSOT), nicht aus globaler Variable
            const ichArchetype = (typeof TiageState !== 'undefined' ? TiageState.get('archetypes.ich.primary') : null) || currentArchetype || 'single';
            const ichDims = (typeof TiageState !== 'undefined' ? TiageState.get('personDimensions.ich') : null) || personDimensions.ich || {};
            const validIchGeschlecht = ensureValidGeschlecht(ichDims.geschlecht);
            const validIchDominanz = ensureValidDominanz(ichDims.dominanz);
            const validIchOrientierung = ensureValidOrientierung(ichDims.orientierung);
            const ichGfk = ichDims.gfk || 'mittel';

            console.log('[calculateAllCombinations] ICH-Dimensionen aus SSOT:', {
                archetyp: ichArchetype,
                geschlecht: validIchGeschlecht,
                orientierung: validIchOrientierung,
                dominanz: validIchDominanz
            });

            // NEU: ICH-Needs aus TiageState holen oder berechnen
            // FIX: Korrekter Pfad ist 'flatNeeds.ich', nicht 'profiles.ich.flatNeeds'
            let ichNeeds = null;
            if (typeof TiageState !== 'undefined') {
                ichNeeds = TiageState.get('flatNeeds.ich');
            }
            if (!ichNeeds && typeof ProfileCalculator !== 'undefined' && ProfileCalculator.calculateFlatNeeds) {
                ichNeeds = ProfileCalculator.calculateFlatNeeds(
                    ichArchetype,
                    validIchGeschlecht,
                    validIchDominanz,
                    validIchOrientierung
                );
            }

            // NEU: Cache fÃ¼r Partner-Needs (vermeidet redundante Berechnungen)
            const partnerNeedsCache = {};
            function getPartnerNeeds(archetype, geschlecht, orientierung, dominanz) {
                const cacheKey = `${archetype}-${geschlecht.primary}-${geschlecht.secondary}-${orientierung}-${dominanz}`;
                if (!partnerNeedsCache[cacheKey]) {
                    if (typeof ProfileCalculator !== 'undefined' && ProfileCalculator.calculateFlatNeeds) {
                        partnerNeedsCache[cacheKey] = ProfileCalculator.calculateFlatNeeds(
                            archetype,
                            geschlecht,
                            { primary: dominanz, secondary: null },
                            { primary: orientierung, secondary: null }
                        );
                    } else {
                        partnerNeedsCache[cacheKey] = null;
                    }
                }
                return partnerNeedsCache[cacheKey];
            }

            // Speichere globale Variablen
            const savedCurrentArchetype = currentArchetype;
            const savedSelectedPartner = selectedPartner;

            try {
                // Iteriere durch alle Kombinationen
                for (const archetype of ALL_ARCHETYPES_SLOT) {
                    for (const geschlecht of ALL_GESCHLECHT_COMBINATIONS) {
                        for (const orientierung of ALL_ORIENTIERUNGEN) {
                            for (const dominanz of ALL_DOMINANZEN) {
                                // NEU: Partner-Needs berechnen (mit Cache)
                                const partnerNeeds = getPartnerNeeds(archetype, geschlecht, orientierung, dominanz);

                                // Partner-Person erstellen MIT needs
                                const partnerObj = {
                                    archetyp: archetype,
                                    geschlecht: geschlecht,
                                    orientierung: { primary: orientierung, secondary: null },
                                    dominanz: { primary: dominanz, secondary: null },
                                    gfk: 'mittel',
                                    needs: partnerNeeds  // NEU: Partner-spezifische needs fÃ¼r R-Faktor-Berechnung
                                };

                                // ICH-Person erstellen MIT needs
                                const ichObj = {
                                    archetyp: ichArchetype,
                                    geschlecht: validIchGeschlecht,
                                    orientierung: validIchOrientierung,
                                    dominanz: validIchDominanz,
                                    gfk: ichGfk,
                                    needs: ichNeeds  // NEU: ICH-needs fÃ¼r R-Faktor-Berechnung
                                };

                                // Globale Variablen fÃ¼r Berechnung setzen
                                currentArchetype = ichArchetype;
                                selectedPartner = archetype;

                                let score = 0;

                                try {
                                    const pathosCheck = checkPhysicalCompatibility(ichObj, partnerObj);
                                    const logosCheck = calculatePhilosophyCompatibility(ichArchetype, archetype);

                                    if (pathosCheck.result !== 'unmÃ¶glich' && pathosCheck.result !== 'unvollstÃ¤ndig') {
                                        // SSOT v3.10: R-Faktoren EXPLIZIT aus fiktiven Partner-Needs berechnen
                                        const ichRFaktoren = calculateRFactorsFromNeeds(ichObj) || { R1: 1.0, R2: 1.0, R3: 1.0, R4: 1.0 };
                                        const partnerRFaktoren = calculateRFactorsFromNeeds(partnerObj) || { R1: 1.0, R2: 1.0, R3: 1.0, R4: 1.0 };

                                        const result = calculateOverallWithModifiers(ichObj, partnerObj, pathosCheck, logosCheck, {
                                            rFaktoren: {
                                                ich: ichRFaktoren,
                                                partner: partnerRFaktoren
                                            }
                                        });
                                        let baseScore = result.overall || 0;

                                        // SSOT v3.7: Konfidenz-Multiplikator anwenden
                                        // PrimÃ¤re Matches (confidence: 'hoch') werden bevorzugt gegenÃ¼ber sekundÃ¤ren (confidence: 'mittel')
                                        // Dies stellt sicher, dass ein hetero Mann primÃ¤r Frauen sieht, nicht MÃ¤nner Ã¼ber seine sekundÃ¤re Bi-Orientierung
                                        const confidenceMultiplier = getConfidenceMultiplier(pathosCheck.confidence);
                                        score = Math.round(baseScore * confidenceMultiplier * 10) / 10;
                                    } else if (pathosCheck.result === 'unvollstÃ¤ndig') {
                                        score = logosCheck.score || 50;
                                    }
                                } catch (e) {
                                    // Fehler ignorieren
                                }

                                results.push({
                                    archetyp: archetype,
                                    geschlecht: geschlecht,
                                    orientierung: orientierung,
                                    dominanz: dominanz,
                                    score: score
                                });
                            }
                        }
                    }
                }
            } finally {
                // Globale Variablen wiederherstellen
                currentArchetype = savedCurrentArchetype;
                selectedPartner = savedSelectedPartner;
            }

            return results;
        }

        /**
         * Berechnet den Tie-Breaker Score basierend auf Bindungsmuster
         * Niedrigerer Wert = besser
         */
        function calculateTieBreaker(combo) {
            const primary = slotMachineBindung.primary;
            const secondary = slotMachineBindung.secondary;

            let score = 0;

            if (primary && BINDUNGSMUSTER_PRAEFERENZEN[primary]) {
                const prefs = BINDUNGSMUSTER_PRAEFERENZEN[primary];
                // Archetyp Rang (0-7, niedriger = besser) * 0.7
                const archRank = prefs.archetypen.indexOf(combo.archetyp);
                score += (archRank >= 0 ? archRank : 8) * 0.7;
                // Dominanz Rang (0-3, niedriger = besser) * 0.7
                const domRank = prefs.dominanz.indexOf(combo.dominanz);
                score += (domRank >= 0 ? domRank : 4) * 0.7;
            }

            if (secondary && BINDUNGSMUSTER_PRAEFERENZEN[secondary]) {
                const prefs = BINDUNGSMUSTER_PRAEFERENZEN[secondary];
                // SekundÃ¤r mit 30% Gewichtung
                const archRank = prefs.archetypen.indexOf(combo.archetyp);
                score += (archRank >= 0 ? archRank : 8) * 0.3;
                const domRank = prefs.dominanz.indexOf(combo.dominanz);
                score += (domRank >= 0 ? domRank : 4) * 0.3;
            }

            return score;
        }

        /**
         * Zeigt die Top 4 Ergebnisse in Phase 3 (mit erweiterbarer Liste fÃ¼r Position 5-8)
         * NEU: Zeigt den besten Match PRO ARCHETYP (max. 8 Ergebnisse)
         */
        function showSlotResult(result) {
            document.getElementById('slotPhase2').style.display = 'none';
            document.getElementById('slotPhase3').style.display = 'block';

            const listContainer = document.getElementById('slotTop4List');
            const expandedContainer = document.getElementById('slotExpandedList');
            const expandBtn = document.getElementById('slotExpandBtn');
            if (!listContainer) return;

            // Reset expanded state
            slotMachineExpanded = false;
            if (expandedContainer) expandedContainer.style.display = 'none';
            if (expandBtn) {
                expandBtn.innerHTML = 'â–¼ Mehr anzeigen (5-8)';
                // Nur anzeigen wenn es mehr als 4 Ergebnisse gibt
                expandBtn.style.display = slotMachineTop10Results.length > 4 ? 'inline-block' : 'none';
            }

            // Top 4 HTML generieren
            const rankIcons = ['ğŸ¥‡', 'ğŸ¥ˆ', 'ğŸ¥‰', '4.'];
            const rankClasses = ['gold', 'silver', 'bronze', 'fourth'];

            let html = '';
            slotMachineTop4Results.forEach((res, index) => {
                const geschlechtLabel = `${GESCHLECHT_LABELS[res.geschlecht.primary]}-${GESCHLECHT_LABELS[res.geschlecht.secondary]}`;
                const orientierungLabel = ORIENTIERUNG_LABELS[res.orientierung] || res.orientierung;
                const dominanzLabel = DOMINANZ_LABELS[res.dominanz] || res.dominanz;
                const archetypLabel = ARCHETYP_LABELS[res.archetyp] || res.archetyp;

                html += `
                    <div class="slot-top4-item rank-${index + 1}">
                        <div class="slot-top4-rank ${rankClasses[index]}">${rankIcons[index]}</div>
                        <div class="slot-top4-info">
                            <div class="slot-top4-main">
                                <span class="slot-top4-archetyp">${archetypLabel}</span>
                                <span class="slot-top4-score">${res.score}</span>
                            </div>
                            <div class="slot-top4-details">
                                <span class="slot-top4-detail">G: ${geschlechtLabel}</span>
                                <span class="slot-top4-detail">O: ${orientierungLabel}</span>
                                <span class="slot-top4-detail">D: ${dominanzLabel}</span>
                            </div>
                        </div>
                        <button class="slot-top4-apply-btn" onclick="applySlotResult(${index})">âœ“ Ãœbernehmen</button>
                    </div>
                `;
            });
            listContainer.innerHTML = html;

            // Erweiterte Liste (Position 5-10) generieren
            if (expandedContainer && slotMachineTop10Results.length > 4) {
                let expandedHtml = '';
                for (let i = 4; i < slotMachineTop10Results.length; i++) {
                    const res = slotMachineTop10Results[i];
                    const geschlechtLabel = `${GESCHLECHT_LABELS[res.geschlecht.primary]}-${GESCHLECHT_LABELS[res.geschlecht.secondary]}`;
                    const orientierungLabel = ORIENTIERUNG_LABELS[res.orientierung] || res.orientierung;
                    const dominanzLabel = DOMINANZ_LABELS[res.dominanz] || res.dominanz;
                    const archetypLabel = ARCHETYP_LABELS[res.archetyp] || res.archetyp;

                    expandedHtml += `
                        <div class="slot-top4-item rank-${i + 1}" style="opacity: 0.85;">
                            <div class="slot-top4-rank" style="background: rgba(255,255,255,0.1); color: #888;">${i + 1}.</div>
                            <div class="slot-top4-info">
                                <div class="slot-top4-main">
                                    <span class="slot-top4-archetyp">${archetypLabel}</span>
                                    <span class="slot-top4-score">${res.score}</span>
                                </div>
                                <div class="slot-top4-details">
                                    <span class="slot-top4-detail">G: ${geschlechtLabel}</span>
                                    <span class="slot-top4-detail">O: ${orientierungLabel}</span>
                                    <span class="slot-top4-detail">D: ${dominanzLabel}</span>
                                </div>
                            </div>
                            <button class="slot-top4-apply-btn" onclick="applySlotResult(${i})">âœ“ Ãœbernehmen</button>
                        </div>
                    `;
                }
                expandedContainer.innerHTML = expandedHtml;
            }
        }

        /**
         * Toggle-Funktion fÃ¼r erweiterte Liste (Position 5-8)
         * NEU: Zeigt besten Match PRO ARCHETYP
         */
        function toggleSlotExpand() {
            const expandedContainer = document.getElementById('slotExpandedList');
            const expandBtn = document.getElementById('slotExpandBtn');
            const titleEl = document.getElementById('slotResultTitle');

            if (!expandedContainer || !expandBtn) return;

            slotMachineExpanded = !slotMachineExpanded;

            if (slotMachineExpanded) {
                expandedContainer.style.display = 'block';
                expandBtn.innerHTML = 'â–² Weniger anzeigen';
                if (titleEl) titleEl.innerHTML = `ğŸ† Top ${slotMachineTop10Results.length} Partner gefunden!`;
            } else {
                expandedContainer.style.display = 'none';
                expandBtn.innerHTML = 'â–¼ Mehr anzeigen (5-8)';
                if (titleEl) titleEl.innerHTML = 'ğŸ† Top 4 Partner gefunden!';
            }
        }
        window.toggleSlotExpand = toggleSlotExpand;

        /**
         * Wendet das Slot Machine Ergebnis auf das Partner-Profil an
         * @param {number} index - Index des Ergebnisses in slotMachineTop10Results (0-9), default 0
         */
        function applySlotResult(index = 0) {
            // WÃ¤hle Ergebnis aus Top 10 basierend auf Index (unterstÃ¼tzt Position 1-10)
            const result = slotMachineTop10Results[index] || slotMachineTop4Results[index] || slotMachineResult;
            if (!result) return;

            // 1. Archetyp setzen
            selectArchetypeFromGrid('partner', result.archetyp);

            // 2. Geschlecht setzen
            personDimensions.partner.geschlecht = {
                primary: result.geschlecht.primary,
                secondary: result.geschlecht.secondary
            };
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions.partner.geschlecht = {
                    primary: result.geschlecht.primary,
                    secondary: result.geschlecht.secondary
                };
            }
            if (typeof TiageState !== 'undefined') {
                TiageState.set('personDimensions.partner.geschlecht', personDimensions.partner.geschlecht);
            }

            // 3. Orientierung setzen
            personDimensions.partner.orientierung = {
                primary: result.orientierung,
                secondary: null
            };
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions.partner.orientierung = {
                    primary: result.orientierung,
                    secondary: null
                };
            }
            if (typeof TiageState !== 'undefined') {
                TiageState.set('personDimensions.partner.orientierung', personDimensions.partner.orientierung);
            }

            // 4. Dominanz setzen
            personDimensions.partner.dominanz = {
                primary: result.dominanz,
                secondary: null
            };
            if (typeof mobilePersonDimensions !== 'undefined') {
                mobilePersonDimensions.partner.dominanz = {
                    primary: result.dominanz,
                    secondary: null
                };
            }
            if (typeof TiageState !== 'undefined') {
                TiageState.set('personDimensions.partner.dominanz', personDimensions.partner.dominanz);
            }

            // 5. UI aktualisieren - Sync all dimension buttons and summaries for partner
            syncGeschlechtUI('partner');
            syncDimensionUI('partner', 'dominanz');
            syncDimensionUI('partner', 'orientierung');
            updateGeschlechtSummary('partner');
            updateDominanzSummary('partner');
            updateOrientierungSummary('partner');
            updateComparisonView();

            // Profil neu berechnen
            if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                ProfileCalculator.loadProfile('partner', {
                    archetyp: result.archetyp,
                    geschlecht: personDimensions.partner.geschlecht,
                    dominanz: personDimensions.partner.dominanz,
                    orientierung: personDimensions.partner.orientierung
                });
            }

            // Modal schlieÃŸen und zurÃ¼cksetzen
            const modal = document.getElementById('slotMachineModal');
            if (modal) {
                modal.style.display = 'none';
            }
            // Reset fÃ¼r nÃ¤chste Verwendung (Phase 1)
            resetSlotMachine();

            // Feedback-Animation auf dem Button
            const matchBtns = document.querySelectorAll('.best-match-btn:not(.ich-match-btn)');
            matchBtns.forEach(btn => {
                btn.classList.add('match-found');
                setTimeout(() => btn.classList.remove('match-found'), 1000);
            });
        }
        window.applySlotResult = applySlotResult;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // HILFSFUNKTIONEN FÃœR DIMENSIONEN
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Extrahiert primÃ¤re Dominanz aus dem Dominanz-Objekt
        function getPrimaryDominanz(dominanzObj) {
            if (!dominanzObj) return 'ausgeglichen';
            for (const type of ['dominant', 'submissiv', 'switch', 'ausgeglichen']) {
                if (dominanzObj[type] === 'gelebt') return type;
            }
            return 'ausgeglichen';
        }

        // Extrahiert primÃ¤re Orientierung aus dem Orientierungs-Objekt
        function getPrimaryOrientierung(orientierungObj) {
            if (!orientierungObj) return 'heterosexuell';
            for (const type of ['heterosexuell', 'homosexuell', 'bisexuell', 'pansexuell']) {
                if (orientierungObj[type] === 'gelebt') return type;
            }
            return 'heterosexuell';
        }

        // Extrahiert primÃ¤res Geschlecht aus dem Geschlechts-Objekt
        function getPrimaryGeschlecht(geschlechtObj) {
            if (!geschlechtObj) return 'mann';
            const primary = geschlechtObj.primary;
            if (primary) return primary.toLowerCase();
            return 'mann';
        }

        /**
         * findBestIchMatch() - Findet den besten ICH-Archetyp basierend auf den Partner-Einstellungen
         * Umgekehrte Logik zu findBestPartnerMatch(): Hier werden die PARTNER-Einstellungen als Basis genommen
         * und der beste ICH-Archetyp gesucht.
         *
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * TIAGE SYNTHESE v3.1 FORMEL (siehe findBestPartnerMatch fÃ¼r Details)
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         *
         * Q = [(A Ã— 0.15) + (O Ã— 0.40) + (D Ã— 0.20) + (G Ã— 0.25)] Ã— R
         *
         * v3.1: Q = Î£(Faktor Ã— Gewicht Ã— R_Dimension)
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */
        function findBestIchMatch() {
            console.log('[findBestIchMatch] Funktion aufgerufen');
            console.log('[findBestIchMatch] data geladen:', data !== null);
            console.log('[findBestIchMatch] personDimensions:', JSON.stringify(personDimensions));

            // PrÃ¼fe, ob data geladen ist
            if (!data) {
                console.warn('[findBestIchMatch] WARNUNG: data ist nicht geladen! Verwende Fallback-Matrix.');
            }

            const ALL_ARCHETYPES = ['single', 'duo', 'duo_flex', 'ra', 'lat', 'aromantisch', 'solopoly', 'polyamor'];

            // v3.6: Hole echte Needs aus TiageState fÃ¼r R-Faktor-Berechnung
            let ichNeeds = null;
            let partnerNeeds = null;
            if (typeof TiageState !== 'undefined') {
                ichNeeds = TiageState.get('flatNeeds.ich');
                partnerNeeds = TiageState.get('flatNeeds.partner');
                console.log('[findBestIchMatch] Echte Needs geladen:', {
                    ichNeeds: ichNeeds ? Object.keys(ichNeeds).length : 0,
                    partnerNeeds: partnerNeeds ? Object.keys(partnerNeeds).length : 0
                });
            }

            // Sammle PARTNER-Daten (DU) als Basis
            const partnerArchetype = selectedPartner || 'duo';
            const partnerDims = personDimensions.partner || {};

            // Sammle ICH-Dimensionen (fÃ¼r die Berechnung)
            const ichDims = personDimensions.ich || {};

            // Validierte Dimensionen mit Defaults fÃ¼r fehlende Werte
            const validIchGeschlecht = ensureValidGeschlecht(ichDims.geschlecht);
            const validIchDominanz = ensureValidDominanz(ichDims.dominanz);
            const validIchOrientierung = ensureValidOrientierung(ichDims.orientierung);

            // BUGFIX: Wenn Partner-Dimensionen fehlen, verwende kompatible Defaults
            // statt feste Defaults die mÃ¶glicherweise inkompatibel sind
            const partnerHasGeschlecht = partnerDims.geschlecht && partnerDims.geschlecht.primary;
            const partnerHasOrientierung = partnerDims.orientierung && partnerDims.orientierung.primary;

            let validPartnerGeschlecht;
            if (partnerHasGeschlecht) {
                validPartnerGeschlecht = ensureValidGeschlecht(partnerDims.geschlecht);
            } else {
                // Setze kompatibles Geschlecht basierend auf ICH-Orientierung
                // FÃ¼r heterosexuell: gegengeschlechtlich, sonst gleiches Geschlecht
                const ichOriPrimary = validIchOrientierung.primary;
                const ichGeschPrimary = validIchGeschlecht.primary;
                if (ichOriPrimary === 'heterosexuell') {
                    // Heterosexuell: Partner sollte anderes Geschlecht haben
                    validPartnerGeschlecht = {
                        primary: ichGeschPrimary === 'mann' ? 'frau' : 'mann',
                        secondary: 'cis'
                    };
                } else {
                    // Homosexuell/bi-pansexuell: Gleiches Geschlecht ist kompatibel
                    validPartnerGeschlecht = {
                        primary: ichGeschPrimary,
                        secondary: 'cis'
                    };
                }
                console.log('[findBestIchMatch] Partner-Geschlecht nicht gesetzt, verwende kompatiblen Default:', validPartnerGeschlecht);
            }

            let validPartnerOrientierung;
            if (partnerHasOrientierung) {
                validPartnerOrientierung = ensureValidOrientierung(partnerDims.orientierung);
            } else {
                // Setze kompatible Orientierung basierend auf ICH
                validPartnerOrientierung = {
                    primary: validIchOrientierung.primary,
                    secondary: validIchOrientierung.secondary
                };
                console.log('[findBestIchMatch] Partner-Orientierung nicht gesetzt, verwende ICH-Orientierung:', validPartnerOrientierung);
            }

            // FEATURE: Dominanz-Auto-Korrelation - komplementÃ¤re Dominanz fÃ¼r beste KompatibilitÃ¤t
            const partnerHasDominanz = partnerDims.dominanz && partnerDims.dominanz.primary;
            let validPartnerDominanz;
            if (partnerHasDominanz) {
                validPartnerDominanz = ensureValidDominanz(partnerDims.dominanz);
            } else {
                // Setze komplementÃ¤re Dominanz basierend auf ICH fÃ¼r maximalen Modifier (+8)
                const ichDomPrimary = validIchDominanz.primary;
                if (ichDomPrimary === 'dominant') {
                    // dominant + submissiv = +8 Modifier (beste Kombination)
                    validPartnerDominanz = { primary: 'submissiv', secondary: null };
                } else if (ichDomPrimary === 'submissiv') {
                    // submissiv + dominant = +8 Modifier (beste Kombination)
                    validPartnerDominanz = { primary: 'dominant', secondary: null };
                } else if (ichDomPrimary === 'switch') {
                    // switch + switch = +3 Modifier
                    validPartnerDominanz = { primary: 'switch', secondary: null };
                } else {
                    // ausgeglichen + ausgeglichen = +5 Modifier
                    validPartnerDominanz = { primary: 'ausgeglichen', secondary: null };
                }
                console.log('[findBestIchMatch] Partner-Dominanz nicht gesetzt, verwende komplementÃ¤ren Default:', validPartnerDominanz);
            }

            // FEATURE: GFK-Auto-Korrelation - gleiche oder hÃ¶here GFK-Kompetenz
            const partnerHasGfk = partnerDims.gfk && partnerDims.gfk !== '';
            let validPartnerGfk;
            if (partnerHasGfk) {
                validPartnerGfk = partnerDims.gfk;
            } else {
                // Setze GFK basierend auf ICH - gleich oder hÃ¶her fÃ¼r beste KompatibilitÃ¤t
                const ichGfk = ichDims.gfk || 'mittel';
                // hoch-hoch = 100, mittel-mittel = 65, niedrig-niedrig = 25
                // FÃ¼r beste KompatibilitÃ¤t: Gleiche Stufe oder hÃ¶her
                if (ichGfk === 'hoch') {
                    validPartnerGfk = 'hoch'; // hoch-hoch = 100
                } else if (ichGfk === 'mittel') {
                    validPartnerGfk = 'hoch'; // mittel-hoch = 75 (besser als mittel-mittel = 65)
                } else {
                    validPartnerGfk = 'mittel'; // niedrig-mittel = 45 (besser als niedrig-niedrig = 25)
                }
                console.log('[findBestIchMatch] Partner-GFK nicht gesetzt, verwende optimalen Default:', validPartnerGfk);
            }

            console.log('[findBestIchMatch] selectedPartner:', selectedPartner, '-> verwendet:', partnerArchetype);
            console.log('[findBestIchMatch] Validierte Partner-Dimensionen:', {
                geschlecht: validPartnerGeschlecht,
                dominanz: validPartnerDominanz,
                orientierung: validPartnerOrientierung,
                gfk: validPartnerGfk
            });

            let bestMatch = null;
            let bestScore = -1;
            const results = [];

            // Berechne Score fÃ¼r jeden mÃ¶glichen ICH-Archetyp
            for (const ichArch of ALL_ARCHETYPES) {
                try {
                    // Erstelle temporÃ¤re Person-Objekte fÃ¼r die Berechnung
                    // Person1 = ICH (der Archetyp, der getestet wird)
                    const person1 = {
                        archetyp: ichArch,
                        dominanz: validIchDominanz,
                        geschlecht: validIchGeschlecht,
                        orientierung: validIchOrientierung,
                        gfk: ichDims.gfk || 'mittel',
                        needs: ichNeeds  // v3.6: Echte Needs fÃ¼r R-Faktor-Berechnung
                    };

                    // Person2 = PARTNER (die festen Einstellungen)
                    const person2 = {
                        archetyp: partnerArchetype,
                        dominanz: validPartnerDominanz,
                        geschlecht: validPartnerGeschlecht,
                        orientierung: validPartnerOrientierung,
                        gfk: validPartnerGfk,
                        needs: partnerNeeds  // v3.6: Echte Needs fÃ¼r R-Faktor-Berechnung
                    };

                    let score = 0;

                    // WICHTIG: Verwende dieselbe Berechnung wie updateComparisonView()
                    // um konsistente Scores zu erhalten

                    // TemporÃ¤r globale Variablen setzen fÃ¼r calculateRelationshipQuality
                    const savedCurrentArchetype = currentArchetype;
                    const savedSelectedPartner = selectedPartner;
                    currentArchetype = ichArch;
                    selectedPartner = partnerArchetype;

                    try {
                        const pathosCheck = checkPhysicalCompatibility(person1, person2);
                        const logosCheck = calculatePhilosophyCompatibility(ichArch, partnerArchetype);

                        if (pathosCheck.result !== 'unmÃ¶glich' && pathosCheck.result !== 'unvollstÃ¤ndig') {
                            // SSOT v3.10: R-Faktoren aus person.needs
                            const result = calculateOverallWithModifiers(person1, person2, pathosCheck, logosCheck);
                            let baseScore = result.overall || 0;

                            // SSOT v3.7: Konfidenz-Multiplikator anwenden
                            const confidenceMultiplier = getConfidenceMultiplier(pathosCheck.confidence);
                            score = Math.round(baseScore * confidenceMultiplier * 10) / 10;
                        } else if (pathosCheck.result === 'unvollstÃ¤ndig') {
                            // Bei unvollstÃ¤ndigen Dimensionen: Fallback auf Archetyp-Matrix
                            const logosScore = logosCheck.score || 50;
                            score = logosScore;
                        }
                        // Bei 'unmÃ¶glich': score bleibt 0
                    } finally {
                        // Globale Variablen wiederherstellen
                        currentArchetype = savedCurrentArchetype;
                        selectedPartner = savedSelectedPartner;
                    }

                    results.push({ archetype: ichArch, score: score });

                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = ichArch;
                    }
                } catch (e) {
                    console.warn(`Fehler bei der Berechnung fÃ¼r ${ichArch}:`, e);
                }
            }

            // Sortiere Ergebnisse fÃ¼r Debugging
            results.sort((a, b) => b.score - a.score);
            console.log('[findBestIchMatch] PARTNER:', partnerArchetype);
            console.log('[findBestIchMatch] Ranking:', results);

            // WÃ¤hle den besten Match aus, der NICHT derselbe Archetyp wie PARTNER ist
            // (nÃ¤chstbester statt identischer Archetyp)
            const bestDifferentMatch = results.find(r => r.archetype !== partnerArchetype);
            if (bestDifferentMatch) {
                bestMatch = bestDifferentMatch.archetype;
                bestScore = bestDifferentMatch.score;
            }

            console.log('[findBestIchMatch] Bester ICH-Match (â‰  PARTNER):', bestMatch, 'mit Score:', bestScore);

            // WÃ¤hle den besten Match aus
            if (bestMatch) {
                selectArchetypeFromGrid('ich', bestMatch);

                // Zeige kurze Feedback-Animation auf dem Button
                const matchBtns = document.querySelectorAll('.ich-match-btn');
                matchBtns.forEach(btn => {
                    btn.classList.add('match-found');
                    setTimeout(() => btn.classList.remove('match-found'), 1000);
                });
            }

            return { bestMatch, bestScore, results };
        }

        // Globale Funktion verfÃ¼gbar machen
        window.findBestIchMatch = findBestIchMatch;

        // Navigation auf Seite 2 (Ergebnis) - ruft navigateArchetype auf und aktualisiert Seite 2
        function navigateArchetypeOnPage2(person, direction) {
            navigateArchetype(person, direction);
            // Seite 2 explizit aktualisieren
            updateMobileResultPage();
        }

        // Navigation auf Seite 3 (Kategorien) - ruft navigateArchetype auf und aktualisiert Seite 3
        function navigateArchetypeOnPage3(person, direction) {
            navigateArchetype(person, direction);
            // Seite 3 explizit aktualisieren
            updateMobilePage3();
        }

        // Aktualisiert die Anzeige auf Mobile Seite 3
        function updateMobilePage3() {
            const ichArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[selectedPartner];

            const ichEl = document.getElementById('mobileResultIch3');
            const partnerEl = document.getElementById('mobileResultPartner3');

            if (ichEl) ichEl.textContent = ichArch?.name || currentArchetype;
            if (partnerEl) partnerEl.textContent = partnerArch?.name || selectedPartner;
        }

        // Variable fÃ¼r aktuelle Kategorie im Modal
        let currentDisplayedCategory = 'A';

        // Navigation fÃ¼r CategoryModal - wechselt beide Archetypen (ICH)
        function navigateCategoryArchetype(direction) {
            navigateArchetype('ich', direction);
            // CategoryModal neu laden mit aktueller Kategorie
            showCategoryDetails(currentDisplayedCategory);
            // Alle Ansichten aktualisieren
            updateComparisonView();
        }

        function initComparisonLayout() {
            // ICH select
            const ichSelect = document.getElementById('ichSelect');
            if (ichSelect) {
                ichSelect.addEventListener('change', (e) => {
                    currentArchetype = e.target.value;
                    mobileIchArchetype = e.target.value;
                    // Sync with TiageState for save/load
                    if (typeof TiageState !== 'undefined') {
                        TiageState.setArchetype('ich', e.target.value);
                    }
                    // Sync with old select if exists
                    const oldSelect = document.getElementById('archetypeSelect');
                    if (oldSelect) oldSelect.value = e.target.value;
                    updateArchetypeGrid('ich', e.target.value);

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // SSOT: Berechne flatNeeds + Resonanzfaktoren bei Archetyp-Wechsel
                    // ProfileCalculator.loadProfile() schreibt direkt in TiageState
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                        const profileData = {
                            archetyp: e.target.value,
                            geschlecht: TiageState.get('personDimensions.ich.geschlecht'),
                            dominanz: TiageState.get('personDimensions.ich.dominanz'),
                            orientierung: TiageState.get('personDimensions.ich.orientierung')
                        };
                        console.log('[SSOT] Rufe ProfileCalculator.loadProfile auf mit:', JSON.stringify(profileData));
                        ProfileCalculator.loadProfile('ich', profileData);
                        console.log('[SSOT] Profil fÃ¼r ICH neu berechnet:', e.target.value);
                        // Debug: Was steht jetzt in TiageState?
                        const resonanzNachBerechnung = TiageState.get('resonanzFaktoren.ich');
                        console.log('[SSOT] resonanzFaktoren nach Berechnung:', JSON.stringify(resonanzNachBerechnung));
                    }

                    updateComparisonView();
                    // GFK automatisch aus Archetypen-Matching ableiten
                    updateGfkFromArchetypes();
                });
            }

            // Partner select
            const partnerSelect = document.getElementById('partnerSelect');
            if (partnerSelect) {
                partnerSelect.addEventListener('change', (e) => {
                    selectedPartner = e.target.value;
                    mobilePartnerArchetype = e.target.value;
                    // Sync with TiageState for save/load
                    if (typeof TiageState !== 'undefined') {
                        TiageState.setArchetype('partner', e.target.value);
                    }
                    updateArchetypeGrid('partner', e.target.value);

                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    // SSOT: Berechne flatNeeds + Resonanzfaktoren bei Archetyp-Wechsel
                    // ProfileCalculator.loadProfile() schreibt direkt in TiageState
                    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                    if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                        const profileData = {
                            archetyp: e.target.value,
                            geschlecht: TiageState.get('personDimensions.partner.geschlecht'),
                            dominanz: TiageState.get('personDimensions.partner.dominanz'),
                            orientierung: TiageState.get('personDimensions.partner.orientierung')
                        };
                        ProfileCalculator.loadProfile('partner', profileData);
                        console.log('[SSOT] Profil fÃ¼r PARTNER neu berechnet:', e.target.value);
                    }

                    updateComparisonView();
                    // GFK automatisch aus Archetypen-Matching ableiten
                    updateGfkFromArchetypes();
                });
            }

            // ICH compact dimensions
            document.querySelectorAll('input[name="ich-geschlecht-new"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    // Use handleGeschlechtClick to maintain consistent object format
                    handleGeschlechtClick('ich', e.target.value, e.target);
                });
            });
            document.querySelectorAll('input[name="ich-dominanz-new"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    handleDominanzClick('ich', e.target.value);
                });
            });
            document.querySelectorAll('input[name="ich-dominanz-status-new"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    personDimensions.ich.dominanzStatus = e.target.value;
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    updateAnalysisOverview();
                    updateComparisonView();
                });
            });

            // Partner compact dimensions
            document.querySelectorAll('input[name="partner-geschlecht-new"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    // Use handleGeschlechtClick to maintain consistent object format
                    handleGeschlechtClick('partner', e.target.value, e.target);
                });
            });
            document.querySelectorAll('input[name="partner-dominanz-new"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    handleDominanzClick('partner', e.target.value);
                });
            });
            document.querySelectorAll('input[name="partner-dominanz-status-new"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    personDimensions.partner.dominanzStatus = e.target.value;
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    updateAnalysisOverview();
                    updateComparisonView();
                });
            });

            // Initial Score-Circle Update beim Start
            updateComparisonView();
        }

        function updateComparisonView() {
            if (!data) return;

            console.log('[TIAGE] updateComparisonView called - dimensions:', JSON.stringify({
                ich: personDimensions.ich,
                partner: personDimensions.partner
            }));

            const ichArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[selectedPartner];

            // NEU: GFK-BedÃ¼rfnis-Matching mit allen Dimensionen neu berechnen
            try {
                updateGfkFromArchetypes();
            } catch (e) {
                console.warn('[TIAGE] updateGfkFromArchetypes error:', e);
            }

            // Update type names
            document.getElementById('resultIchType').textContent = ichArch?.name || currentArchetype;
            document.getElementById('resultPartnerType').textContent = partnerArch?.name || selectedPartner;

            // Calculate compatibility
            // SSOT v3.10: Needs aus TiageState laden fÃ¼r R-Faktor-Berechnung
            const ichNeeds = typeof TiageState !== 'undefined' ? TiageState.get('flatNeeds.ich') : null;
            const partnerNeeds = typeof TiageState !== 'undefined' ? TiageState.get('flatNeeds.partner') : null;

            const person1 = { archetyp: currentArchetype, ...personDimensions.ich, needs: ichNeeds };
            const person2 = { archetyp: selectedPartner, ...personDimensions.partner, needs: partnerNeeds };

            console.log('[updateComparisonView] person1:', JSON.stringify(person1));
            console.log('[updateComparisonView] person2:', JSON.stringify(person2));
            console.log('[updateComparisonView] SSOT: ichNeeds:', !!ichNeeds, 'partnerNeeds:', !!partnerNeeds);

            const pathosCheck = checkPhysicalCompatibility(person1, person2);
            console.log('[updateComparisonView] pathosCheck:', JSON.stringify(pathosCheck));
            const logosCheck = calculatePhilosophyCompatibility(currentArchetype, selectedPartner);

            // Update warnings
            const warningsContainer = document.getElementById('warningsContainer');
            warningsContainer.innerHTML = '';

            if (pathosCheck.result === 'unvollstÃ¤ndig') {
                let warningHTML = '<div class="warning-box incomplete-warning">âš ï¸ Es fehlt noch:';
                if (pathosCheck.missingItems && pathosCheck.missingItems.length > 0) {
                    warningHTML += '<ul style="margin: 5px 0 0 20px; padding: 0;">';
                    pathosCheck.missingItems.forEach(item => {
                        warningHTML += `<li>${item}</li>`;
                    });
                    warningHTML += '</ul>';
                }
                warningHTML += '</div>';
                warningsContainer.innerHTML = warningHTML;
            } else if (pathosCheck.result === 'unmÃ¶glich') {
                warningsContainer.innerHTML = `<div class="warning-box pathos-warning">ğŸš« Keine emotionale/kÃ¶rperliche Anziehung: ${pathosCheck.reason}</div>`;
            } else if (pathosCheck.result === 'unsicher') {
                warningsContainer.innerHTML = `<div class="warning-box logos-warning">âš ï¸ Unsichere kÃ¶rperliche Anziehung (Exploration-Phase)</div>`;
            }

            // Warnung bei unsicherem Dominanz-Status (prÃ¼fe ob mindestens eine Auswahl "interessiert" ist)
            const hasInteressiert1 = person1.dominanz && Object.values(person1.dominanz).some(s => s === 'interessiert');
            const hasInteressiert2 = person2.dominanz && Object.values(person2.dominanz).some(s => s === 'interessiert');
            if (hasInteressiert1 || hasInteressiert2) {
                warningsContainer.innerHTML += `<div class="warning-box logos-warning">âš ï¸ Unsichere Dominanz-Dynamik (Exploration-Phase â€“ reduzierte Konfidenz)</div>`;
            }

            if (logosCheck.score < 50) {
                warningsContainer.innerHTML += `<div class="warning-box logos-warning">âš ï¸ Verstandsebene-Warnung: Philosophie nur ${logosCheck.score}</div>`;
            }

            // If dimensions incomplete, show empty state and return
            if (pathosCheck.result === 'unvollstÃ¤ndig') {
                // Clear all expandable sections
                const percentage = document.getElementById('resultPercentage');
                const progressFill = document.getElementById('resultProgressFill');
                percentage.textContent = 'â€“';
                percentage.className = 'result-percentage';
                progressFill.style.width = '0%';

                // Update desktop circle for incomplete state
                const desktopCircle = document.getElementById('desktopCirclePercentage');
                if (desktopCircle) desktopCircle.textContent = 'â€“';
                const desktopScoreCircle = document.getElementById('desktopScoreCircle');
                if (desktopScoreCircle) desktopScoreCircle.style.background = 'transparent';

                const categoryBars = document.getElementById('expandCategoryBars');
                if (categoryBars) categoryBars.innerHTML = '<p style="color: var(--text-muted); font-style: italic; text-align: center; padding: 20px;">Bitte alle Dimensionen auswÃ¤hlen</p>';

                const expandRadar = document.getElementById('expandRadarChart');
                if (expandRadar) expandRadar.innerHTML = '';

                const desktopScoreNoteIncomplete = document.getElementById('desktopScoreNote');
                if (desktopScoreNoteIncomplete) desktopScoreNoteIncomplete.textContent = 'Bitte alle Dimensionen auswÃ¤hlen.';

                // KO-Text ausblenden bei unvollstÃ¤ndigen Dimensionen (Desktop)
                const desktopKoTextIncomplete = document.getElementById('desktopKoTextDisplay');
                if (desktopKoTextIncomplete) {
                    desktopKoTextIncomplete.style.display = 'none';
                    desktopKoTextIncomplete.innerHTML = '';
                }

                // KO-Text ausblenden bei unvollstÃ¤ndigen Dimensionen (Mobile)
                const mobileKoTextIncomplete = document.getElementById('mobileKoTextDisplay');
                if (mobileKoTextIncomplete) {
                    mobileKoTextIncomplete.style.display = 'none';
                    mobileKoTextIncomplete.innerHTML = '';
                }

                // Update Score-Circle auch bei unvollstÃ¤ndigen Dimensionen
                updateSyntheseScoreCycle();
                return;
            }

            // Calculate overall score
            let overallScore = 0;
            let qualityBreakdown = { archetyp: 0, dominanz: 0, orientierung: 0, geschlecht: 0 };

            if (pathosCheck.result !== 'unmÃ¶glich') {
                try {
                    // SSOT v3.10: R-Faktoren aus person.needs (TiageState)
                    const result = calculateOverallWithModifiers(person1, person2, pathosCheck, logosCheck);
                    overallScore = result.overall;
                    qualityBreakdown = result.breakdown || qualityBreakdown;
                    console.log('[TIAGE] Score calculated:', overallScore, 'breakdown:', qualityBreakdown);

                    // Update expandable category bars
                    updateExpandableCategoryBars(result.categories);
                } catch (e) {
                    console.error('[TIAGE] calculateOverallWithModifiers error:', e);
                }
            }

            // Update 4-Factor Breakdown (Desktop)
            const factorArchetyp = document.getElementById('desktopFactorArchetyp');
            const factorDominanz = document.getElementById('desktopFactorDominanz');
            const factorOrientierung = document.getElementById('desktopFactorOrientierung');
            const factorGeschlecht = document.getElementById('desktopFactorGeschlecht');

            if (factorArchetyp) factorArchetyp.textContent = qualityBreakdown.archetyp;
            if (factorDominanz) factorDominanz.textContent = qualityBreakdown.dominanz;
            if (factorOrientierung) factorOrientierung.textContent = qualityBreakdown.orientierung;
            if (factorGeschlecht) factorGeschlecht.textContent = qualityBreakdown.geschlecht;

            // Update expandable desktop factor content
            updateDesktopFactorContent();

            // Update result bar
            const percentage = document.getElementById('resultPercentage');
            const progressFill = document.getElementById('resultProgressFill');

            percentage.textContent = overallScore.toFixed(1);
            progressFill.style.width = Math.min(100, overallScore) + '%';

            // Update desktop score circle
            const desktopCircle = document.getElementById('desktopCirclePercentage');
            if (desktopCircle) {
                desktopCircle.textContent = overallScore.toFixed(1);
            }

            // Set color based on score (3-Stufen-Skala: 70/50)
            let colorClass = 'low';
            let color = 'var(--danger)';
            if (overallScore >= 70) { colorClass = 'good'; color = 'var(--primary)'; }
            else if (overallScore >= 50) { colorClass = 'moderate'; color = 'var(--warning)'; }

            percentage.className = 'result-percentage ' + colorClass;
            progressFill.style.background = color;

            // Update desktop circle color
            const desktopScoreCircle = document.getElementById('desktopScoreCircle');
            if (desktopScoreCircle) {
                desktopScoreCircle.style.background = 'transparent';
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // DESKTOP KO-TEXT DISPLAY (unter dem Score Circle)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const desktopKoTextDisplay = document.getElementById('desktopKoTextDisplay');
            if (desktopKoTextDisplay) {
                if (pathosCheck.result === 'unmÃ¶glich') {
                    // KO-Text anzeigen
                    const koReason = pathosCheck.reason || 'Inkompatible Orientierungen';
                    desktopKoTextDisplay.innerHTML = '<span class="ko-title">âš ï¸ K.O.-Kriterium</span><span class="ko-reason">' + koReason + '</span>';
                    desktopKoTextDisplay.style.display = 'block';
                } else {
                    // KO-Text ausblenden
                    desktopKoTextDisplay.style.display = 'none';
                    desktopKoTextDisplay.innerHTML = '';
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // MOBILE KO-TEXT DISPLAY (unter dem Score Circle auf Page 3)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const mobileKoTextDisplay = document.getElementById('mobileKoTextDisplay');
            if (mobileKoTextDisplay) {
                if (pathosCheck.result === 'unmÃ¶glich') {
                    // KO-Text anzeigen
                    const koReason = pathosCheck.reason || 'Inkompatible Orientierungen';
                    mobileKoTextDisplay.innerHTML = '<span class="ko-title">âš ï¸ K.O.-Kriterium</span><br><span class="ko-reason">' + koReason + '</span>';
                    mobileKoTextDisplay.style.display = 'block';
                } else {
                    // KO-Text ausblenden
                    mobileKoTextDisplay.style.display = 'none';
                    mobileKoTextDisplay.innerHTML = '';
                }
            }

            // Update Desktop Score Note (direkt beim Kreis) - 3-Stufen-Skala
            const desktopScoreNote = document.getElementById('desktopScoreNote');
            if (desktopScoreNote) {
                let noteText = '';
                let quoteText = '';
                let quoteSource = '';

                // Bestimme Resonanzlevel basierend auf Score
                let resonanceLevel = 'niedrig';
                if (overallScore >= 80) resonanceLevel = 'hoch';
                else if (overallScore >= 50) resonanceLevel = 'mittel';

                // Versuche Zitat aus ResonanceQuotesTable zu holen
                if (typeof ResonanceQuotesTable !== 'undefined' && pathosCheck.result !== 'unmÃ¶glich') {
                    const category = overallScore >= 65 ? 'RESONANCE' : overallScore >= 50 ? 'GROWTH' : 'AWARENESS';
                    const result = ResonanceQuotesTable.generateResonanceText(resonanceLevel, category, 'de');

                    if (result && result.quote) {
                        noteText = result.title;
                        quoteText = result.quote;
                        quoteSource = result.quoteSource ? ` â€” ${result.quoteSource}` : '';
                    }
                }

                // Fallback zu hardcoded Texten
                if (!quoteText) {
                    if (pathosCheck.result === 'unmÃ¶glich') {
                        noteText = 'Keine Basis fÃ¼r Resonanz vorhanden.';
                        quoteText = 'Diese Beziehung zeigt eine QualitÃ¤t von ' + overallScore + ' â€“ keine kompatible Basis vorhanden, deren Muster sich ausschlieÃŸen.';
                    } else if (overallScore >= 70) {
                        noteText = 'Gute Resonanz â€“ Muster ergÃ¤nzen sich.';
                        quoteText = 'Diese Beziehung zeigt eine QualitÃ¤t von ' + overallScore + ' â€“ eine gute Resonanz zwischen zwei Menschen, deren Muster sich ergÃ¤nzen.';
                    } else if (overallScore >= 50) {
                        noteText = 'Basis vorhanden, Arbeit erforderlich.';
                        quoteText = 'Diese Beziehung zeigt eine QualitÃ¤t von ' + overallScore + ' â€“ eine Basis ist vorhanden, erfordert aber bewusste Arbeit und Kommunikation.';
                    } else {
                        noteText = 'Bewusste Reflexion erforderlich.';
                        quoteText = 'Diese Beziehung zeigt eine QualitÃ¤t von ' + overallScore + ' â€“ bewusste Reflexion und offene Kommunikation sind erforderlich.';
                    }
                }

                desktopScoreNote.innerHTML = '<strong>' + noteText + '</strong><br><span style="font-style: italic; opacity: 0.85; font-size: 0.9em;">"' + quoteText + '"' + quoteSource + '</span>';
            }

            // Update Radar Chart
            const interactionKey = `${currentArchetype}_${selectedPartner}`;
            const interaction = data.interactions?.[interactionKey] || {};
            drawRadarChart(interaction.scores || {}, partnerArch?.color || '#457B9D');

            // Update Desktop Selection Info Message
            updateSelectionInfoMessage();

            // Update Score-Circle auf der Hauptseite
            updateSyntheseScoreCycle();
        }

        // Universelle Funktion fÃ¼r Kategorien-Balken (Mobile & Desktop)
        const categoryNamesMap = {
            A: 'Beziehungsphilosophie',
            B: 'Werte-Alignment',
            C: 'NÃ¤he-Distanz',
            D: 'Autonomie',
            E: 'Kommunikation',
            F: 'Soziale KompatibilitÃ¤t'
        };

        function renderCategoryBars(containerId, categories) {
            const container = document.getElementById(containerId);
            if (!container) return;

            let html = '';
            for (const [cat, catData] of Object.entries(categories)) {
                const score = catData.score || 0;
                let colorClass = 'low';
                if (score >= 70) colorClass = 'good';
                else if (score >= 50) colorClass = 'moderate';

                html += `
                    <div class="category-bar-row clickable-bar" style="margin-bottom: 12px; cursor: pointer; padding: 8px; border-radius: 8px; transition: background 0.2s;" onclick="showCategoryDetails('${cat}')" onmouseover="this.style.background='rgba(255,255,255,0.05)'" onmouseout="this.style.background='transparent'">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 4px; align-items: center;">
                            <span style="font-size: 12px; color: var(--text-secondary);">${cat}: ${categoryNamesMap[cat]}</span>
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 12px; font-weight: 600;" class="${colorClass}">${score}%</span>
                                <span style="font-size: 10px; color: var(--text-muted);">â„¹</span>
                            </div>
                        </div>
                        <div style="height: 6px; background: var(--bg-dark); border-radius: 3px; overflow: hidden;">
                            <div style="height: 100%; width: ${score}%; background: var(--${colorClass === 'good' ? 'primary' : colorClass === 'moderate' ? 'warning' : 'danger'}); border-radius: 3px;"></div>
                        </div>
                    </div>
                `;
            }
            container.innerHTML = html;
        }

        // Desktop: Wrapper fÃ¼r KompatibilitÃ¤t
        function updateExpandableCategoryBars(categories) {
            renderCategoryBars('expandCategoryBars', categories);
        }

        function showArchetypeInfo(person) {
            console.log('showArchetypeInfo called with:', person);
            const archetype = person === 'ich' ? currentArchetype : selectedPartner;
            console.log('archetype:', archetype, 'data:', data);
            if (!data || !data.archetypes || !data.archetypes[archetype]) {
                console.error('Data not available for archetype:', archetype);
                return;
            }

            // Set current index for swipe navigation
            currentDefinitionIndex = archetypeOrder.indexOf(archetype);
            if (currentDefinitionIndex === -1) currentDefinitionIndex = 0;
            currentDefinitionPerson = person;

            // Use the shared function to render content
            showArchetypeInfoByType(archetype);

            document.getElementById('definitionModal').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Add touch swipe support
            const modal = document.querySelector('#definitionModal .modal');
            modal.ontouchstart = handleDefinitionTouchStart;
            modal.ontouchend = handleDefinitionTouchEnd;
        }

        function showCategoryDetails(cat) {
            if (!data || !data.categories || !data.categories[cat]) return;

            // Aktuelle Kategorie speichern fÃ¼r Navigation
            currentDisplayedCategory = cat;

            const catInfo = data.categories[cat];
            const catNames = {
                A: 'Beziehungsphilosophie',
                B: 'Werte-Alignment',
                C: 'NÃ¤he-Distanz',
                D: 'Autonomie',
                E: 'Kommunikation',
                F: 'Soziale KompatibilitÃ¤t'
            };

            const ichArch = data.archetypes[currentArchetype];
            const partnerArch = data.archetypes[selectedPartner];
            const key = `${currentArchetype}_${selectedPartner}`;
            const interaction = data.interactions?.[key] || {};
            const catScore = interaction.scores?.[cat]?.value || 0;

            let scoreClass = 'low';
            let scoreText = 'Herausfordernd';
            if (catScore >= 70) { scoreClass = 'good'; scoreText = 'Gut'; }
            else if (catScore >= 50) { scoreClass = 'moderate'; scoreText = 'Mittel'; }

            let modalContent = `
                <div class="modal-category">
                    <div style="background: rgba(69,123,157,0.1); padding: 12px; border-radius: 10px; margin-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="color: var(--text-secondary); font-size: 12px;">Aktuelle Kombination</span>
                            <span style="font-size: 18px; font-weight: 700; color: var(--${scoreClass === 'good' ? 'primary' : scoreClass === 'moderate' ? 'warning' : 'danger'});">${catScore}%</span>
                        </div>
                        <div style="font-size: 14px; font-weight: 600; color: var(--text-primary);">
                            <span style="color: #2ecc71;">${ichArch?.name || currentArchetype}</span>
                            <span style="color: var(--text-muted);"> Ã— </span>
                            <span style="color: #e74c3c;">${partnerArch?.name || selectedPartner}</span>
                        </div>
                        <div style="font-size: 11px; color: var(--text-muted); margin-top: 4px;">${scoreText} in dieser Kategorie</div>
                    </div>

                    <div class="modal-category-header">
                        <div class="modal-category-letter">${cat}</div>
                        <div class="modal-category-name">${catNames[cat]}</div>
                    </div>
                    <div class="modal-category-desc">${catInfo.description || 'Keine Beschreibung verfÃ¼gbar.'}</div>
            `;

            if (catInfo.subDimensions && catInfo.subDimensions.length > 0) {
                modalContent += `
                    <div class="definition-section">
                        <div class="definition-section-title">Subdimensionen <span style="font-size: 10px; color: var(--text-muted);">(klicken fÃ¼r Details)</span></div>
                        <ul class="definition-list variants clickable-subs">
                            ${catInfo.subDimensions.map(sub => `<li onclick="showSubDimensionInfo('${cat}', '${sub.replace(/'/g, "\\'")}')" style="cursor: pointer; padding: 8px; border-radius: 6px; transition: background 0.2s;" onmouseover="this.style.background='rgba(255,255,255,0.1)'" onmouseout="this.style.background='transparent'">${sub} <span style="color: var(--text-muted); font-size: 10px;">â†’</span></li>`).join('')}
                        </ul>
                    </div>
                `;
            }

            modalContent += '</div>';

            document.getElementById('modalTitle').textContent = `QualitÃ¤tsmuster ${cat}: ${catNames[cat]}`;
            document.getElementById('modalBody').innerHTML = modalContent;
            document.getElementById('categoryModal').classList.add('active');
        }

        const subDimensionData = {
            "ExklusivitÃ¤ts-Erwartung": {
                was: "Die Erwartung, der einzige romantische/sexuelle Partner zu sein.",
                warum: "Diese Dimension ist fundamental, weil unterschiedliche Erwartungen zu EnttÃ¤uschung, Eifersucht und VertrauensbrÃ¼chen fÃ¼hren kÃ¶nnen.",
                wozu: "Klare Erwartungen verhindern MissverstÃ¤ndnisse und schaffen eine gemeinsame Basis fÃ¼r die Beziehungsgestaltung.",
                archetypen: {
                    single: "Flexibel - keine feste Erwartung, offen fÃ¼r verschiedene Modelle",
                    duo: "Hohe Erwartung an vollstÃ¤ndige ExklusivitÃ¤t",
                    duo_flex: "GrundsÃ¤tzlich exklusiv, aber mit Ausnahmen nach Absprache",
                    solopoly: "Keine ExklusivitÃ¤tserwartung - jede Beziehung ist eigenstÃ¤ndig",
                    polyamor: "Bewusste Nicht-ExklusivitÃ¤t mit klaren Strukturen",
                    ra: "Keine normativen ExklusivitÃ¤tserwartungen - alles verhandelbar",
                    lat: "Flexibel - ExklusivitÃ¤t ist unabhÃ¤ngig von Wohnsituation",
                    aromantisch: "Romantische ExklusivitÃ¤t nicht relevant - andere Verbindungen zÃ¤hlen"
                }
            },
            "Offenheit fÃ¼r alternative Modelle": {
                was: "Die Bereitschaft, nicht-traditionelle Beziehungsformen zu akzeptieren oder auszuprobieren.",
                warum: "Unterschiedliche Offenheit kann zu Konflikten fÃ¼hren, wenn ein Partner expandieren mÃ¶chte und der andere nicht.",
                wozu: "Gemeinsame Offenheit ermÃ¶glicht Wachstum und Anpassung der Beziehung an verÃ¤nderte BedÃ¼rfnisse.",
                archetypen: {
                    single: "Oft sehr offen - keine festgelegte Struktur",
                    duo: "Tendenziell geschlossen - Monogamie als Ideal",
                    duo_flex: "Moderat offen - bereit fÃ¼r situative Anpassungen",
                    solopoly: "Sehr offen - lebt bereits alternatives Modell",
                    polyamor: "Strukturiert offen - klare Rahmen fÃ¼r Vielfalt",
                    ra: "Maximal offen - alle Normen werden hinterfragt",
                    lat: "Moderat offen - alternative Wohnform wird bereits gelebt",
                    aromantisch: "Offen fÃ¼r alternative Beziehungsformen - Romantik ist nicht zentral"
                }
            },
            "Beziehung als Lebensinhalt vs. Lebensbereich": {
                was: "Wie zentral ist die Beziehung im Leben? Ist sie alles oder ein Teil von vielem?",
                warum: "Wenn einer die Beziehung als Lebensmittelpunkt sieht und der andere als Nebensache, entstehen ungleiche Investitionen.",
                wozu: "Ã„hnliche Priorisierung schafft Balance und verhindert das GefÃ¼hl von VernachlÃ¤ssigung oder Ãœberforderung.",
                archetypen: {
                    single: "Lebensbereich - das eigene Leben steht im Zentrum",
                    duo: "Oft Lebensinhalt - die Beziehung ist sehr wichtig",
                    duo_flex: "Wichtiger Lebensbereich mit hoher PrioritÃ¤t",
                    solopoly: "Klar Lebensbereich - das Selbst bleibt Zentrum",
                    polyamor: "Wichtiger Lebensbereich - aber mit mehreren Beziehungen",
                    ra: "Lebensbereich - Autonomie und Selbstbestimmung zentral",
                    lat: "Wichtiger Lebensbereich - aber eigener Raum ist essentiell",
                    aromantisch: "Lebensbereich - Freundschaften und andere Verbindungen zentral"
                }
            },
            "Definition von Treue": {
                was: "Was bedeutet 'treu sein' konkret? KÃ¶rperliche ExklusivitÃ¤t, emotionale Treue, oder Ehrlichkeit?",
                warum: "Unterschiedliche Definitionen fÃ¼hren oft zu den schmerzhaftesten MissverstÃ¤ndnissen in Beziehungen.",
                wozu: "Eine gemeinsame Definition von Treue schafft Klarheit und Vertrauen - unabhÃ¤ngig davon, wie sie aussieht.",
                archetypen: {
                    single: "Flexibel - Treue ist kontextabhÃ¤ngig",
                    duo: "Klassisch - kÃ¶rperliche UND emotionale ExklusivitÃ¤t",
                    duo_flex: "Angepasst - emotionale Treue wichtiger als kÃ¶rperliche",
                    solopoly: "Neu definiert - Treue = Ehrlichkeit und Transparenz",
                    polyamor: "Strukturiert - Treue zu vereinbarten Regeln und Grenzen",
                    ra: "Individuell definiert - Treue ist nicht normativ vorgegeben",
                    lat: "Emotionale Treue wichtig - unabhÃ¤ngig von Wohnsituation",
                    aromantisch: "Treue zu Absprachen - romantische Treue nicht relevant"
                }
            },
            "Ethische Grundhaltung": {
                was: "Die gemeinsamen Werte wie Ehrlichkeit, Respekt, Consent und Fairness.",
                warum: "Unterschiedliche ethische Grundhaltungen untergraben das Fundament jeder Beziehung und fÃ¼hren zu Vertrauensverlust.",
                wozu: "Geteilte ethische Werte schaffen ein sicheres Fundament fÃ¼r alle anderen Aspekte der Beziehung.",
                archetypen: {
                    single: "Individuell geprÃ¤gt - eigene ethische Standards",
                    duo: "Traditionell - gesellschaftliche Normen als Leitfaden",
                    duo_flex: "Reflektiert - bewusste Auseinandersetzung mit Normen",
                    solopoly: "Progressiv - aktive ethische Reflexion",
                    polyamor: "Strukturiert ethisch - klare Regeln fÃ¼r fairen Umgang",
                    ra: "Anarchisch-ethisch - Normen werden radikal hinterfragt",
                    lat: "Autonom-ethisch - Respekt vor individuellem Raum",
                    aromantisch: "Authentisch - Ehrlichkeit Ã¼ber eigene Grenzen"
                }
            },
            "Verantwortungsbewusstsein": {
                was: "Die Bereitschaft, Verantwortung fÃ¼r eigene Handlungen und deren Auswirkungen zu Ã¼bernehmen.",
                warum: "Ohne Verantwortungsbewusstsein werden Fehler wiederholt und Partner verletzt.",
                wozu: "Verantwortung ermÃ¶glicht Wachstum, Reparatur nach Konflikten und nachhaltige BeziehungsqualitÃ¤t.",
                archetypen: {
                    single: "PrimÃ¤r fÃ¼r sich selbst verantwortlich",
                    duo: "Hohe gegenseitige Verantwortung erwartet",
                    duo_flex: "Balancierte Verantwortung mit FlexibilitÃ¤t",
                    solopoly: "Selbstverantwortung betont, aber fair zu Partnern",
                    polyamor: "Komplexe Verantwortung fÃ¼r mehrere Beziehungen",
                    ra: "Hohe Selbstverantwortung - keine normativen Erwartungen",
                    lat: "Verantwortung fÃ¼r BeziehungsqualitÃ¤t trotz Distanz",
                    aromantisch: "Verantwortung fÃ¼r klare Kommunikation der Grenzen"
                }
            },
            "Emotionale Verschmelzungs-Tendenz": {
                was: "Das BedÃ¼rfnis, emotional mit dem Partner zu verschmelzen - von 'wir sind eins' bis 'wir sind zwei'.",
                warum: "Starke Unterschiede fÃ¼hren dazu, dass einer sich eingeengt und der andere sich abgelehnt fÃ¼hlt.",
                wozu: "Ã„hnliche Verschmelzungs-PrÃ¤ferenzen ermÃ¶glichen eine NÃ¤he, die sich fÃ¼r beide richtig anfÃ¼hlt.",
                archetypen: {
                    single: "Niedrig - Autonomie steht vor Verschmelzung",
                    duo: "Oft hoch - 'Wir' als zentrale IdentitÃ¤t",
                    duo_flex: "Moderat - NÃ¤he mit Grenzen",
                    solopoly: "Niedrig - bewusste Distanz zu Verschmelzung",
                    polyamor: "Differenziert - unterschiedlich mit verschiedenen Partnern",
                    ra: "Niedrig - Autonomie ist zentraler Wert",
                    lat: "Moderat - emotionale NÃ¤he ohne rÃ¤umliche Verschmelzung",
                    aromantisch: "Niedrig - romantische Verschmelzung nicht gewÃ¼nscht"
                }
            },
            "Physische NÃ¤he-BedÃ¼rfnisse": {
                was: "Wie viel kÃ¶rperliche PrÃ¤senz und NÃ¤he braucht man? Zusammenleben, tÃ¤glicher Kontakt, wÃ¶chentlich?",
                warum: "Mismatches fÃ¼hren zu Einsamkeit (bei zu wenig) oder Erstickung (bei zu viel).",
                wozu: "Abgestimmte NÃ¤he-BedÃ¼rfnisse ermÃ¶glichen, dass beide sich gesehen und respektiert fÃ¼hlen.",
                archetypen: {
                    single: "Flexibel - kein konstantes NÃ¤he-BedÃ¼rfnis",
                    duo: "Hoch - oft Wunsch nach Zusammenleben",
                    duo_flex: "Moderat bis hoch mit Freiraum-Phasen",
                    solopoly: "Bewusst niedrig - eigener Wohnraum wichtig",
                    polyamor: "Komplex - unterschiedliche NÃ¤he mit verschiedenen Partnern",
                    ra: "Individuell verhandelbar - keine normativen Erwartungen",
                    lat: "Bewusst niedrig - getrennte Wohnungen als Prinzip",
                    aromantisch: "Variabel - nicht an romantische NÃ¤he gebunden"
                }
            },
            "FÃ¤higkeit, Raum zu geben": {
                was: "Die FÃ¤higkeit, dem Partner Freiraum zu lassen ohne sich vernachlÃ¤ssigt oder unsicher zu fÃ¼hlen.",
                warum: "Ohne diese FÃ¤higkeit entstehen Kontrolle, Eifersucht und Erstickung der Beziehung.",
                wozu: "Raum geben kÃ¶nnen ermÃ¶glicht individuelle Entwicklung innerhalb der Beziehung.",
                archetypen: {
                    single: "Hoch - Raum ist selbstverstÃ¤ndlich",
                    duo: "Muss oft gelernt werden - NÃ¤he ist Standard",
                    duo_flex: "Bewusst entwickelt - wichtig fÃ¼r das Modell",
                    solopoly: "Sehr hoch - Teil der Grundphilosophie",
                    polyamor: "Essentiell - strukturell eingebaut",
                    ra: "Maximal - Autonomie als hÃ¶chster Wert",
                    lat: "Sehr hoch - rÃ¤umlicher Freiraum ist zentral",
                    aromantisch: "Hoch - respektiert nicht-romantische Grenzen"
                }
            },
            "Individuelle Freiheit": {
                was: "Der Wert, den man persÃ¶nlicher Freiheit in der Beziehung beimisst - eigene Entscheidungen, Hobbies, Freunde.",
                warum: "Unterschiedliche FreiheitsbedÃ¼rfnisse fÃ¼hren zu MachtkÃ¤mpfen oder Entfremdung.",
                wozu: "Respektierte Freiheit ermÃ¶glicht authentisches Selbst und verhindert Resentment.",
                archetypen: {
                    single: "Maximale Freiheit - das KernbedÃ¼rfnis",
                    duo: "EingeschrÃ¤nkt - Kompromisse erwartet",
                    duo_flex: "Balanciert - Freiheit mit RÃ¼cksichtnahme",
                    solopoly: "Maximal - Autonomie ist nicht verhandelbar",
                    polyamor: "Hoch - aber mit Verantwortung verbunden",
                    ra: "Maximal - Freiheit von allen Normen",
                    lat: "Hoch - rÃ¤umliche Autonomie garantiert Freiheit",
                    aromantisch: "Hoch - Freiheit von romantischen Erwartungen"
                }
            },
            "Entscheidungsautonomie": {
                was: "Wer entscheidet was? Wie viel Mitsprache hat der Partner bei persÃ¶nlichen Entscheidungen?",
                warum: "Konflikte entstehen, wenn einer Kontrolle erwartet und der andere Autonomie braucht.",
                wozu: "Klare Entscheidungsstrukturen verhindern MachtkÃ¤mpfe und schaffen Klarheit.",
                archetypen: {
                    single: "VollstÃ¤ndig - alle Entscheidungen selbst",
                    duo: "Oft geteilt - wichtige Dinge gemeinsam",
                    duo_flex: "Hybrid - manche gemeinsam, manche allein",
                    solopoly: "Hoch - Autonomie auch in der Beziehung",
                    polyamor: "Komplex - unterschiedlich je nach Beziehung",
                    ra: "Maximal - keine externen Vorgaben akzeptiert",
                    lat: "Hoch - eigene Entscheidungen im eigenen Raum",
                    aromantisch: "Hoch - Entscheidungen nicht an romantischen Normen orientiert"
                }
            },
            "Akzeptanz der Autonomie des anderen": {
                was: "Die FÃ¤higkeit zu akzeptieren, dass der Partner eigene Entscheidungen trifft - auch wenn man nicht zustimmt.",
                warum: "Fehlende Akzeptanz fÃ¼hrt zu Kontrolle, Manipulation und Vertrauensverlust.",
                wozu: "Akzeptanz ermÃ¶glicht echte Partnerschaft statt AbhÃ¤ngigkeit.",
                archetypen: {
                    single: "Hoch - Autonomie wird geschÃ¤tzt",
                    duo: "Muss oft gelernt werden",
                    duo_flex: "Bewusst entwickelt",
                    solopoly: "Sehr hoch - zentral fÃ¼r das Modell",
                    polyamor: "Essentiell - ohne geht es nicht",
                    ra: "Maximal - Grundprinzip der Beziehungsphilosophie",
                    lat: "Hoch - respektiert rÃ¤umliche Autonomie des anderen",
                    aromantisch: "Hoch - akzeptiert nicht-romantische BedÃ¼rfnisse"
                }
            },
            "Kommunikationstiefe": {
                was: "Wie tief gehen GesprÃ¤che? Von Alltag bis zu Ã„ngsten, TrÃ¤umen und Verletzlichkeit.",
                warum: "Unterschiedliche Tiefen-PrÃ¤ferenzen fÃ¼hren zu Frustration - einer will mehr, einer weniger.",
                wozu: "Passende Kommunikationstiefe schafft echte Verbindung und VerstÃ¤ndnis.",
                archetypen: {
                    single: "Variabel - je nach Beziehung",
                    duo: "Oft hoch - alles teilen als Ideal",
                    duo_flex: "Selektiv tief - wichtiges wird geteilt",
                    solopoly: "Bewusst tief - Kommunikation ist essentiell",
                    polyamor: "Hoch - KomplexitÃ¤t erfordert Kommunikation",
                    ra: "Individuell - keine normativen Erwartungen an Tiefe",
                    lat: "QualitÃ¤tsfokussiert - tiefe GesprÃ¤che in begrenzter Zeit",
                    aromantisch: "Authentisch - tiefe Verbindung ohne romantische Komponente"
                }
            },
            "KonfliktfÃ¤higkeit": {
                was: "Wie geht man mit Konflikten um? Vermeidung, Eskalation, konstruktive LÃ¶sung?",
                warum: "Unterschiedliche Stile fÃ¼hren dazu, dass Konflikte ungelÃ¶st bleiben oder eskalieren.",
                wozu: "Kompatible KonfliktfÃ¤higkeit ermÃ¶glicht Wachstum durch Krisen statt ZerstÃ¶rung.",
                archetypen: {
                    single: "Kann Konflikte vermeiden durch Distanz",
                    duo: "Muss Konflikte lÃ¶sen - kein Entkommen",
                    duo_flex: "Flexibel - manchmal Distanz, manchmal LÃ¶sung",
                    solopoly: "Klar - bei UnlÃ¶sbarkeit kann man gehen",
                    polyamor: "Entwickelt - Kommunikation als LÃ¶sung",
                    ra: "Individuell - keine externen KonfliktlÃ¶sungsmodelle",
                    lat: "Distanz mÃ¶glich - rÃ¤umliche Trennung als Puffer",
                    aromantisch: "Sachlich - nicht-romantische KonfliktlÃ¶sung"
                }
            },
            "Emotionale Transparenz": {
                was: "Wie offen teilt man GefÃ¼hle? Alles aussprechen oder manches fÃ¼r sich behalten?",
                warum: "Unterschiede fÃ¼hren zu MissverstÃ¤ndnissen - einer fÃ¼hlt sich verschlossen, der andere Ã¼berfordert.",
                wozu: "Abgestimmte Transparenz schafft Vertrauen ohne Ãœberforderung.",
                archetypen: {
                    single: "Selektiv - teilt was nÃ¶tig ist",
                    duo: "Oft hohe Erwartung an Transparenz",
                    duo_flex: "Balanciert - wichtiges wird geteilt",
                    solopoly: "Hoch - Ehrlichkeit ist zentral",
                    polyamor: "Sehr hoch - Basis des Modells",
                    ra: "Individuell - keine normativen Transparenz-Erwartungen",
                    lat: "Qualitativ - tiefe GesprÃ¤che in begrenzter Zeit",
                    aromantisch: "Ehrlich - klar Ã¼ber eigene Grenzen"
                }
            },
            "Gesellschaftliche Akzeptanz": {
                was: "Wie wichtig ist es, dass Familie, Freunde und Gesellschaft die Beziehung akzeptieren?",
                warum: "Unterschiedliche Wichtigkeit fÃ¼hrt zu Konflikten Ã¼ber 'Outing' und Ã¶ffentliches Auftreten.",
                wozu: "Ã„hnliche Wichtigkeit ermÃ¶glicht einen gemeinsamen Umgang mit dem sozialen Umfeld.",
                archetypen: {
                    single: "Unkompliziert - gesellschaftlich akzeptiert",
                    duo: "Sehr wichtig - passt zur Norm",
                    duo_flex: "Moderat - gewisse ErklÃ¤rungen nÃ¶tig",
                    solopoly: "Weniger wichtig - lebt gegen die Norm",
                    polyamor: "Komplex - manche Offenheit, manche Diskretion",
                    ra: "Unwichtig - gesellschaftliche Normen werden abgelehnt",
                    lat: "ErklÃ¤rungsbedÃ¼rftig - 'Warum wohnt ihr nicht zusammen?'",
                    aromantisch: "Herausfordernd - romantische Norm ist tief verankert"
                }
            },
            "Integration in soziale Kreise": {
                was: "Wie wird die Beziehung in Freundeskreis, Familie und Arbeit integriert und prÃ¤sentiert?",
                warum: "Unterschiede fÃ¼hren zu Frustration - einer will prÃ¤sentieren, der andere verstecken.",
                wozu: "Gemeinsame Strategien fÃ¼r soziale Integration schaffen ein einheitliches Auftreten.",
                archetypen: {
                    single: "Einfach - keine komplexe Integration nÃ¶tig",
                    duo: "VollstÃ¤ndig - Partner wird Ã¼berall eingefÃ¼hrt",
                    duo_flex: "Weitgehend - mit gewissen Grenzen",
                    solopoly: "Selektiv - nicht Ã¼berall erklÃ¤rbar",
                    polyamor: "Komplex - unterschiedlich je nach Umfeld",
                    ra: "Individuell - Integration nach eigenen Regeln",
                    lat: "ErklÃ¤rungsbedÃ¼rftig - getrennte Wohnungen irritieren",
                    aromantisch: "Herausfordernd - 'Nur Freunde?' wird oft missverstanden"
                }
            },
            "Umgang mit Stigma": {
                was: "Wie geht man mit negativen Reaktionen auf die Beziehungsform um? ErklÃ¤ren, ignorieren, kÃ¤mpfen?",
                warum: "Unterschiedliche Strategien fÃ¼hren zu Konflikten darÃ¼ber, wie man als Paar auftritt.",
                wozu: "Gemeinsame Strategie stÃ¤rkt die Beziehung gegen Ã¤uÃŸeren Druck.",
                archetypen: {
                    single: "Kaum Stigma - gesellschaftlich normal",
                    duo: "Kein Stigma - das Ideal der Gesellschaft",
                    duo_flex: "Leichtes Stigma - 'offene Beziehung'",
                    solopoly: "Erhebliches Stigma - schwer erklÃ¤rbar",
                    polyamor: "Stigma vorhanden - aber zunehmend bekannt",
                    ra: "Hohes Stigma - radikale Position wird missverstanden",
                    lat: "Moderates Stigma - 'echte' Beziehung in Frage gestellt",
                    aromantisch: "Hohes Stigma - wird als Defizit wahrgenommen"
                }
            }
        };

        function showSubDimensionInfo(cat, subName) {
            const subData = subDimensionData[subName] || { was: "Keine Beschreibung verfÃ¼gbar.", warum: "", wozu: "", archetypen: {} };
            const catNames = {
                A: 'Beziehungsphilosophie',
                B: 'Werte-Alignment',
                C: 'NÃ¤he-Distanz',
                D: 'Autonomie',
                E: 'Kommunikation',
                F: 'Soziale KompatibilitÃ¤t'
            };

            const ichArch = data?.archetypes?.[currentArchetype];
            const partnerArch = data?.archetypes?.[selectedPartner];
            const ichId = currentArchetype;
            const partnerId = selectedPartner;

            const ichPerspektive = subData.archetypen?.[ichId] || "Keine Daten";
            const partnerPerspektive = subData.archetypen?.[partnerId] || "Keine Daten";

            let modalContent = `
                <div style="background: rgba(69,123,157,0.1); padding: 12px; border-radius: 10px; margin-bottom: 15px;">
                    <div style="font-size: 11px; color: var(--text-muted);">Teil von QualitÃ¤tsmuster ${cat}: ${catNames[cat]}</div>
                </div>

                <div style="margin-bottom: 15px;">
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">WAS?</div>
                    <p style="color: var(--text-primary); line-height: 1.5;">${subData.was}</p>
                </div>

                <div style="margin-bottom: 15px;">
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">WARUM WICHTIG?</div>
                    <p style="color: var(--text-secondary); line-height: 1.5;">${subData.warum}</p>
                </div>

                <div style="margin-bottom: 20px;">
                    <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 4px;">WOZU?</div>
                    <p style="color: var(--text-secondary); line-height: 1.5;">${subData.wozu}</p>
                </div>

                <div style="background: rgba(46,204,113,0.1); padding: 12px; border-radius: 10px; margin-bottom: 10px;">
                    <div style="font-size: 12px; color: #2ecc71; font-weight: 600; margin-bottom: 8px;">ICH (${ichArch?.name || ichId}):</div>
                    <p style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">${ichPerspektive}</p>
                </div>

                <div style="background: rgba(231,76,60,0.1); padding: 12px; border-radius: 10px; margin-bottom: 15px;">
                    <div style="font-size: 12px; color: #e74c3c; font-weight: 600; margin-bottom: 8px;">PARTNER (${partnerArch?.name || partnerId}):</div>
                    <p style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">${partnerPerspektive}</p>
                </div>

                <div style="background: rgba(108, 117, 125, 0.1); padding: 12px; border-radius: 10px;">
                    <div style="font-size: 12px; color: #6c757d; font-weight: 600; margin-bottom: 8px;">BEDEUTUNG FÃœR EURE KOMBINATION:</div>
                    <p style="color: var(--text-secondary); font-size: 12px; line-height: 1.5;">${generateCombinationAnalysis(ichId, partnerId, subName, subData)}</p>
                </div>
            `;

            document.getElementById('modalTitle').textContent = subName;
            document.getElementById('modalBody').innerHTML = modalContent;
        }

        function generateCombinationAnalysis(ichId, partnerId, subName, subData) {
            if (ichId === partnerId) {
                return `Da ihr beide denselben Archetyp habt, solltet ihr hier Ã¤hnliche Vorstellungen haben. Das reduziert Konfliktpotential in dieser Dimension erheblich.`;
            }

            const polyTypes = ['solopoly', 'polyamor', 'ra'];
            const monoTypes = ['single', 'duo', 'duo_flex', 'lat', 'aromantisch'];
            const ichIsPoly = polyTypes.includes(ichId);
            const partnerIsPoly = polyTypes.includes(partnerId);

            if (ichIsPoly !== partnerIsPoly) {
                return `Hier treffen fundamental unterschiedliche Weltanschauungen aufeinander. Ein Poly-Typ und ein Mono-Typ haben oft gegensÃ¤tzliche Perspektiven auf "${subName}". Intensive Kommunikation und gegenseitiges VerstÃ¤ndnis sind essentiell.`;
            }

            if (ichIsPoly && partnerIsPoly) {
                return `Als zwei Poly-Typen teilt ihr grundsÃ¤tzlich Ã¤hnliche Werte in dieser Dimension. Die Unterschiede liegen eher in der konkreten Ausgestaltung als in den Grundprinzipien.`;
            }

            return `Eure Archetypen haben unterschiedliche Schwerpunkte in dieser Dimension. Offene GesprÃ¤che darÃ¼ber, was euch beiden wichtig ist, helfen, gemeinsame LÃ¶sungen zu finden.`;
        }

        // NEU: Generiere dynamische Pro/Contra aus Micro-Statements
        function generateDynamicProContra(type1, type2, dims1, dims2) {
            const pro = [];
            const contra = [];

            // 1. Archetyp-basierte Pro/Contra
            const archStatements = getArchetypeStatements(type1, type2);
            if (archStatements) {
                pro.push(...(archStatements.pro || []));
                contra.push(...(archStatements.contra || []));
            }

            // 2. Dominanz-basierte Pro/Contra hinzufÃ¼gen
            const domStatements = getDominanceStatements(dims1?.dominanz, dims2?.dominanz);
            if (domStatements && domStatements.pro) {
                // FÃ¼ge nur die relevantesten hinzu, um Doppelungen zu vermeiden
                domStatements.pro.slice(0, 2).forEach(p => {
                    if (!pro.includes(p)) pro.push(p);
                });
            }
            if (domStatements && domStatements.contra) {
                domStatements.contra.slice(0, 2).forEach(c => {
                    if (!contra.includes(c)) contra.push(c);
                });
            }

            return { pro, contra };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // KOMBINIERTES SYNTHESE-SYSTEM (A+B+C)
        // A) Score â†’ TonalitÃ¤t (positiv/neutral/kritisch)
        // B) Hash aus 4 Faktoren â†’ deterministische Variation
        // C) 6 Kategorien + Templates â†’ ZusammenfÃ¼hrung
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Berechnet einen deterministischen Hash aus den 4 Faktoren
         * Gibt einen Index zurÃ¼ck, der fÃ¼r Statement-Auswahl verwendet wird
         */
        function getFactorHash(archetypScore, dominanzScore, orientierungScore, geschlechtScore) {
            // Einfacher aber deterministischer Hash basierend auf allen 4 Faktoren
            const combined = (archetypScore * 1000000) + (dominanzScore * 10000) + (orientierungScore * 100) + geschlechtScore;
            // Verwende Modulo um einen Index zu bekommen
            return combined;
        }

        /**
         * WÃ¤hlt ein Statement deterministisch aus einem Array basierend auf Hash
         */
        function selectStatementByHash(statements, hash) {
            if (!statements || statements.length === 0) return null;
            const index = hash % statements.length;
            return statements[index];
        }

        /**
         * Bestimmt die TonalitÃ¤t basierend auf dem Gesamtscore
         * @returns 'positiv' | 'neutral' | 'kritisch'
         */
        function getTonality(score) {
            if (score >= 70) return 'positiv';
            if (score >= 50) return 'neutral';
            return 'kritisch';
        }

        /**
         * TonalitÃ¤ts-Templates fÃ¼r die Synthese-Einleitungen
         */
        const tonalityTemplates = {
            positiv: {
                pathos: [
                    "Eine vielversprechende Resonanz entsteht zwischen euch.",
                    "Die emotionale Chemie deutet auf tiefes Potenzial hin.",
                    "Eure Energien harmonieren auf einer fundamentalen Ebene."
                ],
                logos: [
                    "Die strukturelle KompatibilitÃ¤t bildet eine solide Basis.",
                    "Eure Beziehungsphilosophien ergÃ¤nzen sich konstruktiv.",
                    "Das rationale Fundament ermÃ¶glicht fruchtbare Kommunikation."
                ]
            },
            neutral: {
                pathos: [
                    "Eine interessante Dynamik entfaltet sich zwischen euch.",
                    "Die emotionale Landschaft bietet sowohl Chancen als auch Herausforderungen.",
                    "Eure Energien begegnen sich â€“ was daraus wird, liegt in euren HÃ¤nden."
                ],
                logos: [
                    "Die strukturellen Unterschiede erfordern bewusste Navigation.",
                    "Eure Beziehungsvorstellungen haben Ãœberschneidungen, aber auch Differenzen.",
                    "Dialog und KlÃ¤rung werden wichtig sein fÃ¼r das gegenseitige VerstÃ¤ndnis."
                ]
            },
            kritisch: {
                pathos: [
                    "Die emotionalen Welten prallen aufeinander.",
                    "Spannungen auf der GefÃ¼hlsebene sind zu erwarten.",
                    "Die unterschiedlichen emotionalen BedÃ¼rfnisse erfordern besondere Achtsamkeit."
                ],
                logos: [
                    "Fundamentale Unterschiede in den Beziehungsvorstellungen werden sichtbar.",
                    "Die strukturellen Differenzen stellen eine erhebliche Herausforderung dar.",
                    "Grundlegende GesprÃ¤che Ã¼ber Erwartungen sind unerlÃ¤sslich."
                ]
            }
        };

        /**
         * Kategorie-spezifische Synthese-Bausteine fÃ¼r die 6 Bereiche
         */
        const categorySynthesisTemplates = {
            A: { // Beziehungsphilosophie
                name: "Beziehungsphilosophie",
                positiv: "Eure Grundhaltungen zu Beziehungen harmonieren.",
                neutral: "Eure Beziehungsphilosophien haben gemeinsame Punkte, aber auch Unterschiede.",
                kritisch: "Fundamentale Differenzen in der Beziehungsphilosophie erfordern KlÃ¤rung."
            },
            B: { // Werte-Alignment
                name: "Werte-Alignment",
                positiv: "Geteilte Werte bilden ein stabiles Fundament.",
                neutral: "Manche Werte teilt ihr, andere unterscheiden sich.",
                kritisch: "Unterschiedliche Wertevorstellungen kÃ¶nnen zu Konflikten fÃ¼hren."
            },
            C: { // NÃ¤he-Distanz
                name: "NÃ¤he-Distanz",
                positiv: "Eure BedÃ¼rfnisse nach NÃ¤he und Raum passen gut zusammen.",
                neutral: "Die Balance zwischen NÃ¤he und Distanz wird Kommunikation erfordern.",
                kritisch: "Unterschiedliche NÃ¤he-Distanz-BedÃ¼rfnisse kÃ¶nnen Spannung erzeugen."
            },
            D: { // Autonomie
                name: "Autonomie",
                positiv: "Ihr respektiert gegenseitig eure UnabhÃ¤ngigkeit.",
                neutral: "Das Autonomie-VerstÃ¤ndnis bedarf weiterer Abstimmung.",
                kritisch: "Konfliktpotenzial bei unterschiedlichen Autonomie-Erwartungen."
            },
            E: { // Kommunikation
                name: "Kommunikation",
                positiv: "Die Basis fÃ¼r fruchtbaren Dialog ist gegeben.",
                neutral: "Kommunikationsstile unterscheiden sich â€“ Anpassung mÃ¶glich.",
                kritisch: "Unterschiedliche Kommunikationsweisen kÃ¶nnen MissverstÃ¤ndnisse erzeugen."
            },
            F: { // Soziale KompatibilitÃ¤t
                name: "Soziale KompatibilitÃ¤t",
                positiv: "Soziale Vorstellungen und Umfelder harmonieren.",
                neutral: "Soziale KompatibilitÃ¤t ist teilweise gegeben.",
                kritisch: "Unterschiedliche soziale Erwartungen kÃ¶nnen belasten."
            }
        };

        /**
         * Generiert detaillierte Pathos-Inhalte mit ICH/Partner/Synthese Struktur
         * Nutzt PathosTextGenerator fÃ¼r flieÃŸende, poetische Texte
         * @returns {Object} { ich, partner, synthese, resonanz }
         */
        function generateDetailedPathos(ichArch, partnerArch) {
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';
            const ichId = ichArch?.id || currentArchetype || '';
            const partnerId = partnerArch?.id || selectedPartner || '';

            // Berechne die 4 Faktor-Scores
            const person1 = {
                archetyp: ichId,
                dominanz: personDimensions.ich?.dominanz,
                orientierung: personDimensions.ich?.orientierung,
                geschlecht: personDimensions.ich?.geschlecht,
                orientierungStatus: personDimensions.ich?.orientierungStatus
            };
            const person2 = {
                archetyp: partnerId,
                dominanz: personDimensions.partner?.dominanz,
                orientierung: personDimensions.partner?.orientierung,
                geschlecht: personDimensions.partner?.geschlecht,
                orientierungStatus: personDimensions.partner?.orientierungStatus
            };

            // Hole Score-Breakdown
            const qualityResult = calculateRelationshipQuality(person1, person2);
            const breakdown = qualityResult.breakdown || { archetyp: 50, dominanz: 75, orientierung: 100, geschlecht: 100 };
            const overallScore = qualityResult.score || 50;
            const resonanzData = qualityResult.resonanz;
            const tonality = getTonality(overallScore);

            // Hole Statement-Quellen
            const archStatements = getArchetypeStatements(ichId, partnerId);
            const domStatements = getDominanceStatements(person1.dominanz, person2.dominanz);
            const orientStatements = getOrientierungStatements(person1.orientierung, person2.orientierung, person1.geschlecht, person2.geschlecht);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NUTZE PATHOS TEXT GENERATOR (wenn verfÃ¼gbar)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof PathosTextGenerator !== 'undefined') {
                // Extrahiere primitive Werte fÃ¼r Hash (dominanz kann Objekt sein)
                const dom1 = typeof person1.dominanz === 'object' ? (person1.dominanz?.primary || 'none') : (person1.dominanz || 'none');
                const dom2 = typeof person2.dominanz === 'object' ? (person2.dominanz?.primary || 'none') : (person2.dominanz || 'none');

                // Generiere deterministischen Hash fÃ¼r Varianz
                const seed = PathosTextGenerator.generateHash(
                    ichId, partnerId,
                    dom1,
                    dom2,
                    overallScore
                );

                // ICH BRINGT MIT - Poetischer FlieÃŸtext
                const ichText = PathosTextGenerator.generatePersonText(
                    ichArch,
                    personDimensions.ich,
                    ichName,
                    seed
                );

                // PARTNER BRINGT MIT - Poetischer FlieÃŸtext
                const partnerText = PathosTextGenerator.generatePersonText(
                    partnerArch,
                    personDimensions.partner,
                    partnerName,
                    seed + 100
                );

                // DARAUS ENTSTEHT - Poetische Synthese
                const syntheseText = PathosTextGenerator.generateSyntheseText({
                    ichArch,
                    partnerArch,
                    ichName,
                    partnerName,
                    ichDimensions: personDimensions.ich,
                    partnerDimensions: personDimensions.partner,
                    overallScore,
                    archStatements,
                    domStatements,
                    orientStatements,
                    seed
                });

                // RESONANZ - Poetische Interpretation
                let resonanzText = null;
                if (resonanzData && resonanzData.R !== undefined) {
                    resonanzText = PathosTextGenerator.generateResonanzText(
                        resonanzData.R,
                        seed + 200
                    );
                }

                return {
                    ich: ichText,
                    partner: partnerText,
                    synthese: syntheseText,
                    resonanz: resonanzText,
                    score: overallScore,
                    tonality: tonality
                };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FALLBACK: Original-Logik (wenn PathosTextGenerator nicht geladen)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const hash = getFactorHash(breakdown.archetyp, breakdown.dominanz, breakdown.orientierung, breakdown.geschlecht);

            // ICH BRINGT MIT
            const ichParts = [];
            if (ichArch?.pirsig?.dynamicQuality !== undefined) {
                const dynQual = ichArch.pirsig.dynamicQuality;
                if (dynQual >= 0.7) {
                    ichParts.push(`${ichName} bringt eine hohe dynamische Energie mit â€“ offen fÃ¼r VerÃ¤nderung und spontane Verbindung.`);
                } else if (dynQual >= 0.4) {
                    ichParts.push(`${ichName} balanciert zwischen StabilitÃ¤t und Beweglichkeit in der emotionalen Welt.`);
                } else {
                    ichParts.push(`${ichName} sucht emotionale Tiefe durch BestÃ¤ndigkeit und vertraute Muster.`);
                }
            }
            if (ichArch?.osho?.naturalness >= 0.7) {
                ichParts.push(`Emotionale AuthentizitÃ¤t steht im Vordergrund â€“ ${ichName} folgt dem natÃ¼rlichen Fluss der GefÃ¼hle.`);
            }
            const ichDom = person1.dominanz;
            if (ichDom) {
                const domText = {
                    'dominant': `Als FÃ¼hrende/r trÃ¤gt ${ichName} eine aktive emotionale Energie.`,
                    'submissiv': `${ichName} bringt eine empfÃ¤ngliche, hingebungsvolle QualitÃ¤t mit.`,
                    'switch': `${ichName} ist flexibel in der emotionalen Dynamik â€“ mal fÃ¼hrend, mal folgend.`,
                    'ausgeglichen': `${ichName} strebt nach emotionalem Gleichgewicht in der Verbindung.`
                };
                if (domText[ichDom]) ichParts.push(domText[ichDom]);
            }
            if (ichArch?.coreValues?.length) {
                ichParts.push(`Kernwerte wie ${ichArch.coreValues.slice(0, 2).join(' und ')} prÃ¤gen das emotionale Erleben.`);
            }

            // PARTNER BRINGT MIT
            const partnerParts = [];
            if (partnerArch?.pirsig?.dynamicQuality !== undefined) {
                const dynQual = partnerArch.pirsig.dynamicQuality;
                if (dynQual >= 0.7) {
                    partnerParts.push(`${partnerName} bringt eine hohe dynamische Energie mit â€“ offen fÃ¼r VerÃ¤nderung und spontane Verbindung.`);
                } else if (dynQual >= 0.4) {
                    partnerParts.push(`${partnerName} balanciert zwischen StabilitÃ¤t und Beweglichkeit in der emotionalen Welt.`);
                } else {
                    partnerParts.push(`${partnerName} sucht emotionale Tiefe durch BestÃ¤ndigkeit und vertraute Muster.`);
                }
            }
            if (partnerArch?.osho?.naturalness >= 0.7) {
                partnerParts.push(`Emotionale AuthentizitÃ¤t steht im Vordergrund â€“ ${partnerName} folgt dem natÃ¼rlichen Fluss der GefÃ¼hle.`);
            }
            const partnerDom = person2.dominanz;
            if (partnerDom) {
                const domText = {
                    'dominant': `Als FÃ¼hrende/r trÃ¤gt ${partnerName} eine aktive emotionale Energie.`,
                    'submissiv': `${partnerName} bringt eine empfÃ¤ngliche, hingebungsvolle QualitÃ¤t mit.`,
                    'switch': `${partnerName} ist flexibel in der emotionalen Dynamik â€“ mal fÃ¼hrend, mal folgend.`,
                    'ausgeglichen': `${partnerName} strebt nach emotionalem Gleichgewicht in der Verbindung.`
                };
                if (domText[partnerDom]) partnerParts.push(domText[partnerDom]);
            }
            if (partnerArch?.coreValues?.length) {
                partnerParts.push(`Kernwerte wie ${partnerArch.coreValues.slice(0, 2).join(' und ')} prÃ¤gen das emotionale Erleben.`);
            }

            // SYNTHESE
            const syntheseParts = [];
            const tonalityIntro = selectStatementByHash(tonalityTemplates[tonality].pathos, hash);
            if (tonalityIntro) syntheseParts.push(tonalityIntro);
            if (archStatements?.pathos) {
                const allPathos = [...(archStatements.pathos.gemeinsam || []), ...(archStatements.pathos.spannung || [])];
                const selected = selectStatementByHash(allPathos, hash + 7);
                if (selected) syntheseParts.push(selected);
            }
            if (domStatements?.pathos?.length) {
                syntheseParts.push(selectStatementByHash(domStatements.pathos, hash + 11));
            }
            const ichDyn = ichArch?.pirsig?.dynamicQuality || 0.5;
            const partnerDyn = partnerArch?.pirsig?.dynamicQuality || 0.5;
            if (Math.abs(ichDyn - partnerDyn) < 0.2) {
                syntheseParts.push(`Beide schwingen auf einer Ã¤hnlichen emotionalen Frequenz.`);
            }
            if (syntheseParts.length === 0) {
                syntheseParts.push(`${ichName} und ${partnerName} kÃ¶nnen emotional zueinander finden.`);
            }

            // RESONANZ
            let resonanzText = null;
            if (resonanzData?.R !== undefined) {
                const R = resonanzData.R;
                if (R >= 1.05) resonanzText = `Hohe emotionale Resonanz (R=${R.toFixed(2)}): Pathos und Logos harmonieren.`;
                else if (R >= 0.95) resonanzText = `Gute Resonanz (R=${R.toFixed(2)}): Emotionale und rationale Ebene im Gleichgewicht.`;
                else resonanzText = `Resonanz R=${R.toFixed(2)}: Die WellenlÃ¤ngen sind noch nicht vollstÃ¤ndig abgestimmt.`;
            }

            return {
                ich: ichParts.join(' '),
                partner: partnerParts.join(' '),
                synthese: syntheseParts.join(' '),
                resonanz: resonanzText,
                score: overallScore,
                tonality: tonality
            };
        }

        // Legacy-Wrapper fÃ¼r KompatibilitÃ¤t
        function generateCombinedPathos(ichArch, partnerArch) {
            const detailed = generateDetailedPathos(ichArch, partnerArch);
            return detailed.synthese;
        }

        /**
         * Generiert detaillierte Logos-Inhalte mit ICH/Partner/Synthese Struktur
         * Nutzt LogosTextGenerator fÃ¼r flieÃŸende, analytische Texte
         * @returns {Object} { ich, partner, synthese, resonanz }
         */
        function generateDetailedLogos(ichArch, partnerArch) {
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';
            const ichId = ichArch?.id || currentArchetype || '';
            const partnerId = partnerArch?.id || selectedPartner || '';

            // Berechne die 4 Faktor-Scores
            const person1 = {
                archetyp: ichId,
                dominanz: personDimensions.ich?.dominanz,
                orientierung: personDimensions.ich?.orientierung,
                geschlecht: personDimensions.ich?.geschlecht,
                orientierungStatus: personDimensions.ich?.orientierungStatus
            };
            const person2 = {
                archetyp: partnerId,
                dominanz: personDimensions.partner?.dominanz,
                orientierung: personDimensions.partner?.orientierung,
                geschlecht: personDimensions.partner?.geschlecht,
                orientierungStatus: personDimensions.partner?.orientierungStatus
            };

            // Hole Score-Breakdown
            const qualityResult = calculateRelationshipQuality(person1, person2);
            const breakdown = qualityResult.breakdown || { archetyp: 50, dominanz: 75, orientierung: 100, geschlecht: 100 };
            const overallScore = qualityResult.score || 50;
            const resonanzData = qualityResult.resonanz;
            const tonality = getTonality(overallScore);

            // Get category scores
            const key = `${ichId}_${partnerId}`;
            const interaction = data?.interactions?.[key];
            const categoryScores = interaction?.scores || {};

            // Hole Statement-Quellen
            const archStatements = getArchetypeStatements(ichId, partnerId);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NUTZE LOGOS TEXT GENERATOR (wenn verfÃ¼gbar)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof LogosTextGenerator !== 'undefined') {
                // Extrahiere primitive Werte fÃ¼r Hash (dominanz kann Objekt sein)
                const dom1 = typeof person1.dominanz === 'object' ? (person1.dominanz?.primary || 'none') : (person1.dominanz || 'none');
                const dom2 = typeof person2.dominanz === 'object' ? (person2.dominanz?.primary || 'none') : (person2.dominanz || 'none');

                // Generiere deterministischen Hash fÃ¼r Varianz
                const seed = LogosTextGenerator.generateHash(
                    ichId, partnerId,
                    dom1,
                    dom2,
                    overallScore
                );

                // ICH BRINGT MIT - Analytischer FlieÃŸtext
                const ichText = LogosTextGenerator.generatePersonText(
                    ichArch,
                    personDimensions.ich,
                    ichName,
                    seed
                );

                // PARTNER BRINGT MIT - Analytischer FlieÃŸtext
                const partnerText = LogosTextGenerator.generatePersonText(
                    partnerArch,
                    personDimensions.partner,
                    partnerName,
                    seed + 100
                );

                // DARAUS ENTSTEHT - Analytische Synthese
                const syntheseText = LogosTextGenerator.generateSyntheseText({
                    ichArch,
                    partnerArch,
                    ichName,
                    partnerName,
                    ichDimensions: personDimensions.ich,
                    partnerDimensions: personDimensions.partner,
                    overallScore,
                    archStatements,
                    categoryScores,
                    seed
                });

                // RESONANZ - Analytische Interpretation
                let resonanzText = null;
                if (resonanzData && resonanzData.R !== undefined) {
                    resonanzText = LogosTextGenerator.generateResonanzText(
                        resonanzData.R,
                        seed + 200
                    );
                }

                return {
                    ich: ichText,
                    partner: partnerText,
                    synthese: syntheseText,
                    resonanz: resonanzText,
                    score: overallScore,
                    tonality: tonality
                };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FALLBACK: Original-Logik (wenn LogosTextGenerator nicht geladen)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const hash = getFactorHash(breakdown.archetyp, breakdown.dominanz, breakdown.orientierung, breakdown.geschlecht);

            // ICH BRINGT MIT
            const ichParts = [];
            if (ichArch?.pirsig?.staticQuality !== undefined) {
                const statQual = ichArch.pirsig.staticQuality;
                if (statQual >= 0.7) {
                    ichParts.push(`${ichName} bringt klare Strukturen und feste Werte mit â€“ VerlÃ¤sslichkeit ist ein Grundpfeiler.`);
                } else if (statQual >= 0.4) {
                    ichParts.push(`${ichName} balanciert zwischen festen Ãœberzeugungen und Offenheit fÃ¼r neue Perspektiven.`);
                } else {
                    ichParts.push(`${ichName} bevorzugt FlexibilitÃ¤t Ã¼ber starre Regeln.`);
                }
            }
            if (ichArch?.coreValues?.length) {
                ichParts.push(`Kernwerte: ${ichArch.coreValues.slice(0, 3).join(', ')}.`);
            }
            if (ichArch?.avoids?.length) {
                ichParts.push(`Vermeidet: ${ichArch.avoids.slice(0, 2).join(' und ')}.`);
            }
            const ichGfk = personDimensions.ich?.gfk;
            if (ichGfk) {
                const gfkText = {
                    'hoch': `GFK-Kompetenz: hoch.`,
                    'mittel': `GFK-Kompetenz: mittel.`,
                    'niedrig': `GFK-Kompetenz: niedrig.`
                };
                if (gfkText[ichGfk]) ichParts.push(gfkText[ichGfk]);
            }

            // PARTNER BRINGT MIT
            const partnerParts = [];
            if (partnerArch?.pirsig?.staticQuality !== undefined) {
                const statQual = partnerArch.pirsig.staticQuality;
                if (statQual >= 0.7) {
                    partnerParts.push(`${partnerName} bringt klare Strukturen und feste Werte mit.`);
                } else if (statQual >= 0.4) {
                    partnerParts.push(`${partnerName} balanciert zwischen Struktur und FlexibilitÃ¤t.`);
                } else {
                    partnerParts.push(`${partnerName} bevorzugt adaptive Strukturen.`);
                }
            }
            if (partnerArch?.coreValues?.length) {
                partnerParts.push(`Kernwerte: ${partnerArch.coreValues.slice(0, 3).join(', ')}.`);
            }
            if (partnerArch?.avoids?.length) {
                partnerParts.push(`Vermeidet: ${partnerArch.avoids.slice(0, 2).join(' und ')}.`);
            }
            const partnerGfk = personDimensions.partner?.gfk;
            if (partnerGfk) {
                const gfkText = {
                    'hoch': `GFK-Kompetenz: hoch.`,
                    'mittel': `GFK-Kompetenz: mittel.`,
                    'niedrig': `GFK-Kompetenz: niedrig.`
                };
                if (gfkText[partnerGfk]) partnerParts.push(gfkText[partnerGfk]);
            }

            // SYNTHESE
            const syntheseParts = [];
            const tonalityIntro = selectStatementByHash(tonalityTemplates[tonality].logos, hash);
            if (tonalityIntro) syntheseParts.push(tonalityIntro);
            if (archStatements?.logos) {
                const allLogos = [...(archStatements.logos.gemeinsam || []), ...(archStatements.logos.unterschied || [])];
                const selected = selectStatementByHash(allLogos, hash + 7);
                if (selected) syntheseParts.push(selected);
            }
            const ichStat = ichArch?.pirsig?.staticQuality || 0.5;
            const partnerStat = partnerArch?.pirsig?.staticQuality || 0.5;
            if (Math.abs(ichStat - partnerStat) < 0.2) {
                syntheseParts.push(`Ã„hnliches StrukturbedÃ¼rfnis erleichtert die Abstimmung.`);
            }
            if (syntheseParts.length === 0) {
                syntheseParts.push(`${ichName} und ${partnerName} haben Potenzial fÃ¼r eine tragfÃ¤hige Basis.`);
            }

            // RESONANZ
            let resonanzText = null;
            if (resonanzData?.R !== undefined) {
                const R = resonanzData.R;
                if (R >= 1.05) resonanzText = `Resonanz R=${R.toFixed(2)}: Hohe strukturelle Ãœbereinstimmung.`;
                else if (R >= 0.95) resonanzText = `Resonanz R=${R.toFixed(2)}: Gute KompatibilitÃ¤t.`;
                else resonanzText = `Resonanz R=${R.toFixed(2)}: Erfordert bewusste Abstimmung.`;
            }

            return {
                ich: ichParts.join(' '),
                partner: partnerParts.join(' '),
                synthese: syntheseParts.join(' '),
                resonanz: resonanzText,
                score: overallScore,
                tonality: tonality
            };
        }

        // Legacy-Wrapper fÃ¼r KompatibilitÃ¤t
        function generateCombinedLogos(ichArch, partnerArch) {
            const detailed = generateDetailedLogos(ichArch, partnerArch);
            return detailed.synthese;
        }

        // Legacy-Funktion fÃ¼r KompatibilitÃ¤t (wird nicht mehr verwendet)
        function generateCombinedLogos_legacy(ichArch, partnerArch) {
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';
            // Use global archetype keys as IDs since archetypeDefinitions doesn't have id property
            const ichId = ichArch?.id || currentArchetype || '';
            const partnerId = partnerArch?.id || selectedPartner || '';

            // Get philosophy score from compatibility matrix
            const key = `${ichId}_${partnerId}`;
            const interaction = data?.interactions?.[key];
            const philScore = interaction?.scores?.A?.value || interaction?.overall || 50;

            // Hole Statements aus der Datenbank
            const archStatements = getArchetypeStatements(ichId, partnerId);
            const domStatements = getDominanceStatements(
                personDimensions.ich?.dominanz,
                personDimensions.partner?.dominanz
            );
            const orientStatements = getOrientierungStatements(
                personDimensions.ich?.orientierung,
                personDimensions.partner?.orientierung,
                personDimensions.ich?.geschlecht,
                personDimensions.partner?.geschlecht
            );
            const statusStmts = getStatusStatements(
                personDimensions.ich,
                personDimensions.partner
            );

            const textParts = [];

            // Archetyp-basierte Logos-Statements
            if (archStatements?.logos) {
                if (archStatements.logos.gemeinsam?.length) {
                    textParts.push(archStatements.logos.gemeinsam[0]);
                }
                if (archStatements.logos.unterschied?.length && philScore < 70) {
                    textParts.push(archStatements.logos.unterschied[0]);
                }
            }

            // Dominanz-basierte Logos-Statements (nur wenn nicht default)
            if (domStatements?.logos?.length && domStatements !== dominanceStatements.default) {
                textParts.push(domStatements.logos[0]);
            }

            // Orientierungs-basierte Logos-Statements hinzufÃ¼gen (nur wenn nicht default)
            if (orientStatements?.logos?.length && orientStatements !== orientierungStatements.default) {
                textParts.push(orientStatements.logos[0]);
            }

            // Status-basierte Logos-Statements hinzufÃ¼gen (Pirsig-Perspektive)
            if (statusStmts?.logos?.length && statusStmts !== statusStatements.default) {
                textParts.push(statusStmts.logos[0]);
            }

            // Fallback mit Philosophie-Score
            if (textParts.length === 0) {
                if (philScore >= 80) {
                    return `${ichName} und ${partnerName} teilen viele rationale GrundÃ¼berzeugungen Ã¼ber Beziehungen (Philosophie-Score: ${philScore}%). Das bildet eine solide Basis fÃ¼r konstruktive GesprÃ¤che.`;
                } else if (philScore < 50) {
                    return `${ichName} und ${partnerName} haben unterschiedliche rationale Vorstellungen von Beziehungen (Philosophie-Score: ${philScore}%). Grundlegende GesprÃ¤che Ã¼ber Erwartungen sind wichtig.`;
                }
                return `${ichName} und ${partnerName} haben einige Ãœberschneidungen in ihren rationalen Beziehungsvorstellungen (Philosophie-Score: ${philScore}%), aber auch Unterschiede, die Kommunikation erfordern.`;
            }

            return textParts.join(' ');
        }

        // ========================================
        // MOBILE MULTI-PAGE FUNCTIONS
        // ========================================

        let currentMobilePage = 1;
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PHASE 1: PROXY-LAYER MIGRATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // mobilePersonDimensions verweist jetzt auf denselben Proxy wie personDimensions.
        // Mobile und Desktop teilen sich TiageState als Single Source of Truth.
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        let mobilePersonDimensions = window.mobilePersonDimensions;
        let mobileIchArchetype = 'single';
        let mobilePartnerArchetype = 'duo';
        let mobileTouchStartX = 0;
        let mobileTouchEndX = 0;

        function getMissingDimensions() {
            // Check if we're in mobile mode
            const isMobile = window.innerWidth <= 768;
            const dimensions = isMobile ? mobilePersonDimensions : personDimensions;
            const missing = [];

            // Check ICH dimensions
            // Geschlecht ist jetzt { primary, secondary } - nur primary ist erforderlich
            if (!dimensions.ich.geschlecht || !dimensions.ich.geschlecht.primary) {
                missing.push('Ich: Geschlecht');
            }
            if (dimensions.ich.dominanz === null) {
                missing.push('Ich: Dominanz');
            }
            if (dimensions.ich.orientierung === null) {
                missing.push('Ich: Orientierung');
            }
            if (dimensions.ich.orientierungStatus === null) {
                missing.push('Ich: Orientierung-Status');
            }

            // Check PARTNER dimensions
            if (!dimensions.partner.geschlecht || !dimensions.partner.geschlecht.primary) {
                missing.push('Partner: Geschlecht');
            }
            if (dimensions.partner.dominanz === null) {
                missing.push('Partner: Dominanz');
            }
            if (dimensions.partner.orientierung === null) {
                missing.push('Partner: Orientierung');
            }
            if (dimensions.partner.orientierungStatus === null) {
                missing.push('Partner: Orientierung-Status');
            }

            return missing;
        }

        function validateDimensionsComplete() {
            return getMissingDimensions().length === 0;
        }

        function showValidationWarning() {
            // Find or create warning element
            let warning = document.getElementById('dimensionWarning');
            if (warning) {
                warning.remove();
            }

            const missingItems = getMissingDimensions();

            warning = document.createElement('div');
            warning.id = 'dimensionWarning';
            warning.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(231, 76, 60, 0.95);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 600;
                z-index: 9999;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                animation: slideDown 0.3s ease;
                max-width: 90%;
                text-align: left;
            `;

            // Build message with missing items
            let messageHTML = '<div style="margin-bottom: 8px;">âš ï¸ Es fehlt noch:</div>';
            messageHTML += '<ul style="margin: 0; padding-left: 20px; font-weight: normal; font-size: 13px;">';
            missingItems.forEach(item => {
                messageHTML += `<li>${item}</li>`;
            });
            messageHTML += '</ul>';

            warning.innerHTML = messageHTML;
            document.body.appendChild(warning);

            // Auto-remove after 4 seconds (slightly longer for reading)
            setTimeout(() => {
                warning.style.animation = 'slideUp 0.3s ease';
                setTimeout(() => warning.remove(), 300);
            }, 4000);
        }

        function mobileGoToPage(pageNumber, skipPushState = false) {
            // WICHTIG: Speichere alle Einstellungen BEVOR navigiert wird
            // Dies verhindert Datenverlust bei ZurÃ¼ck-Navigation (Fix fÃ¼r GOD-Einstellungen)
            if (typeof saveSelectionToStorage === 'function') {
                saveSelectionToStorage();
            }

            // Validate before moving to page 4 (Synthese) - ensure all dimensions are complete
            if (currentMobilePage === 3 && pageNumber === 4 && !validateDimensionsComplete()) {
                showValidationWarning();
                return;
            }

            // Hide all pages
            document.querySelectorAll('.mobile-page').forEach(p => {
                p.classList.remove('active');
            });

            // Show target page
            const targetPage = document.getElementById(`mobilePage${pageNumber}`);
            if (targetPage) {
                targetPage.classList.add('active');
            }

            // Update dots
            document.querySelectorAll('.page-dot').forEach((dot, index) => {
                dot.classList.toggle('active', index === pageNumber - 1);
            });

            currentMobilePage = pageNumber;

            // Update page content when navigating
            if (pageNumber === 4) {
                updateMobileResultPage();
            }

            // Push to browser history for back button navigation (only for forward navigation)
            if (!skipPushState) {
                history.pushState({ mobilePage: pageNumber }, '', `#seite${pageNumber}`);
            }

            // Scroll to top
            window.scrollTo(0, 0);
        }

        // DEAKTIVIERT: Swipe-Navigation entfernt - alle Seiten sind jetzt untereinander angeordnet
        function initMobileSwipe() {
            // Swipe-FunktionalitÃ¤t deaktiviert
            // Alle mobilen Seiten werden nun untereinander angezeigt
            return;
        }

        function handleMobileSwipe() {
            // Swipe-FunktionalitÃ¤t deaktiviert
            return;
        }

        function initMobileDimensionListeners() {
            // ICH Select
            const mobileIchSelect = document.getElementById('mobileIchSelect');
            if (mobileIchSelect) {
                mobileIchSelect.addEventListener('change', (e) => {
                    mobileIchArchetype = e.target.value;
                    // Sync with TiageState for save/load
                    if (typeof TiageState !== 'undefined') {
                        TiageState.setArchetype('ich', e.target.value);
                    }
                    // Sync with desktop
                    const desktopSelect = document.getElementById('ichSelect');
                    if (desktopSelect) desktopSelect.value = e.target.value;
                    currentArchetype = e.target.value;
                    // Sync archetype grid highlighting
                    updateArchetypeGrid('ich', e.target.value);

                    // SSOT: Berechne flatNeeds + Resonanzfaktoren bei Archetyp-Wechsel
                    if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                        const profileData = {
                            archetyp: e.target.value,
                            geschlecht: TiageState.get('personDimensions.ich.geschlecht'),
                            dominanz: TiageState.get('personDimensions.ich.dominanz'),
                            orientierung: TiageState.get('personDimensions.ich.orientierung')
                        };
                        ProfileCalculator.loadProfile('ich', profileData);
                    }

                    updateComparisonView();
                    // GFK automatisch aus Archetypen-Matching ableiten
                    updateGfkFromArchetypes();
                });
            }

            // Partner Select
            const mobilePartnerSelect = document.getElementById('mobilePartnerSelect');
            if (mobilePartnerSelect) {
                mobilePartnerSelect.addEventListener('change', (e) => {
                    mobilePartnerArchetype = e.target.value;
                    // Sync with TiageState for save/load
                    if (typeof TiageState !== 'undefined') {
                        TiageState.setArchetype('partner', e.target.value);
                    }
                    // Sync with desktop
                    const desktopSelect = document.getElementById('partnerSelect');
                    if (desktopSelect) desktopSelect.value = e.target.value;
                    selectedPartner = e.target.value;
                    // Sync archetype grid highlighting
                    updateArchetypeGrid('partner', e.target.value);

                    // SSOT: Berechne flatNeeds + Resonanzfaktoren bei Archetyp-Wechsel
                    if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                        const profileData = {
                            archetyp: e.target.value,
                            geschlecht: TiageState.get('personDimensions.partner.geschlecht'),
                            dominanz: TiageState.get('personDimensions.partner.dominanz'),
                            orientierung: TiageState.get('personDimensions.partner.orientierung')
                        };
                        ProfileCalculator.loadProfile('partner', profileData);
                    }

                    updateComparisonView();
                    // GFK automatisch aus Archetypen-Matching ableiten
                    updateGfkFromArchetypes();
                });
            }

            // ICH Dimensions
            document.querySelectorAll('input[name="mobile-ich-geschlecht"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    // Use handleGeschlechtClick to maintain consistent object format
                    handleGeschlechtClick('ich', e.target.value, e.target);
                });
            });
            document.querySelectorAll('input[name="mobile-ich-dominanz"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    handleDominanzClick('ich', e.target.value, true);
                });
            });
            document.querySelectorAll('input[name="mobile-ich-dominanz-status"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    mobilePersonDimensions.ich.dominanzStatus = e.target.value;
                    personDimensions.ich.dominanzStatus = e.target.value;
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    syncDimensionToDesktop('ich-dominanz-status-new', e.target.value);
                    updateComparisonView();
                    // Fix: Speichere Ã„nderungen sofort
                    if (typeof saveSelectionToStorage === 'function') {
                        saveSelectionToStorage();
                    }
                });
            });

            // Partner Dimensions
            document.querySelectorAll('input[name="mobile-partner-geschlecht"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    // Use handleGeschlechtClick to maintain consistent object format
                    handleGeschlechtClick('partner', e.target.value, e.target);
                });
            });
            document.querySelectorAll('input[name="mobile-partner-dominanz"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    handleDominanzClick('partner', e.target.value, true);
                });
            });
            document.querySelectorAll('input[name="mobile-partner-dominanz-status"]').forEach(radio => {
                radio.addEventListener('change', (e) => {
                    mobilePersonDimensions.partner.dominanzStatus = e.target.value;
                    personDimensions.partner.dominanzStatus = e.target.value;
                    e.target.closest('.compact-dimension').classList.remove('needs-selection');
                    syncDimensionToDesktop('partner-dominanz-status-new', e.target.value);
                    updateComparisonView();
                    // Fix: Speichere Ã„nderungen sofort
                    if (typeof saveSelectionToStorage === 'function') {
                        saveSelectionToStorage();
                    }
                });
            });
        }

        function syncDimensionToDesktop(name, value) {
            const desktopRadio = document.querySelector(`input[name="${name}"][value="${value}"]`);
            if (desktopRadio) {
                desktopRadio.checked = true;
                const container = desktopRadio.closest('.compact-dimension');
                if (container) container.classList.remove('needs-selection');
            }
        }

        function updateMobileResultPage() {
            if (!data) return;

            const ichArch = data.archetypes[mobileIchArchetype || currentArchetype];
            const partnerArch = data.archetypes[mobilePartnerArchetype || selectedPartner];

            // Update type names
            document.getElementById('mobileResultIch').textContent = ichArch?.name || mobileIchArchetype;
            document.getElementById('mobileResultPartner').textContent = partnerArch?.name || mobilePartnerArchetype;

            // Calculate scores - use mobilePersonDimensions for consistency with tooltips
            const dims = mobilePersonDimensions;
            const person1 = { archetyp: mobileIchArchetype || currentArchetype, ...dims.ich };
            const person2 = { archetyp: mobilePartnerArchetype || selectedPartner, ...dims.partner };

            // Check if both genders are selected before calculating
            // Support both string format ('cis_mann') and object format ({ primary: 'cis_mann' })
            const g1Raw = dims.ich.geschlecht;
            const g2Raw = dims.partner.geschlecht;
            const g1 = (typeof g1Raw === 'string') ? g1Raw : (g1Raw && g1Raw.primary);
            const g2 = (typeof g2Raw === 'string') ? g2Raw : (g2Raw && g2Raw.primary);

            // Check if any orientierung is selected for both (Primary/Secondary structure)
            const hasOri1 = dims.ich.orientierung && dims.ich.orientierung.primary;
            const hasOri2 = dims.partner.orientierung && dims.partner.orientierung.primary;

            // Check if any dominanz is selected for both (Primary/Secondary structure)
            const hasDom1 = dims.ich.dominanz && dims.ich.dominanz.primary;
            const hasDom2 = dims.partner.dominanz && dims.partner.dominanz.primary;

            const isIncomplete = !g1 || !g2 || !hasOri1 || !hasOri2 || !hasDom1 || !hasDom2;

            const qualityResult = isIncomplete ?
                { score: 0, blocked: false, incomplete: true, breakdown: { archetyp: 0, dominanz: 0, orientierung: 0, geschlecht: 0 } } :
                calculateRelationshipQuality(person1, person2);

            // Update score circle
            const scoreCircle = document.getElementById('mobileScoreCircle');

            // Set score circle color and content
            // Kein harter K.O. mehr - sanfte Abstufung durch Resonanz
            if (qualityResult.incomplete) {
                scoreCircle.textContent = 'â€“';
            } else {
                scoreCircle.textContent = qualityResult.score.toFixed(1);
            }
            scoreCircle.style.background = 'transparent';

            // Sync score to resultPercentage for Tiage's Synthese modal
            const resultPercentageEl = document.getElementById('resultPercentage');
            if (resultPercentageEl) {
                resultPercentageEl.textContent = qualityResult.incomplete ? 'â€“' : qualityResult.score.toFixed(1);
            }

            // Update Mobile Score Note (direkt beim Kreis)
            const mobileScoreNote = document.getElementById('mobileScoreNote');
            if (mobileScoreNote) {
                let noteText = '';
                let quoteText = '';
                let quoteSource = '';
                const score = qualityResult.score;

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // K.O.-WARNUNG: PrÃ¼fe auf harte Ausschlusskriterien
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                let koWarning = null;

                // 1. Orientierungs-K.O. (keine kÃ¶rperliche Anziehung mÃ¶glich)
                if (qualityResult.blocked && qualityResult.reason) {
                    koWarning = {
                        type: 'orientation',
                        message: qualityResult.reason
                    };
                }

                // 2. Lifestyle-K.O. prÃ¼fen (Kinderwunsch, Wohnform etc.)
                if (!koWarning && typeof TiageSynthesis !== 'undefined' && TiageSynthesis.LifestyleFilter) {
                    const attrs1 = personDimensions.ich?.baseAttributes || {};
                    const attrs2 = personDimensions.partner?.baseAttributes || {};
                    const lifestyleCheck = TiageSynthesis.LifestyleFilter.check(attrs1, attrs2);

                    if (lifestyleCheck.isKO && lifestyleCheck.koReasons.length > 0) {
                        koWarning = {
                            type: 'lifestyle',
                            message: lifestyleCheck.koReasons.map(r => r.message).join(' | '),
                            details: lifestyleCheck.koReasons
                        };
                    }
                }

                if (qualityResult.incomplete) {
                    noteText = 'Bitte alle Dimensionen auswÃ¤hlen.';
                    mobileScoreNote.textContent = noteText;
                    mobileScoreNote.style.display = 'block';
                } else if (koWarning) {
                    // K.O.-Warnung anzeigen
                    mobileScoreNote.innerHTML = '<div class="ko-warning-message" style="color: #e74c3c; background: rgba(231, 76, 60, 0.15); border: 1px solid #e74c3c; border-radius: 8px; padding: 10px 12px; margin-top: 8px; text-align: center;"><strong style="display: block; margin-bottom: 4px;">âš ï¸ K.O.-Kriterium</strong><span style="font-size: 0.9em; opacity: 0.95;">' + koWarning.message + '</span></div>';
                    mobileScoreNote.style.display = 'block';
                } else if (qualityResult.noRealNeeds) {
                    // Warnung: Keine echten Needs verfÃ¼gbar - R1-R3 sind neutral (1.0)
                    mobileScoreNote.innerHTML = '<div class="needs-warning-message" style="color: #f39c12; background: rgba(243, 156, 18, 0.15); border: 1px solid #f39c12; border-radius: 8px; padding: 10px 12px; margin-top: 8px; text-align: center;"><strong style="display: block; margin-bottom: 4px;">âš ï¸ Keine BedÃ¼rfnis-Daten</strong><span style="font-size: 0.9em; opacity: 0.95;">R1-R3 Resonanz-Faktoren kÃ¶nnen nicht berechnet werden. Bitte BedÃ¼rfnis-Werte im Profil anpassen.</span></div>';
                    mobileScoreNote.style.display = 'block';
                } else {
                    // Bestimme Resonanzlevel basierend auf Score
                    let resonanceLevel = 'niedrig';
                    if (score >= 80) resonanceLevel = 'hoch';
                    else if (score >= 50) resonanceLevel = 'mittel';

                    // Versuche Zitat aus ResonanceQuotesTable zu holen
                    if (typeof ResonanceQuotesTable !== 'undefined') {
                        const category = score >= 65 ? 'RESONANCE' : score >= 50 ? 'GROWTH' : 'AWARENESS';
                        const result = ResonanceQuotesTable.generateResonanceText(resonanceLevel, category, 'de');

                        if (result && result.quote) {
                            noteText = result.title;
                            quoteText = result.quote;
                            quoteSource = result.quoteSource ? ` â€” ${result.quoteSource}` : '';
                        }
                    }

                    // Fallback zu hardcoded Texten wenn ResonanceQuotesTable nicht verfÃ¼gbar
                    if (!quoteText) {
                        if (score < 30) {
                            noteText = 'Sehr niedrige Resonanz â€“ groÃŸe Unterschiede.';
                            quoteText = 'Hier begegnen sich zwei Menschen, deren Frequenzen sich deutlich unterscheiden. Diese Beziehung erfordert besondere Achtsamkeit und die Bereitschaft, die Andersartigkeit des anderen als Bereicherung zu sehen.';
                        } else if (score >= 80) {
                            noteText = 'Hohe Resonanz â€“ Muster ergÃ¤nzen sich.';
                            quoteText = 'Hier begegnen sich zwei Menschen, deren Frequenzen sich natÃ¼rlich ergÃ¤nzen. Diese Verbindung trÃ¤gt die QualitÃ¤t tiefer Resonanz â€“ ein Zusammenspiel, das beide bereichert und wachsen lÃ¤sst.';
                        } else if (score >= 65) {
                            noteText = 'Solide Balance mit Potenzial.';
                            quoteText = 'Hier begegnen sich zwei Menschen mit guter Grundresonanz. Diese Verbindung bietet eine solide Balance und echtes Potenzial fÃ¼r gemeinsames Wachstum.';
                        } else if (score >= 50) {
                            noteText = 'Basis vorhanden, Arbeit erforderlich.';
                            quoteText = 'Hier begegnen sich zwei Menschen mit einer tragfÃ¤higen Basis. Diese Verbindung hat QualitÃ¤t, die durch bewusste Kommunikation und gegenseitiges VerstÃ¤ndnis vertieft werden kann.';
                        } else {
                            noteText = 'Bewusste Reflexion erforderlich.';
                            quoteText = 'Hier begegnen sich zwei Menschen mit unterschiedlichen Mustern. Diese Verbindung lÃ¤dt zur bewussten Reflexion ein â€“ ein Weg, der Offenheit und ehrliche Kommunikation erfordert.';
                        }
                    }

                    mobileScoreNote.innerHTML = '<strong>' + noteText + '</strong><br><span style="font-style: italic; opacity: 0.85; font-size: 0.9em;">"' + quoteText + '"' + quoteSource + '</span>';
                    mobileScoreNote.style.display = 'block';
                }
            }
        }

        function updateMobileProContraPage() {
            if (!data) return;

            const ichArch = data.archetypes[mobileIchArchetype || currentArchetype];
            const partnerArch = data.archetypes[mobilePartnerArchetype || selectedPartner];

            // Update title
            const title = document.getElementById('mobileProContraTitle');
            if (title) {
                title.textContent = `${ichArch?.name || 'ICH'} Ã— ${partnerArch?.name || 'PARTNER'}`;
            }

            // Get interaction data
            const interactionKey = `${mobileIchArchetype || currentArchetype}_${mobilePartnerArchetype || selectedPartner}`;
            const interaction = data.interactions?.[interactionKey];

            const proList = document.getElementById('mobileProList');
            const contraList = document.getElementById('mobileContraList');

            if (interaction) {
                // Pro list
                if (proList && interaction.pros?.length) {
                    proList.innerHTML = interaction.pros.map(p => `<li>${p}</li>`).join('');
                } else if (proList) {
                    proList.innerHTML = '<li>Keine spezifischen Vorteile bekannt</li>';
                }

                // Contra list
                if (contraList && interaction.contras?.length) {
                    contraList.innerHTML = interaction.contras.map(c => `<li>${c}</li>`).join('');
                } else if (contraList) {
                    contraList.innerHTML = '<li>Keine spezifischen Herausforderungen bekannt</li>';
                }
            } else {
                if (proList) proList.innerHTML = '<li>Keine Daten verfÃ¼gbar</li>';
                if (contraList) contraList.innerHTML = '<li>Keine Daten verfÃ¼gbar</li>';
            }
        }

        function updateMobileCategoriesPage() {
            if (!data) return;

            const container = document.getElementById('mobileCategoriesAccordion');
            if (!container) return;

            // SSOT v3.10: Needs aus TiageState laden fÃ¼r R-Faktor-Berechnung
            const ichNeeds = typeof TiageState !== 'undefined' ? TiageState.get('flatNeeds.ich') : null;
            const partnerNeeds = typeof TiageState !== 'undefined' ? TiageState.get('flatNeeds.partner') : null;

            const person1 = { archetyp: mobileIchArchetype || currentArchetype, ...personDimensions.ich, needs: ichNeeds };
            const person2 = { archetyp: mobilePartnerArchetype || selectedPartner, ...personDimensions.partner, needs: partnerNeeds };

            const pathosCheck = checkPhysicalCompatibility(person1, person2);
            const logosCheck = calculatePhilosophyCompatibility(person1.archetyp, person2.archetyp);
            // SSOT v3.10: R-Faktoren aus person.needs
            const result = calculateOverallWithModifiers(person1, person2, pathosCheck, logosCheck);

            const categoryNamesMap = {
                A: 'Beziehungsphilosophie',
                B: 'Werte-Alignment',
                C: 'NÃ¤he-Distanz',
                D: 'Autonomie',
                E: 'Kommunikation',
                F: 'Soziale KompatibilitÃ¤t'
            };

            const categoryDescMap = {
                A: 'Ãœbereinstimmung in den grundlegenden Beziehungsvorstellungen und -erwartungen.',
                B: 'Wie gut eure moralischen und ethischen Werte Ã¼bereinstimmen.',
                C: 'Balance zwischen BedÃ¼rfnis nach NÃ¤he und Freiraum.',
                D: 'Respekt fÃ¼r individuelle UnabhÃ¤ngigkeit und Selbstbestimmung.',
                E: 'FÃ¤higkeit zur offenen und ehrlichen Kommunikation.',
                F: 'KompatibilitÃ¤t im sozialen Umfeld und gesellschaftlicher Akzeptanz.'
            };

            // FEATURE 2: Category explanations
            function getCategoryExplanation(cat, score, ich, partner) {
                const ichName = data?.archetypes?.[ich]?.name || ich;
                const partnerName = data?.archetypes?.[partner]?.name || partner;

                const explanations = {
                    A: () => {
                        if (ich === partner) {
                            return `${ichName} und ${partnerName} teilen dieselbe Beziehungsphilosophie (100% Ãœbereinstimmung). Beide haben identische GrundÃ¼berzeugungen Ã¼ber Beziehungsstrukturen, was eine solide Basis bietet.`;
                        }
                        if (score >= 80) {
                            return `${ichName} und ${partnerName} haben sehr Ã¤hnliche Beziehungsphilosophien (${score}%). Die GrundÃ¼berzeugungen passen gut zusammen und schaffen eine harmonische Basis.`;
                        } else if (score >= 60) {
                            return `${ichName} (sucht ${ichName === 'Single' ? 'Freiheit' : ichName === 'Duo' ? 'ExklusivitÃ¤t' : 'FlexibilitÃ¤t'}) und ${partnerName} (sucht ${partnerName === 'Single' ? 'Freiheit' : partnerName === 'Duo' ? 'ExklusivitÃ¤t' : 'FlexibilitÃ¤t'}) haben unterschiedliche, aber vereinbare Beziehungsphilosophien (${score}%). Mit Kommunikation und VerstÃ¤ndnis ist eine BrÃ¼cke mÃ¶glich.`;
                        } else {
                            return `${ichName} und ${partnerName} haben fundamentale philosophische Unterschiede (${score}%). Die Beziehungsvorstellungen weichen stark voneinander ab. Intensive Kommunikation und groÃŸe Kompromisse sind nÃ¶tig.`;
                        }
                    },
                    B: () => `Diese Kategorie misst, wie gut eure moralischen Werte Ã¼bereinstimmen. Ein Score von ${score}% zeigt ${score >= 70 ? 'starke' : score >= 50 ? 'moderate' : 'schwache'} Ãœbereinstimmung in ethischen Grundfragen.`,
                    C: () => `NÃ¤he-Distanz bewertet das Gleichgewicht zwischen Zusammensein und Freiraum. Bei ${score}% gibt es ${score >= 70 ? 'eine harmonische Balance' : score >= 50 ? 'moderate Abstimmung nÃ¶tig' : 'deutliche Unterschiede in den BedÃ¼rfnissen'}.`,
                    D: () => `Autonomie misst den Respekt fÃ¼r individuelle Freiheit. ${score}% bedeutet ${score >= 70 ? 'hohe gegenseitige WertschÃ¤tzung' : score >= 50 ? 'moderate Ãœbereinstimmung' : 'Spannungen durch unterschiedliche Autonomie-BedÃ¼rfnisse'}.`,
                    E: () => `Kommunikation bewertet Offenheit und Ehrlichkeit. Ein Score von ${score}% zeigt ${score >= 70 ? 'exzellente Kommunikationsbasis' : score >= 50 ? 'solide, aber ausbaufÃ¤hige Kommunikation' : 'Herausforderungen in der VerstÃ¤ndigung'}.`,
                    F: () => `Soziale KompatibilitÃ¤t bewertet gesellschaftliche Akzeptanz und Umfeld-Passung. ${score}% bedeutet ${score >= 70 ? 'sehr gute soziale Harmonie' : score >= 50 ? 'akzeptable soziale Integration' : 'potenzielle soziale Herausforderungen'}.`
                };

                return explanations[cat] ? explanations[cat]() : '';
            }

            let html = '';
            for (const [cat, catData] of Object.entries(result.categories)) {
                const score = catData.score || 0;
                const barClass = score >= 80 ? 'bar-excellent' : score >= 65 ? 'bar-good' : score >= 50 ? 'bar-medium' : 'bar-low';
                const explanation = getCategoryExplanation(cat, score, person1.archetyp, person2.archetyp);

                html += `
                    <div class="category-accordion-item">
                        <div class="category-accordion-header" onclick="toggleMobileCategory(this)">
                            <span class="category-accordion-letter">${cat}</span>
                            <span class="category-accordion-name">${categoryNamesMap[cat] || cat}</span>
                            <span class="category-accordion-score">${score}%</span>
                            <span class="category-accordion-icon">â–¼</span>
                        </div>
                        <div class="category-accordion-content">
                            <div class="category-accordion-inner">
                                <p class="category-accordion-desc">${categoryDescMap[cat] || ''}</p>
                                <div style="margin-top: 10px; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden;">
                                    <div class="${barClass}" style="height: 100%; width: ${score}%; border-radius: 4px;"></div>
                                </div>
                                <div style="margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.05); border-radius: 8px; border-left: 3px solid var(--primary);">
                                    <h4 style="font-size: var(--font-sm); color: var(--text-primary); margin-bottom: 8px;">Warum ${score}%?</h4>
                                    <p style="font-size: var(--font-xs); color: var(--text-secondary); line-height: 1.5; margin: 0;">${explanation}</p>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        function toggleMobileCategory(header) {
            const item = header.closest('.category-accordion-item');
            if (item) {
                item.classList.toggle('open');
            }
        }

        function checkAndShowMobileLayout() {
            const isMobile = window.innerWidth <= 768;
            const desktopView = document.getElementById('comparisonView');
            const mobileView = document.getElementById('mobileMultipage');

            if (isMobile) {
                if (desktopView) desktopView.style.display = 'none';
                if (mobileView) mobileView.style.display = 'block';
            } else {
                if (desktopView) desktopView.style.display = 'block';
                if (mobileView) mobileView.style.display = 'none';
            }
        }

        // ========================================
        // MOBILE GEWICHTUNG FUNCTIONS
        // ========================================

        function updateMobileGewichtung(factor, value) {
            const numValue = Math.max(0, Math.min(100, parseInt(value, 10) || 0));

            // Update input and slider
            const input = document.getElementById(`mobile-gewicht-${factor}`);
            const slider = document.getElementById(`mobile-gewicht-slider-${factor}`);
            if (input) input.value = numValue;
            if (slider) slider.value = numValue;

            // Sync mit GewichtungCard (nutzt deren normalize-Logik)
            if (typeof GewichtungCard !== 'undefined') {
                GewichtungCard.normalize(factor, numValue);
                // Sync zurÃ¼ck von GewichtungCard zu Mobile UI
                syncMobileGewichtungFromState();
            }

            // Update Summe
            updateMobileGewichtungSumme();

            // Sync mit Desktop AGOD Sticks
            syncDesktopAgodFromMobile();

            // Trigger recalculation
            if (typeof updateDisplay === 'function') updateDisplay();
        }

        function syncMobileGewichtungFromState() {
            if (typeof GewichtungCard === 'undefined') return;

            const gew = GewichtungCard.getValues();

            // Update Mobile inputs/sliders
            ['orientierung', 'archetyp', 'dominanz', 'geschlecht'].forEach(factor => {
                const key = factor === 'orientierung' ? 'O' :
                           factor === 'archetyp' ? 'A' :
                           factor === 'dominanz' ? 'D' : 'G';
                const val = gew[key];
                const input = document.getElementById(`mobile-gewicht-${factor}`);
                const slider = document.getElementById(`mobile-gewicht-slider-${factor}`);
                if (input) input.value = val;
                if (slider) slider.value = val;
            });

            updateMobileGewichtungSumme();
        }

        function updateMobileGewichtungSumme() {
            const o = parseInt(document.getElementById('mobile-gewicht-orientierung')?.value) || 0;
            const a = parseInt(document.getElementById('mobile-gewicht-archetyp')?.value) || 0;
            const d = parseInt(document.getElementById('mobile-gewicht-dominanz')?.value) || 0;
            const g = parseInt(document.getElementById('mobile-gewicht-geschlecht')?.value) || 0;
            const summe = o + a + d + g;

            const summeEl = document.getElementById('mobile-gewicht-summe');
            const summeLabelEl = document.getElementById('mobile-gewicht-summe-label');

            if (summeEl) {
                summeEl.textContent = summe + '%';
                summeEl.style.color = summe === 100 ? '#10B981' : '#EF4444';
            }
            if (summeLabelEl) {
                summeLabelEl.textContent = summe + '%';
                summeLabelEl.style.color = summe === 100 ? '' : '#EF4444';
            }
        }

        function syncDesktopAgodFromMobile() {
            // Sync to Desktop AGOD Weight Sticks
            const gew = typeof GewichtungCard !== 'undefined' ? GewichtungCard.getValues() : null;
            if (!gew) return;

            const agodA = document.getElementById('agodWeightA');
            const agodG = document.getElementById('agodWeightG');
            const agodO = document.getElementById('agodWeightO');
            const agodD = document.getElementById('agodWeightD');

            if (agodA) agodA.value = gew.A;
            if (agodG) agodG.value = gew.G;
            if (agodO) agodO.value = gew.O;
            if (agodD) agodD.value = gew.D;

            // Update AGOD stick visuals if function exists
            if (typeof updateAgodStickVisuals === 'function') {
                updateAgodStickVisuals();
            }
        }

        function resetMobileGewichtung() {
            if (typeof GewichtungCard !== 'undefined') {
                GewichtungCard.reset();
            }

            // Reset Mobile UI
            ['orientierung', 'archetyp', 'dominanz', 'geschlecht'].forEach(factor => {
                const input = document.getElementById(`mobile-gewicht-${factor}`);
                const slider = document.getElementById(`mobile-gewicht-slider-${factor}`);
                if (input) input.value = 25;
                if (slider) slider.value = 25;
            });

            updateMobileGewichtungSumme();
            syncDesktopAgodFromMobile();

            if (typeof updateDisplay === 'function') updateDisplay();
        }

        function initMobileGewichtung() {
            // Load initial values from GewichtungCard
            syncMobileGewichtungFromState();
        }

        // Make functions globally available
        window.updateMobileGewichtung = updateMobileGewichtung;
        window.resetMobileGewichtung = resetMobileGewichtung;

        // ========================================
        // MOBILE GESCHLECHT SECONDARY GRIDS
        // ========================================

        function initMobileGeschlechtGrids() {
            // Mobile geschlecht P-grids are initialized by initDimensionButtons (via pGridSelectors)
            // S-grids are dynamically populated by updateGeschlechtSGrid when P is selected
            // Just trigger S-grid update for any existing P selections
            ['ich', 'partner'].forEach(person => {
                if (personDimensions[person].geschlecht?.primary) {
                    updateGeschlechtSGrid(person);
                }
            });
        }

        function initMobileLayout() {
            initMobileSwipe();
            initMobileDimensionListeners();
            checkAndShowMobileLayout();
            initMobileGewichtung();
            initMobileGeschlechtGrids();

            // Listen for window resize
            window.addEventListener('resize', checkAndShowMobileLayout);

            // Initialize browser history for back button support
            initBrowserHistoryNavigation();
        }

        function initBrowserHistoryNavigation() {
            // Set initial state without adding to history
            history.replaceState({ mobilePage: 1 }, '', '#seite1');

            // Handle browser back/forward button
            window.addEventListener('popstate', function(event) {
                // First, close any open modals when going back
                const factorModal = document.getElementById('factorModal');
                const helpModal = document.getElementById('helpModal');
                const commentModal = document.getElementById('commentModal');
                const tiageSyntheseModal = document.getElementById('tiageSyntheseModal');

                // Check if we're returning FROM a modal state (current modal should close)
                if (factorModal && factorModal.classList.contains('active')) {
                    closeFactorModal(null, true);
                }
                if (helpModal && helpModal.classList.contains('active')) {
                    closeHelpModal(null, true);
                }
                if (commentModal && commentModal.classList.contains('active')) {
                    closeCommentModal(null, true);
                }
                if (tiageSyntheseModal && tiageSyntheseModal.classList.contains('active')) {
                    closeTiageSyntheseModal(null, true);
                }

                // Navigate to the correct page
                if (event.state && event.state.mobilePage) {
                    // Only change page if we're not on a modal state
                    if (!event.state.modal) {
                        mobileGoToPage(event.state.mobilePage, true);
                    }
                } else {
                    // If no state, go to page 1
                    mobileGoToPage(1, true);
                }
            });

            // Handle initial load with hash (e.g., direct link to #seite2)
            const hash = window.location.hash;
            if (hash && hash.startsWith('#seite')) {
                const pageNum = parseInt(hash.replace('#seite', ''));
                if (pageNum >= 1 && pageNum <= 3) {
                    // Delay to ensure DOM is ready
                    setTimeout(() => {
                        // For page 2 and 3, we need valid selections - go to page 1 first
                        if (pageNum > 1) {
                            mobileGoToPage(1, true);
                        }
                    }, 100);
                }
            }
        }

        /**
         * Load saved dimensions from TiageState into local personDimensions variable
         * This ensures the UI reflects any previously saved selections
         */
        function loadDimensionsFromState() {
            console.log('[loadDimensionsFromState] Start - TiageState verfÃ¼gbar:', typeof TiageState !== 'undefined');
            if (typeof TiageState === 'undefined') return;

            // FIX v1.8.691: init() statt loadFromStorage() - idempotent, kann mehrfach aufgerufen werden
            // state.js ruft init() bereits beim DOMContentLoaded auf, aber zur Sicherheit nochmal
            TiageState.init();

            // Load archetypes from TiageState and sync with global variables (Desktop + Mobile)
            const savedIchArchetype = TiageState.getArchetype('ich');
            const savedPartnerArchetype = TiageState.getArchetype('partner');

            console.log('[loadDimensionsFromState] Geladene Archetypen - ICH:', savedIchArchetype, 'PARTNER:', savedPartnerArchetype);

            if (savedIchArchetype) {
                currentArchetype = savedIchArchetype;
                mobileIchArchetype = savedIchArchetype;
                // Sync all ICH select dropdowns
                const archetypeSelect = document.getElementById('archetypeSelect');
                const ichSelect = document.getElementById('ichSelect');
                const mobileIchSelect = document.getElementById('mobileIchSelect');
                if (archetypeSelect) archetypeSelect.value = savedIchArchetype;
                if (ichSelect) ichSelect.value = savedIchArchetype;
                if (mobileIchSelect) mobileIchSelect.value = savedIchArchetype;
                // Sync archetype grid highlighting
                if (typeof updateArchetypeGrid === 'function') {
                    updateArchetypeGrid('ich', savedIchArchetype);
                }
            }

            if (savedPartnerArchetype) {
                selectedPartner = savedPartnerArchetype;
                mobilePartnerArchetype = savedPartnerArchetype;
                // Sync all PARTNER select dropdowns
                const partnerSelect = document.getElementById('partnerSelect');
                const mobilePartnerSelect = document.getElementById('mobilePartnerSelect');
                if (partnerSelect) partnerSelect.value = savedPartnerArchetype;
                if (mobilePartnerSelect) mobilePartnerSelect.value = savedPartnerArchetype;
                // Sync archetype grid highlighting
                if (typeof updateArchetypeGrid === 'function') {
                    updateArchetypeGrid('partner', savedPartnerArchetype);
                }
            }

            ['ich', 'partner'].forEach(person => {
                const savedDims = TiageState.get(`personDimensions.${person}`);
                console.log(`[loadDimensionsFromState] ${person} savedDims:`, JSON.stringify(savedDims));
                if (!savedDims) {
                    console.log(`[loadDimensionsFromState] Keine gespeicherten Dimensionen fÃ¼r ${person}`);
                    return;
                }

                // Sync geschlecht
                if (savedDims.geschlecht) {
                    // Handle both old format (string) and new format (object with primary/secondary)
                    if (typeof savedDims.geschlecht === 'object' && 'primary' in savedDims.geschlecht) {
                        personDimensions[person].geschlecht = savedDims.geschlecht;
                    } else if (typeof savedDims.geschlecht === 'string') {
                        // Old format: string like "cis_frau" - convert to new format as primary
                        personDimensions[person].geschlecht = { primary: savedDims.geschlecht, secondary: null };
                    }
                }

                // Sync dominanz - handle both formats
                if (savedDims.dominanz) {
                    if (typeof savedDims.dominanz === 'object') {
                        // New format: { primary: 'dominant', secondary: null }
                        if ('primary' in savedDims.dominanz) {
                            personDimensions[person].dominanz = savedDims.dominanz;
                        } else {
                            // Old format: { dominant: 'gelebt', submissiv: null, ... }
                            // Convert to new format
                            let primary = null;
                            let secondary = null;
                            for (const [type, status] of Object.entries(savedDims.dominanz)) {
                                if (status === 'gelebt' && !primary) {
                                    primary = type;
                                } else if (status === 'interessiert' && !secondary) {
                                    secondary = type;
                                }
                            }
                            personDimensions[person].dominanz = { primary, secondary };
                        }
                    }
                }

                // Sync orientierung - handle all formats and migrate to v4.1 Array format
                if (savedDims.orientierung) {
                    let orientierungen = [];

                    // Convert from various formats to Array
                    if (Array.isArray(savedDims.orientierung)) {
                        // Already array format (v4.0+)
                        orientierungen = [...savedDims.orientierung];
                    } else if (typeof savedDims.orientierung === 'object') {
                        if ('primary' in savedDims.orientierung) {
                            // Format: { primary: 'heterosexuell', secondary: null }
                            if (savedDims.orientierung.primary) {
                                orientierungen.push(savedDims.orientierung.primary);
                            }
                            if (savedDims.orientierung.secondary) {
                                orientierungen.push(savedDims.orientierung.secondary);
                            }
                        } else {
                            // Old format: { heterosexuell: 'gelebt', homosexuell: null, ... }
                            for (const [type, status] of Object.entries(savedDims.orientierung)) {
                                if (status === 'gelebt') {
                                    orientierungen.push(type);
                                } else if (status === 'interessiert') {
                                    orientierungen.push(type);
                                }
                            }
                        }
                    }

                    // v4.1: Migrate legacy values
                    orientierungen = orientierungen.map(ori => {
                        if (ori === 'pansexuell_queer') return 'pansexuell';
                        if (ori === 'homosexuell') return 'gay_lesbisch';
                        return ori;
                    });

                    // Remove duplicates and invalid values
                    orientierungen = [...new Set(orientierungen)].filter(o =>
                        o && typeof o === 'string' && o.trim() !== ''
                    );

                    // Store as Array (v4.1 format)
                    personDimensions[person].orientierung = orientierungen;

                    console.log(`[loadDimensionsFromState] ${person} orientierung migriert:`, orientierungen);
                }

                // Sync GFK if present
                if (savedDims.gfk) {
                    personDimensions[person].gfk = savedDims.gfk;
                }

                // Sync mobilePersonDimensions if it exists
                if (typeof mobilePersonDimensions !== 'undefined') {
                    mobilePersonDimensions[person].geschlecht = personDimensions[person].geschlecht;
                    mobilePersonDimensions[person].dominanz = personDimensions[person].dominanz;
                    mobilePersonDimensions[person].orientierung = personDimensions[person].orientierung;
                    mobilePersonDimensions[person].gfk = personDimensions[person].gfk;
                }

                // Sync UI elements after loading (Desktop + Mobile einheitlich)
                if (typeof syncGeschlechtUI === 'function') {
                    syncGeschlechtUI(person);
                }
                if (typeof syncDominanzUI === 'function') {
                    syncDominanzUI(person);  // EnthÃ¤lt jetzt auch syncMobileStatusButtons
                }
                if (typeof syncOrientierungUI === 'function') {
                    syncOrientierungUI(person);  // EnthÃ¤lt jetzt auch syncMobileStatusButtons
                }
            });

            // Update entire UI after loading all dimensions and archetypes
            // This ensures all UI elements reflect the loaded state
            if (typeof updateAll === 'function') {
                updateAll();
            }

            // Load Gewichtungen into UI after TiageState is loaded
            // Only if GewichtungCard DOM elements exist (card is visible)
            if (typeof GewichtungCard !== 'undefined' && GewichtungCard.loadIntoUI) {
                const gewichtungCardVisible = document.getElementById('gewicht-orientierung');
                if (gewichtungCardVisible) {
                    GewichtungCard.loadIntoUI();
                    console.log('[loadDimensionsFromState] GewichtungCard UI aktualisiert');
                } else {
                    console.log('[loadDimensionsFromState] GewichtungCard skipped - DOM not present');
                }
            }

            // Load ResonanzCard into UI after TiageState is loaded
            if (typeof ResonanzCard !== 'undefined' && ResonanzCard.initializeUI) {
                ResonanzCard.initializeUI('ich');
                console.log('[loadDimensionsFromState] ResonanzCard UI aktualisiert');
            }

            console.log('[loadDimensionsFromState] Abgeschlossen - personDimensions:', JSON.stringify(personDimensions));
            console.log('[loadDimensionsFromState] Abgeschlossen - currentArchetype:', currentArchetype, 'selectedPartner:', selectedPartner);
        }

        // Initialize when DOM is ready
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('[TIAGE DEBUG] DOMContentLoaded fired');
            try {
                // Load archetype data first - this is critical for all other functions
                console.log('[TIAGE DEBUG] Before loadData');
                await loadData();
                console.log('[TIAGE DEBUG] After loadData, data loaded:', data !== null);

                checkAgeVerification();
                initAgeVerification();
                initFeedbackSystem();
                initVisitorId();
                console.log('[TIAGE DEBUG] Before initDimensionListeners');
                initDimensionListeners();
                console.log('[TIAGE DEBUG] Before initComparisonLayout');
                initComparisonLayout();
                console.log('[TIAGE DEBUG] Before initMobileLayout');
                initMobileLayout();
                console.log('[TIAGE DEBUG] Before initDimensionButtons');
                initDimensionButtons();
                console.log('[TIAGE DEBUG] After initDimensionButtons');
                initGeschlechtHoverEvents();

                // FIX: Stelle sicher, dass Subscriber registriert sind BEVOR loadFromStorage()
                // aufgerufen wird, damit flatNeeds reaktiv berechnet werden
                if (typeof ProfileCalculator !== 'undefined' && ProfileCalculator.registerSubscribers) {
                    ProfileCalculator.registerSubscribers();
                }

                console.log('[TIAGE DEBUG] Before loadDimensionsFromState');
                // Load saved dimensions from TiageState AFTER initializing buttons
                // so that UI sync functions can update the buttons
                loadDimensionsFromState();

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // SSOT: Stelle sicher, dass flatNeeds + Resonanzfaktoren fÃ¼r beide Personen
                // berechnet und in TiageState gespeichert sind (bei App-Start)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (typeof ProfileCalculator !== 'undefined' && typeof TiageState !== 'undefined') {
                    ['ich', 'partner'].forEach(person => {
                        const archetyp = person === 'ich' ? currentArchetype : selectedPartner;
                        const flatNeeds = TiageState.get(`flatNeeds.${person}`);

                        // Nur berechnen wenn flatNeeds leer oder nicht vorhanden
                        if (!flatNeeds || Object.keys(flatNeeds).length === 0) {
                            const profileData = {
                                archetyp: archetyp,
                                geschlecht: TiageState.get(`personDimensions.${person}.geschlecht`),
                                dominanz: TiageState.get(`personDimensions.${person}.dominanz`),
                                orientierung: TiageState.get(`personDimensions.${person}.orientierung`)
                            };
                            if (profileData.archetyp) {
                                ProfileCalculator.loadProfile(person, profileData);
                                console.log('[SSOT] Initial-Profil berechnet fÃ¼r', person, ':', archetyp);
                            }
                        } else {
                            console.log('[SSOT] flatNeeds bereits vorhanden fÃ¼r', person, ':', Object.keys(flatNeeds).length, 'EintrÃ¤ge');
                        }
                    });
                }

                // Initialize all summary displays in header
                updateGeschlechtSummary('ich');
                updateGeschlechtSummary('partner');
                updateDominanzSummary('ich');
                updateDominanzSummary('partner');
                updateOrientierungSummary('ich');
                updateOrientierungSummary('partner');
                // GFK automatisch aus Archetypen-Matching setzen
                updateGfkFromArchetypes();

                // IMPORTANT: Update comparison view AFTER loading dimensions
                // This ensures the score is calculated with the correct data
                console.log('[TIAGE DEBUG] Before updateComparisonView');
                updateComparisonView();
                updateSyntheseScoreCycle();
                console.log('[TIAGE DEBUG] After updateComparisonView');

                // Note: openComments=1 parameter is now handled in handleAgeConfirm()
                // to ensure age verification is completed before opening comments modal

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Event-Listener fÃ¼r Resonanzfaktoren-Ã„nderungen
                // Aktualisiert LoadedArchetypProfile wenn sich Resonanzfaktoren Ã¤ndern
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Debounce fÃ¼r Slider-Ã„nderungen (verhindert zu hÃ¤ufige Score-Updates)
                let resonanzUpdateDebounce = null;
                const RESONANZ_DEBOUNCE_DELAY = 100; // ms

                window.addEventListener('resonanzfaktoren-changed', function(e) {
                    const { person, values, source } = e.detail;

                    // NOTE: LoadedArchetypProfile ist ein View auf TiageState (SSOT).
                    // save() in ResonanzCard hat TiageState bereits aktualisiert.
                    // Hier NICHT separat schreiben, da 'values' nur Werte ohne Lock-Status enthÃ¤lt.
                    // Das wÃ¼rde die Lock-Struktur {value, locked} mit nur Werten Ã¼berschreiben.
                    console.log('[TIAGE] resonanzfaktoren-changed Event fÃ¼r', person, '- Quelle:', source);

                    // FIX: Aktualisiere Comparison View fÃ¼r ALLE Quellen (inkl. Slider)
                    // Debounce bei Slider-Ã„nderungen um Performance zu optimieren
                    if (source === 'slider') {
                        if (resonanzUpdateDebounce) {
                            clearTimeout(resonanzUpdateDebounce);
                        }
                        resonanzUpdateDebounce = setTimeout(function() {
                            updateComparisonView();
                        }, RESONANZ_DEBOUNCE_DELAY);
                    } else {
                        // Sofortiges Update fÃ¼r andere Quellen (reset, calculated, etc.)
                        updateComparisonView();
                    }
                });

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Hilfsfunktion: Kurze Toast-Meldung fÃ¼r Lock-Speicherung
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                function showLockSavedToast(message) {
                    var existing = document.getElementById('lockSavedToast');
                    if (existing) existing.remove();

                    var toast = document.createElement('div');
                    toast.id = 'lockSavedToast';
                    toast.textContent = message;
                    toast.style.cssText = 'position:fixed;bottom:80px;left:50%;transform:translateX(-50%);background:#22c55e;color:#fff;padding:8px 16px;border-radius:6px;font-size:13px;z-index:10000;opacity:0;transition:opacity 0.2s;box-shadow:0 2px 8px rgba(0,0,0,0.3);';
                    document.body.appendChild(toast);

                    requestAnimationFrame(function() { toast.style.opacity = '1'; });
                    setTimeout(function() {
                        toast.style.opacity = '0';
                        setTimeout(function() { toast.remove(); }, 200);
                    }, 1500);
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Event-Listener fÃ¼r BedÃ¼rfnis-Lock-Ã„nderungen
                // Synchronisiert Lock-Status mit TiageState.profileReview.{person}.lockedNeeds
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                console.log('[DEBUG] Registering flatNeedLockChange listener');
                document.addEventListener('flatNeedLockChange', function(e) {
                    console.log('[DEBUG] flatNeedLockChange listener CALLED', e.detail);
                    var needId = e.detail && e.detail.needId;
                    var locked = e.detail && e.detail.locked;

                    if (!needId || typeof TiageState === 'undefined') return;

                    // Ermittle aktuelle Person aus Kontext
                    var currentPerson = 'ich';
                    if (window.currentProfileReviewContext && window.currentProfileReviewContext.person) {
                        currentPerson = window.currentProfileReviewContext.person;
                    }

                    if (locked) {
                        // Beim Sperren: Hole aktuellen Wert aus AttributeSummaryCard
                        var currentValue = 50; // Fallback
                        if (typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.getFlatNeeds) {
                            var flatNeeds = AttributeSummaryCard.getFlatNeeds();
                            var needObj = flatNeeds.find(function(n) { return n.id === needId; });
                            if (needObj) {
                                currentValue = needObj.value;
                            }
                        }
                        TiageState.lockNeed(currentPerson, needId, currentValue);
                        console.log('[flatNeedLockChange] BedÃ¼rfnis gesperrt:', needId, '=', currentValue, 'fÃ¼r', currentPerson);
                    } else {
                        // Beim Entsperren: Entferne aus lockedNeeds
                        TiageState.unlockNeed(currentPerson, needId);
                        console.log('[flatNeedLockChange] BedÃ¼rfnis entsperrt:', needId, 'fÃ¼r', currentPerson);
                    }
                    // Sofort in localStorage speichern
                    TiageState.saveToStorage();

                    // Kurze Info einblenden
                    showLockSavedToast(locked ? 'Wert gesperrt & gespeichert' : 'Wert entsperrt');
                });

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // Event-Listener fÃ¼r BedÃ¼rfnis-Wert-Ã„nderungen
                // FIX v1.8.455: Speichere ALLE Wert-Ã„nderungen in TiageState.flatNeeds
                // ZusÃ¤tzlich: Gesperrte Werte werden in profileReview.lockedNeeds gespeichert
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                document.addEventListener('flatNeedChange', function(e) {
                    var needId = e.detail && e.detail.needId;
                    var value = e.detail && e.detail.value;

                    if (!needId || value === undefined || typeof TiageState === 'undefined') return;

                    // Ermittle aktuelle Person aus Kontext
                    var currentPerson = 'ich';
                    if (window.currentProfileReviewContext && window.currentProfileReviewContext.person) {
                        currentPerson = window.currentProfileReviewContext.person;
                    }

                    // FIX: IMMER in TiageState.flatNeeds speichern (damit Werte beim Tab-Wechsel erhalten bleiben)
                    TiageState.setNeed(currentPerson, needId, value);
                    console.log('[flatNeedChange] Wert in TiageState.flatNeeds gespeichert:', needId, '=', value, 'fÃ¼r', currentPerson);

                    // ZusÃ¤tzlich: Wenn gesperrt, auch in lockedNeeds speichern (fÃ¼r Persistenz Ã¼ber Page-Reload)
                    if (TiageState.isNeedLocked(currentPerson, needId)) {
                        TiageState.lockNeed(currentPerson, needId, value);
                        TiageState.saveToStorage();
                        console.log('[flatNeedChange] Gesperrter Wert auch in lockedNeeds gespeichert:', needId);
                    }
                });

                // Initialize MomentsToggle in header
                if (typeof MomentsToggle !== 'undefined' && typeof MomentsToggle.init === 'function') {
                    MomentsToggle.init();
                    console.log('[TIAGE DEBUG] MomentsToggle initialized');
                }

                // Initialize AGOD weight inputs (always reset to 4x 25% on page load)
                if (typeof initAgodWeightInputs === 'function') {
                    initAgodWeightInputs();
                    console.log('[TIAGE DEBUG] AGOD weight inputs initialized');
                }

                console.log('[TIAGE DEBUG] DOMContentLoaded completed successfully');
            } catch (e) {
                console.error('[TIAGE ERROR] DOMContentLoaded failed:', e);
            }
        });

        // ========================================
        // FEATURE 1: Factor Detail Modal
        // ========================================

        const factorExplanations = {
            archetyp: {
                title: 'Archetyp-Ãœbereinstimmung',
                subtitle: '(Beziehungsphilosophie - Verstand&Logos)',
                getExplanation: (ich, partner, score) => {
                    const ichName = data?.archetypes?.[ich]?.name || ich;
                    const partnerName = data?.archetypes?.[partner]?.name || partner;

                    if (ich === partner) {
                        return `${ichName} und ${partnerName} teilen dieselbe Beziehungsphilosophie. Beide haben identische GrundÃ¼berzeugungen Ã¼ber Beziehungsstrukturen.`;
                    }

                    if (score >= 80) {
                        return `${ichName} und ${partnerName} haben sehr Ã¤hnliche Beziehungsphilosophien. Die GrundÃ¼berzeugungen passen gut zusammen und erfordern nur minimale Kompromisse.`;
                    } else if (score >= 60) {
                        return `${ichName} und ${partnerName} haben unterschiedliche, aber kompatible Beziehungsphilosophien. Beide Archetypen kÃ¶nnen sich mit Kommunikation und VerstÃ¤ndnis ergÃ¤nzen.`;
                    } else {
                        return `${ichName} und ${partnerName} haben fundamentale philosophische Unterschiede. Die Beziehungsvorstellungen weichen stark voneinander ab und erfordern intensive Kommunikation.`;
                    }
                },
                getMeaning: (score, ich, partner) => {
                    const ichName = data?.archetypes?.[ich]?.name || ich;
                    const partnerName = data?.archetypes?.[partner]?.name || partner;
                    const rhetoricNote = { title: 'ğŸ’¡ Warum Logos (Verstand)?', desc: 'Archetypen basieren auf rationalen Beziehungsphilosophien und bewussten Ãœberzeugungen â€“ sie sprechen den Verstand an, nicht das GefÃ¼hl.' };

                    if (ich === partner) {
                        return [
                            rhetoricNote,
                            { title: `ğŸ“Œ In dieser Kombination teilen beide denselben Archetyp "${ichName}" â€“ maximale philosophische Ãœbereinstimmung.`, desc: '' },
                            { title: 'Gleiche GrundÃ¼berzeugungen', desc: 'Beide haben identische Vorstellungen davon, wie eine Beziehung funktionieren sollte.' },
                            { title: 'Intuitive VerstÃ¤ndigung', desc: 'Die gemeinsame Basis ermÃ¶glicht tiefes gegenseitiges Verstehen ohne lange ErklÃ¤rungen.' },
                            { title: 'NatÃ¼rliche Harmonie', desc: 'Keine grundsÃ¤tzlichen Konflikte durch unterschiedliche Beziehungsphilosophien.' }
                        ];
                    }

                    if (score >= 80) {
                        return [
                            rhetoricNote,
                            { title: `ğŸ“Œ In dieser Kombination von "${ichName}" und "${partnerName}" ergÃ¤nzen sich die Beziehungsphilosophien sehr gut.`, desc: '' },
                            { title: 'Hohe philosophische Ãœbereinstimmung', desc: 'Beide teilen Ã¤hnliche Grundwerte und Beziehungsideale.' },
                            { title: 'Wenige grundsÃ¤tzliche Konflikte', desc: 'Weltanschauung und Lebensziele sind weitgehend kompatibel.' },
                            { title: 'Ã„hnliche Erwartungen an die Beziehung', desc: 'Was beide von Partnerschaft erwarten, deckt sich gut.' }
                        ];
                    } else if (score >= 60) {
                        return [
                            rhetoricNote,
                            { title: `ğŸ“Œ In dieser Kombination von "${ichName}" und "${partnerName}" gibt es sowohl Gemeinsamkeiten als auch deutliche Unterschiede.`, desc: '' },
                            { title: 'Mittlere philosophische Ãœbereinstimmung', desc: 'Grundwerte Ã¼berlappen, aber es gibt Unterschiede.' },
                            { title: 'Kompromisse und Kommunikation nÃ¶tig', desc: 'Unterschiedliche PrioritÃ¤ten erfordern regelmÃ¤ÃŸigen Austausch.' },
                            { title: 'Unterschiedliche, aber vereinbare BedÃ¼rfnisse', desc: 'Mit FlexibilitÃ¤t kÃ¶nnen beide Seiten zufrieden sein.' }
                        ];
                    } else {
                        return [
                            rhetoricNote,
                            { title: `ğŸ“Œ In dieser Kombination von "${ichName}" und "${partnerName}" prallen grundlegend verschiedene Beziehungsphilosophien aufeinander.`, desc: '' },
                            { title: 'Niedrige philosophische Ãœbereinstimmung', desc: 'GrundsÃ¤tzlich verschiedene Sichtweisen auf Beziehung.' },
                            { title: 'Intensive Kommunikation erforderlich', desc: 'Ohne bewusste Arbeit entstehen leicht MissverstÃ¤ndnisse.' },
                            { title: 'Fundamentale Kompromisse notwendig', desc: 'Beide mÃ¼ssen auf wichtige eigene BedÃ¼rfnisse verzichten kÃ¶nnen.' }
                        ];
                    }
                }
            },
            dominanz: {
                title: 'Dominanz-Harmonie',
                subtitle: '(Emotionale Dynamik - GefÃ¼hl&Pathos)',
                getExplanation: (ich, partner, score, dimensions) => {
                    // Use passed dimensions, fallback to mobilePersonDimensions for backward compatibility
                    const dims = dimensions || mobilePersonDimensions;
                    const ichDomObj = dims.ich.dominanz;
                    const partnerDomObj = dims.partner.dominanz;

                    // Translate values to German labels for display
                    const domLabels = {
                        'dominant': 'dominant',
                        'submissiv': 'submissiv',
                        'switch': 'Switch',
                        'ausgeglichen': 'ausgeglichen'
                    };

                    // Harmony matrix - SSOT: Referenziert Constants.DOMINANCE_MATRIX
                    const harmonyMatrix = (typeof TiageSynthesis !== 'undefined' &&
                        TiageSynthesis.Constants &&
                        TiageSynthesis.Constants.DOMINANCE_MATRIX)
                        ? TiageSynthesis.Constants.DOMINANCE_MATRIX
                        : getDominanzHarmonyMatrix();

                    // Helper to get all selections with status
                    const getAllSelections = (domObj) => {
                        if (!domObj || typeof domObj !== 'object') return [];
                        const selections = [];
                        for (const [type, status] of Object.entries(domObj)) {
                            if (status) selections.push({ type, status });
                        }
                        return selections;
                    };

                    const ichSelections = getAllSelections(ichDomObj);
                    const partnerSelections = getAllSelections(partnerDomObj);

                    if (ichSelections.length === 0 || partnerSelections.length === 0) {
                        return 'Bitte wÃ¤hle fÃ¼r beide Personen mindestens eine Dominanz-Tendenz.';
                    }

                    // Find best combination across ALL selections (primary + secondary)
                    let bestCombo = null;
                    let bestScore = 0;
                    for (const ichSel of ichSelections) {
                        for (const partnerSel of partnerSelections) {
                            const key = `${ichSel.type}-${partnerSel.type}`;
                            let baseScore = harmonyMatrix[key] || harmonyMatrix[`${partnerSel.type}-${ichSel.type}`] || 75;
                            // Reduce score if either is "interessiert"
                            const hasInteressiert = ichSel.status === 'interessiert' || partnerSel.status === 'interessiert';
                            const adjustedScore = hasInteressiert ? Math.round(baseScore * 0.7) : baseScore;
                            if (adjustedScore > bestScore) {
                                bestScore = adjustedScore;
                                bestCombo = { ich: ichSel, partner: partnerSel, hasInteressiert, baseScore };
                            }
                        }
                    }

                    if (!bestCombo) {
                        return 'Keine kompatible Dominanz-Kombination gefunden.';
                    }

                    const ichType = bestCombo.ich.type;
                    const partnerType = bestCombo.partner.type;
                    const ichStatusLabel = bestCombo.ich.status === 'gelebt' ? 'Gelebt' : 'Interessiert';
                    const partnerStatusLabel = bestCombo.partner.status === 'gelebt' ? 'Gelebt' : 'Interessiert';

                    // Build explanation based on best combination
                    let explanation = `Beste Kombination: ${domLabels[ichType]} (${ichStatusLabel}) â†” ${domLabels[partnerType]} (${partnerStatusLabel}). `;

                    if (ichType === partnerType) {
                        if (ichType === 'ausgeglichen' || ichType === 'switch') {
                            explanation += `Beide bevorzugen ${domLabels[ichType]} - flexible Dynamik mÃ¶glich.`;
                        } else if (ichType === 'dominant') {
                            explanation += `Beide dominant - Machtkampf-Risiko, aber mit Kommunikation machbar.`;
                        } else if (ichType === 'submissiv') {
                            explanation += `Beide submissiv - FÃ¼hrungsvakuum-Risiko, klare Absprachen wichtig.`;
                        }
                    } else if ((ichType === 'dominant' && partnerType === 'submissiv') ||
                               (ichType === 'submissiv' && partnerType === 'dominant')) {
                        explanation += `Perfekte KomplementaritÃ¤t in der emotionalen Dynamik!`;
                    } else {
                        explanation += `Interessante Dynamik mit FlexibilitÃ¤tspotential.`;
                    }

                    // Add warning if best combo uses "interessiert"
                    if (bestCombo.hasInteressiert) {
                        explanation += ` âš ï¸ Exploration-Phase: Reduzierte Konfidenz (${bestCombo.baseScore}% â†’ ${bestScore}%).`;
                    }

                    return explanation;
                },
                getMeaning: (score) => {
                    const rhetoricNote = { title: 'ğŸ’¡ Warum Pathos (GefÃ¼hl)?', desc: 'Dominanz-Dynamik wirkt auf der emotionalen Ebene â€“ wer fÃ¼hrt, wer folgt, entsteht aus GefÃ¼hl und Instinkt, nicht aus rationaler Ãœberlegung.' };
                    if (score >= 80) {
                        return [
                            rhetoricNote,
                            { title: 'Harmonische emotionale Dynamik', desc: 'Die Rollen (FÃ¼hren/Folgen) ergÃ¤nzen sich natÃ¼rlich ohne Reibung.' },
                            { title: 'NatÃ¼rliche Rollenverteilung', desc: 'Entscheidungen und Verantwortung flieÃŸen organisch zwischen beiden.' },
                            { title: 'Geringe Reibungspunkte', desc: 'Wenig Konflikte um Kontrolle oder PassivitÃ¤t zu erwarten.' }
                        ];
                    } else if (score >= 60) {
                        return [
                            rhetoricNote,
                            { title: 'Funktionale emotionale Dynamik', desc: 'Die Rollen funktionieren, sind aber nicht perfekt komplementÃ¤r.' },
                            { title: 'Flexible Anpassung mÃ¶glich', desc: 'Mit gegenseitigem VerstÃ¤ndnis kann Balance gefunden werden.' },
                            { title: 'Gelegentliche Abstimmung nÃ¶tig', desc: 'Manchmal braucht es GesprÃ¤che Ã¼ber Erwartungen und BedÃ¼rfnisse.' }
                        ];
                    } else {
                        // Forschungsbasiert: Sadikaj et al. (2017) - MachtkÃ¤mpfe bei gleicher PolaritÃ¤t
                        return [
                            rhetoricNote,
                            { title: 'Machtkampf- oder FÃ¼hrungsvakuum-Risiko', desc: 'Beide dominant = KonkurrenzkÃ¤mpfe. Beide submissiv = keiner Ã¼bernimmt FÃ¼hrung.' },
                            { title: 'Bewusste Kommunikationsregeln wichtig', desc: 'Klare Absprachen nÃ¶tig, wer wann welche Rolle Ã¼bernimmt.' },
                            { title: 'Klare Aufgabenteilung empfohlen', desc: 'Definierte Verantwortungsbereiche reduzieren Konflikte.' }
                        ];
                    }
                }
            },
            orientierung: {
                title: 'Orientierungs-KompatibilitÃ¤t',
                subtitle: '(KÃ¶rperliche Anziehung - GefÃ¼hl&Pathos)',
                getExplanation: (ich, partner, score, dimensions) => {
                    // Use passed dimensions, fallback to mobilePersonDimensions for backward compatibility
                    const dims = dimensions || mobilePersonDimensions;
                    const ichOri = dims.ich.orientierung;
                    const partnerOri = dims.partner.orientierung;

                    // Translate values to German labels for display
                    const oriLabels = {
                        'heterosexuell': 'heterosexuell',
                        'homosexuell': 'homosexuell',
                        'bisexuell': 'bisexuell'
                    };
                    const ichLabel = oriLabels[ichOri] || ichOri || 'nicht gewÃ¤hlt';
                    const partnerLabel = oriLabels[partnerOri] || partnerOri || 'nicht gewÃ¤hlt';

                    if (score === 100) {
                        return `${ichLabel} und ${partnerLabel} - perfekte KompatibilitÃ¤t! KÃ¶rperliche Anziehung ist definitiv mÃ¶glich.`;
                    } else if (score >= 50) {
                        return `${ichLabel} und ${partnerLabel} - Anziehung ist mÃ¶glich, besonders wenn mindestens eine Person bisexuell orientiert ist.`;
                    } else {
                        return `${ichLabel} und ${partnerLabel} - Keine kÃ¶rperliche Anziehung mÃ¶glich aufgrund der sexuellen Orientierungen.`;
                    }
                },
                getMeaning: (score) => {
                    const rhetoricNote = { title: 'ğŸ’¡ Warum Pathos (GefÃ¼hl)?', desc: 'Sexuelle Orientierung bestimmt, wen wir kÃ¶rperlich anziehend finden â€“ ein tiefes, unbewusstes GefÃ¼hl, keine rationale Wahl.' };
                    if (score === 100) {
                        return [
                            rhetoricNote,
                            { title: 'VollstÃ¤ndige kÃ¶rperliche KompatibilitÃ¤t', desc: 'Die sexuellen Orientierungen beider passen ideal zusammen.' },
                            { title: 'Keine Barrieren fÃ¼r Anziehung', desc: 'Beide kÃ¶nnen sich potenziell zueinander hingezogen fÃ¼hlen.' },
                            { title: 'Basis fÃ¼r romantische Beziehung vorhanden', desc: 'KÃ¶rperliche Anziehung kann Grundlage fÃ¼r mehr sein.' }
                        ];
                    } else if (score >= 50) {
                        return [
                            rhetoricNote,
                            { title: 'MÃ¶gliche kÃ¶rperliche KompatibilitÃ¤t', desc: 'Unter bestimmten UmstÃ¤nden ist Anziehung mÃ¶glich.' },
                            { title: 'Anziehung kann entstehen', desc: 'Nicht automatisch, aber nicht ausgeschlossen.' },
                            { title: 'HÃ¤ngt von individuellen PrÃ¤ferenzen ab', desc: 'PersÃ¶nliche Neigungen spielen grÃ¶ÃŸere Rolle.' }
                        ];
                    } else {
                        return [
                            rhetoricNote,
                            { title: 'Keine kÃ¶rperliche KompatibilitÃ¤t', desc: 'Die Orientierungen schlieÃŸen gegenseitige Anziehung aus.' },
                            { title: 'Romantische Beziehung nicht mÃ¶glich', desc: 'Keine Basis fÃ¼r eine intime Partnerschaft.' },
                            { title: 'Freundschaft mÃ¶glich', desc: 'Eine platonische Verbindung bleibt eine Option.' }
                        ];
                    }
                }
            },
            geschlecht: {
                title: 'Geschlechts-Attraktion',
                subtitle: '(Gender-Chemie - GefÃ¼hl&Pathos)',
                getExplanation: (ich, partner, score, dimensions) => {
                    // Use passed dimensions, fallback to mobilePersonDimensions for backward compatibility
                    const dims = dimensions || mobilePersonDimensions;
                    const ichG = dims.ich.geschlecht;
                    const partnerG = dims.partner.geschlecht;

                    // Translate values to German labels for display
                    const genderLabels = {
                        'mÃ¤nnlich': 'mÃ¤nnlich',
                        'weiblich': 'weiblich',
                        'non-binÃ¤r': 'non-binÃ¤r'
                    };
                    const ichLabel = genderLabels[ichG] || ichG || 'nicht gewÃ¤hlt';
                    const partnerLabel = genderLabels[partnerG] || partnerG || 'nicht gewÃ¤hlt';

                    if (score === 100) {
                        return `Die Geschlechterkonstellation ${ichLabel} Ã— ${partnerLabel} passt perfekt zu den angegebenen Orientierungen.`;
                    } else if (score >= 50) {
                        return `Die Geschlechterkonstellation ${ichLabel} Ã— ${partnerLabel} ist mit den angegebenen Orientierungen grundsÃ¤tzlich kompatibel.`;
                    } else {
                        return `Die Geschlechterkonstellation ${ichLabel} Ã— ${partnerLabel} passt nicht zu den angegebenen Orientierungen.`;
                    }
                },
                getMeaning: (score) => {
                    const rhetoricNote = { title: 'ğŸ’¡ Warum Pathos (GefÃ¼hl)?', desc: 'Gender-Chemie ist die instinktive Reaktion auf das Geschlecht des anderen â€“ ein unbewusstes GefÃ¼hl, das kÃ¶rperliche Anziehung auslÃ¶st oder blockiert.' };
                    if (score === 100) {
                        return [
                            rhetoricNote,
                            { title: 'Ideale Geschlechterkonstellation', desc: 'Die Geschlechter-Kombination passt perfekt zu beiden Orientierungen.' },
                            { title: 'Maximale Anziehungskraft mÃ¶glich', desc: 'Gender-Chemie kann voll entfaltet werden.' },
                            { title: 'Keine gender-bezogenen Barrieren', desc: 'Die Geschlechter bilden keine HÃ¼rde fÃ¼r Anziehung.' }
                        ];
                    } else if (score >= 50) {
                        return [
                            rhetoricNote,
                            { title: 'Akzeptable Geschlechterkonstellation', desc: 'Nicht optimal, aber funktional fÃ¼r Anziehung.' },
                            { title: 'Anziehung mÃ¶glich', desc: 'Kann entstehen, ist aber nicht garantiert.' },
                            { title: 'Individuelle PrÃ¤ferenzen entscheidend', desc: 'PersÃ¶nliche Vorlieben bestimmen den Ausgang.' }
                        ];
                    } else {
                        return [
                            rhetoricNote,
                            { title: 'Inkompatible Geschlechterkonstellation', desc: 'Die Geschlechter-Kombination passt nicht zu den Orientierungen.' },
                            { title: 'Anziehung unwahrscheinlich', desc: 'KÃ¶rperliche Chemie wird kaum entstehen.' },
                            { title: 'Orientierung passt nicht', desc: 'Die PrÃ¤ferenzen zeigen in andere Richtungen.' }
                        ];
                    }
                }
            }
        };

        function openFactorModal(factorType, source = 'mobile') {
            const factor = factorExplanations[factorType];
            if (!factor) return;

            // Store current factor type and source for navigation
            currentFactorType = factorType;
            currentFactorSource = source;

            const ich = mobileIchArchetype;
            const partner = mobilePartnerArchetype;

            // Use correct dimensions based on source
            const dimensions = source === 'desktop' ? personDimensions : mobilePersonDimensions;

            // Get score from display - support both mobile and desktop
            const prefix = source === 'desktop' ? 'desktopFactor' : 'mobileFactor';
            let score = 0;
            if (factorType === 'archetyp') {
                score = parseInt(document.getElementById(prefix + 'Archetyp').textContent) || 0;
            } else if (factorType === 'dominanz') {
                score = parseInt(document.getElementById(prefix + 'Dominanz').textContent) || 0;
            } else if (factorType === 'orientierung') {
                score = parseInt(document.getElementById(prefix + 'Orientierung').textContent) || 0;
            } else if (factorType === 'geschlecht') {
                score = parseInt(document.getElementById(prefix + 'Geschlecht').textContent) || 0;
            }

            // Update modal content
            document.getElementById('factorModalTitle').textContent = factor.title;
            document.getElementById('factorModalSubtitle').textContent = factor.subtitle;

            // Update archetype navigation display
            updateFactorModalArchetypeDisplay();

            // Show combination code for archetyp and dominanz factors
            const comboCodeEl = document.getElementById('factorModalComboCode');
            if (factorType === 'archetyp' && ich && partner) {
                const comboCode = `${ich}_${partner}`;
                comboCodeEl.textContent = `Code: ${comboCode}`;
                comboCodeEl.style.display = 'inline-block';
            } else if (factorType === 'dominanz') {
                // Get dominanz and orientierung selections for combo code
                const ichDom = dimensions.ich.dominanz;
                const partnerDom = dimensions.partner.dominanz;
                const ichOri = dimensions.ich.orientierung;
                const partnerOri = dimensions.partner.orientierung;
                const domAbbrev = { 'dominant': 'Dom', 'submissiv': 'Sub', 'switch': 'Swi', 'ausgeglichen': 'Aus' };
                const oriAbbrev = { 'heterosexuell': 'Het', 'homosexuell': 'Hom', 'bisexuell': 'Bi' };

                const getSelectedDom = (domObj) => {
                    if (!domObj) return null;
                    for (const [type, status] of Object.entries(domObj)) {
                        if (status) return domAbbrev[type] || type;
                    }
                    return null;
                };

                const getSelectedOri = (oriObj) => {
                    if (!oriObj) return null;
                    for (const [type, status] of Object.entries(oriObj)) {
                        if (status) return oriAbbrev[type] || type;
                    }
                    return null;
                };

                const ichDomCode = getSelectedDom(ichDom);
                const partnerDomCode = getSelectedDom(partnerDom);
                const ichOriCode = getSelectedOri(ichOri);
                const partnerOriCode = getSelectedOri(partnerOri);

                // Build code: Orientierung-Dominanz for each person
                const ichCode = [ichOriCode, ichDomCode].filter(Boolean).join('-');
                const partnerCode = [partnerOriCode, partnerDomCode].filter(Boolean).join('-');

                if (ichCode && partnerCode) {
                    comboCodeEl.textContent = `Code: ${ichCode}_${partnerCode}`;
                    comboCodeEl.style.display = 'inline-block';
                } else if (ichDomCode && partnerDomCode) {
                    // Fallback to just dominanz if orientierung not selected
                    comboCodeEl.textContent = `Code: ${ichDomCode}_${partnerDomCode}`;
                    comboCodeEl.style.display = 'inline-block';
                } else {
                    comboCodeEl.style.display = 'none';
                }
            } else {
                comboCodeEl.style.display = 'none';
            }

            document.getElementById('factorModalScore').textContent = score;
            document.getElementById('factorModalExplanation').textContent = factor.getExplanation(ich, partner, score, dimensions);

            const meaningList = document.getElementById('factorModalMeaning');
            meaningList.innerHTML = '';
            factor.getMeaning(score, ich, partner).forEach(item => {
                const li = document.createElement('li');
                // Support both old (string) and new (object with title+desc) formats
                if (typeof item === 'object' && item.title) {
                    li.innerHTML = `<strong>${item.title}</strong>${item.desc ? ` â€“ ${item.desc}` : ''}`;
                } else {
                    li.textContent = item;
                }
                meaningList.appendChild(li);
            });

            // Show modal
            document.getElementById('factorModal').classList.add('active');
            // Push state for back button to close modal
            history.pushState({ mobilePage: currentMobilePage, modal: 'factor' }, '', `#seite${currentMobilePage}-factor`);
        }

        function closeFactorModal(event, skipHistoryBack = false) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('factorModal').classList.remove('active');
            // Go back in history if not triggered by back button
            if (!skipHistoryBack && history.state && history.state.modal === 'factor') {
                history.back();
            }
        }

        // Ti-Age Synthese Modal Functions (unified Score/Pathos/Logos)
        let currentTiageSyntheseType = TiageState.get('ui.syntheseType') || 'score'; // Sticky: 'score', 'pathos' or 'logos'
        let currentTiageSyntheseContent = { score: '', pathos: '', logos: '' };

        // Legacy aliases for backwards compatibility
        let currentPathosLogosType = currentTiageSyntheseType;
        let currentPathosLogosContent = currentTiageSyntheseContent;

        function openTiageSyntheseModal(type = null) {
            console.log('[TIAGE] openTiageSyntheseModal called with type:', type);
            const modal = document.getElementById('tiageSyntheseModal');
            console.log('[TIAGE] Modal element found:', !!modal);
            if (!modal) {
                console.error('[TIAGE] tiageSyntheseModal NOT FOUND in DOM!');
                return;
            }

            // Use sticky type if no type specified
            if (type === null) {
                type = currentTiageSyntheseType;
            }
            currentTiageSyntheseType = type;
            currentPathosLogosType = type; // Keep legacy in sync

            // Get current archetypes
            const ichArch = archetypeDescriptions[currentArchetype];
            const partnerArch = archetypeDescriptions[selectedPartner];
            console.log('[TIAGE] Archetypes:', currentArchetype, selectedPartner, !!ichArch, !!partnerArch);

            // Update archetype display
            const ichDisplay = document.getElementById('tiageSyntheseModalIch');
            const partnerDisplay = document.getElementById('tiageSyntheseModalPartner');
            if (ichDisplay) ichDisplay.textContent = ichArch?.name || currentArchetype;
            if (partnerDisplay) partnerDisplay.textContent = partnerArch?.name || selectedPartner;

            // Generate content for all types
            try {
                console.log('[TIAGE] Generating pathos content...');
                currentTiageSyntheseContent.pathos = generateCombinedPathos(ichArch, partnerArch);
                console.log('[TIAGE] Generating logos content...');
                currentTiageSyntheseContent.logos = generateCombinedLogos(ichArch, partnerArch);
                console.log('[TIAGE] Content generated successfully');
            } catch (e) {
                console.error('[TIAGE] Error generating content:', e);
            }

            // Show the selected type
            try {
                console.log('[TIAGE] Showing content type:', type);
                showTiageSyntheseContent(type);
            } catch (e) {
                console.error('[TIAGE] Error in showTiageSyntheseContent:', e);
            }

            // Update Score Cycle
            try {
                updateSyntheseScoreCycle();
            } catch (e) {
                console.error('[TIAGE] Error in updateSyntheseScoreCycle:', e);
            }

            console.log('[TIAGE] Adding active class to modal');
            modal.classList.add('active');
            history.pushState({ mobilePage: currentMobilePage, modal: 'tiagesynthese' }, '', `#seite${currentMobilePage}-tiagesynthese`);
            console.log('[TIAGE] Modal should now be visible');
        }

        // Legacy alias
        function openPathosLogosModal(type = null) {
            openTiageSyntheseModal(type);
        }

        // Legacy alias for Pro/Contra modal
        function openProContraModal() {
            openTiageSyntheseModal('score');
        }

        function closeTiageSyntheseModal(event, skipHistoryBack = false) {
            if (event && event.target !== event.currentTarget) return;
            // Stop TTS when modal is closed
            stopTTSOnModalClose();
            const modal = document.getElementById('tiageSyntheseModal');
            if (modal) modal.classList.remove('active');
            if (!skipHistoryBack && history.state && (history.state.modal === 'tiagesynthese' || history.state.modal === 'pathoslogos' || history.state.modal === 'procontra')) {
                history.back();
            }
        }

        // Legacy aliases
        function closePathosLogosModal(event, skipHistoryBack = false) {
            closeTiageSyntheseModal(event, skipHistoryBack);
        }
        function closeProContraModal(event, skipHistoryBack = false) {
            closeTiageSyntheseModal(event, skipHistoryBack);
        }

        function navigateProContraArchetype(person, direction) {
            navigateTiageSyntheseArchetype(person, direction);
        }

        function showTiageSyntheseContent(type) {
            currentTiageSyntheseType = type;
            currentPathosLogosType = type; // Keep legacy in sync
            // Stop TTS when switching content
            stopTTSOnModalClose();
            // Save to TiageState for sticky behavior (SSOT)
            TiageState.set('ui.syntheseType', type);

            const titleEl = document.getElementById('tiageSyntheseModalTitle');
            const iconEl = document.getElementById('tiageSyntheseIcon');
            const categoryEl = document.getElementById('tiageSyntheseCategory');
            const subtitleEl = document.getElementById('tiageSyntheseSubtitle');
            const contentEl = document.getElementById('tiageSyntheseModalContent');
            const typeIndicatorEl = document.getElementById('tiageSyntheseTypeIndicator');

            // Sticky side buttons
            const scoreBtn = document.getElementById('tiageSyntheseToggleScore');
            const oshoZenBtn = document.getElementById('tiageSyntheseToggleOshoZen');
            const needsBtn = document.getElementById('tiageSyntheseToggleNeeds');

            // Modal header buttons
            const modalScoreBtn = document.getElementById('modalScoreBtn');
            const modalOshoZenBtn = document.getElementById('modalOshoZenBtn');
            const modalNeedsBtn = document.getElementById('modalNeedsBtn');

            // Reset all sticky side button styles
            [scoreBtn, oshoZenBtn, needsBtn].forEach(btn => {
                if (btn) {
                    btn.style.background = 'rgba(30,30,35,0.95)';
                    btn.style.color = 'var(--text-muted)';
                    btn.style.border = '1px solid var(--border)';
                }
            });

            // Reset modal header button styles
            [modalScoreBtn, modalOshoZenBtn, modalNeedsBtn].forEach(btn => {
                if (btn) btn.classList.remove('active');
            });

            if (type === 'score') {
                titleEl.textContent = "Ti-Age Synthese";
                iconEl.textContent = 'ğŸ“Š';
                categoryEl.textContent = 'KompatibilitÃ¤ts-Analyse';
                subtitleEl.textContent = 'Score â€“ Pro & Contra';
                typeIndicatorEl.style.display = 'flex';
                contentEl.innerHTML = getScoreContent();
                if (scoreBtn) {
                    scoreBtn.style.background = 'rgba(139, 92, 246, 0.3)';
                    scoreBtn.style.color = 'var(--text-primary)';
                    scoreBtn.style.border = '1px solid #8B5CF6';
                }
                if (modalScoreBtn) modalScoreBtn.classList.add('active');
            } else if (type === 'oshozen') {
                titleEl.textContent = "Ti-Age Synthese";
                iconEl.textContent = 'ğŸ”¥';
                categoryEl.textContent = 'Osho Zen Tarot';
                subtitleEl.textContent = 'Gemeinsame BedÃ¼rfnisse';
                typeIndicatorEl.style.display = 'flex';
                contentEl.innerHTML = getOshoZenContent();
                if (oshoZenBtn) {
                    oshoZenBtn.style.background = 'rgba(236, 72, 153, 0.3)';
                    oshoZenBtn.style.color = 'var(--text-primary)';
                    oshoZenBtn.style.border = '1px solid #EC4899';
                }
                if (modalOshoZenBtn) modalOshoZenBtn.classList.add('active');
            } else if (type === 'pathos' || type === 'logos') {
                // Legacy support - redirect to oshozen
                showTiageSyntheseContent('oshozen');
                return;
            } else if (type === 'needs') {
                titleEl.textContent = "Ti-Age Synthese";
                iconEl.textContent = 'ğŸ’š';
                categoryEl.textContent = 'GFK-BedÃ¼rfnisanalyse';
                subtitleEl.textContent = 'BedÃ¼rfnis-Match mit Differenz';
                typeIndicatorEl.style.display = 'flex';
                contentEl.innerHTML = getNeedsContent();
                if (needsBtn) {
                    needsBtn.style.background = 'rgba(34, 197, 94, 0.3)';
                    needsBtn.style.color = 'var(--text-primary)';
                    needsBtn.style.border = '1px solid #22c55e';
                }
                if (modalNeedsBtn) modalNeedsBtn.classList.add('active');
            }
        }

        // Legacy alias
        function showPathosLogosContent(type) {
            showTiageSyntheseContent(type);
        }

        /**
         * Generate Score content (formerly Pro & Contra)
         */
        function getScoreContent() {
            // Get current score
            const percentage = document.getElementById('resultPercentage');
            const currentScore = percentage ? percentage.textContent : '0%';
            const scoreValue = parseInt(currentScore) || 0;

            // Set color based on score
            let scoreColor = 'var(--danger)';
            if (scoreValue >= 80) {
                scoreColor = 'var(--success)';
            } else if (scoreValue >= 65) {
                scoreColor = 'var(--primary)';
            } else if (scoreValue >= 50) {
                scoreColor = 'var(--warning)';
            }

            // Generate Pro/Contra
            const dynamicProContra = generateDynamicProContra(
                currentArchetype,
                selectedPartner,
                personDimensions.ich,
                personDimensions.partner
            );

            let proListHtml = '';
            if (dynamicProContra.pro && dynamicProContra.pro.length > 0) {
                proListHtml = dynamicProContra.pro.slice(0, 5).map(s => `<li style="margin-bottom: 8px; padding-left: 8px; border-left: 2px solid var(--success);">${s}</li>`).join('');
            } else {
                proListHtml = '<li style="color: var(--text-muted);">Keine Daten verfÃ¼gbar</li>';
            }

            let contraListHtml = '';
            if (dynamicProContra.contra && dynamicProContra.contra.length > 0) {
                contraListHtml = dynamicProContra.contra.slice(0, 5).map(c => `<li style="margin-bottom: 8px; padding-left: 8px; border-left: 2px solid var(--danger);">${c}</li>`).join('');
            } else {
                contraListHtml = '<li style="color: var(--text-muted);">Keine Daten verfÃ¼gbar</li>';
            }

            // Use overall needs matching score (all 224 needs) instead of matrix fallback
            let baseArchetypeScore = null;
            let scoreLabel = 'Theoretischer Wert';

            // Try to get actual needs matching score
            const matching = lastGfkMatchingResult;
            if (matching && matching.score !== undefined) {
                baseArchetypeScore = matching.score;
                scoreLabel = 'BedÃ¼rfnis-Ãœbereinstimmung';
            }

            // Fallback: Matrix-Score if needs not available
            if (baseArchetypeScore === null) {
                baseArchetypeScore = getArchetypeScore(currentArchetype, selectedPartner);
                scoreLabel = 'Theoretischer Wert';
            }

            return `
                <!-- Score Display -->
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 3rem; font-weight: 700; color: ${scoreColor};">${currentScore}</div>
                    <div style="margin-top: 12px; padding: 12px; background: rgba(100,100,110,0.15); border-radius: 8px; font-size: 13px; color: var(--text-muted);">
                        <div style="display: flex; justify-content: center; align-items: center; gap: 20px; flex-wrap: wrap;">
                            <div>
                                <span style="font-weight: 600; color: var(--text-secondary);">Basis-Archetyp:</span>
                                <span style="margin-left: 6px; font-weight: 700; color: var(--primary);">${baseArchetypeScore}%</span>
                                <span style="margin-left: 4px; font-size: 11px;">(${scoreLabel})</span>
                            </div>
                            <div style="color: var(--border);">â†’</div>
                            <div>
                                <span style="font-weight: 600; color: var(--text-secondary);">Gesamt-Score:</span>
                                <span style="margin-left: 6px; font-weight: 700; color: ${scoreColor};">${scoreValue}%</span>
                                <span style="margin-left: 4px; font-size: 11px;">(mit Modifikatoren)</span>
                            </div>
                        </div>
                        <div style="margin-top: 8px; font-size: 11px; text-align: center; opacity: 0.8;">
                            ${scoreValue > baseArchetypeScore ?
                                `Modifikatoren erhÃ¶hen den Score um +${scoreValue - baseArchetypeScore} Prozentpunkte` :
                                scoreValue < baseArchetypeScore ?
                                `Modifikatoren senken den Score um ${baseArchetypeScore - scoreValue} Prozentpunkte` :
                                'Keine Modifikatoren aktiv'}
                        </div>
                    </div>
                </div>
                <!-- Pro/Contra Lists -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                    <div>
                        <h4 style="color: var(--success); margin-bottom: 12px; font-size: 14px;">âœ“ Was funktioniert</h4>
                        <ul style="list-style: none; padding: 0; margin: 0;">${proListHtml}</ul>
                    </div>
                    <div>
                        <h4 style="color: var(--danger); margin-bottom: 12px; font-size: 14px;">âœ— Herausforderungen</h4>
                        <ul style="list-style: none; padding: 0; margin: 0;">${contraListHtml}</ul>
                    </div>
                </div>
            `;
        }

        /**
         * Generate Needs Matching content for Score view
         */
        function getScoreNeedsContent() {
            // Use cached matching result (same as displayed on main page)
            const matching = lastGfkMatchingResult;
            if (!matching || matching.score === undefined) {
                return '';
            }

            // Score-Farbe basierend auf Level
            const scoreColor = matching.level === 'hoch' ? '#22c55e' :
                              matching.level === 'mittel' ? '#eab308' : '#ef4444';

            // VollstÃ¤ndige Daten holen - entweder aus dynamischer Berechnung oder aus GfkBeduerfnisse.details
            let gemeinsam = matching.alleGemeinsam || [];
            let unterschiedlich = matching.alleUnterschiedlich || [];
            let isFallback = false;

            // Fallback: Wenn keine vollstÃ¤ndigen Daten, aus TiageState holen
            if (gemeinsam.length === 0 && unterschiedlich.length === 0) {
                const ichArchetyp = currentArchetype || '';
                const partnerArchetyp = selectedPartner || '';

                // NEU: Direkt aus TiageState.flatNeeds lesen
                // PrimÃ¤r: Direkt aus TiageState.flatNeeds
                const result = calculateNeedsMatchFromFlatNeeds();
                if (result) {
                    // Format-Konvertierung: need â†’ { label, id, wert1, wert2, stringKey }
                    const formatNeed = (item) => {
                        const stringKey = item.need.startsWith('#B') && typeof BeduerfnisIds !== 'undefined' && BeduerfnisIds.toKey
                            ? BeduerfnisIds.toKey(item.need)
                            : item.need;
                        return {
                            label: formatBeduerfnisLabel(item.need),
                            id: item.need,
                            key: item.need,
                            stringKey: stringKey,
                            wert1: item.wert1,
                            wert2: item.wert2,
                            diff: Math.abs(item.wert1 - item.wert2)
                        };
                    };

                    const uebereinstimmend = result.gemeinsam.map(formatNeed);
                    const komplementaer = result.komplementaer.map(formatNeed);
                    gemeinsam = [...uebereinstimmend, ...komplementaer].sort((a, b) =>
                        ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2)
                    );
                    unterschiedlich = result.unterschiedlich.map(formatNeed);
                    console.log('[getScoreNeedsContent] âœ“ Verwende individualisierte Werte aus TiageState.flatNeeds');
                }

                // Fallback: Alte Methode (nur Archetyp - falls flatNeeds leer)
                if (gemeinsam.length === 0 && typeof GfkBeduerfnisse !== 'undefined') {
                    isFallback = true;
                    const fullMatching = GfkBeduerfnisse.berechneMatching(ichArchetyp, partnerArchetyp);
                    if (fullMatching && fullMatching.details) {
                        const uebereinstimmend = (fullMatching.details.uebereinstimmend || []).map(b => ({
                            label: b.label,
                            id: b.id,
                            key: b.key,
                            stringKey: b.stringKey,
                            wert1: b.wert1,
                            wert2: b.wert2,
                            diff: b.diff
                        }));
                        const komplementaer = (fullMatching.details.komplementaer || []).map(b => ({
                            label: b.label,
                            id: b.id,
                            key: b.key,
                            stringKey: b.stringKey,
                            wert1: b.wert1,
                            wert2: b.wert2,
                            diff: b.diff
                        }));
                        gemeinsam = [...uebereinstimmend, ...komplementaer].sort((a, b) =>
                            ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2)
                        );
                        unterschiedlich = (fullMatching.details.konflikt || []).map(b => ({
                            label: b.label,
                            id: b.id,
                            key: b.key,
                            stringKey: b.stringKey,
                            wert1: b.wert1,
                            wert2: b.wert2
                        }));
                        console.log('[getScoreNeedsContent] âš  Fallback: Verwende Archetyp-basierte BedÃ¼rfniswerte');
                    }
                }
            }

            // Weitere Fallback: Top-Listen verwenden
            if (gemeinsam.length === 0) gemeinsam = matching.topGemeinsam || [];
            if (unterschiedlich.length === 0) unterschiedlich = matching.topUnterschiedlich || [];

            // Tag-Style - clickable with hover effect
            const tagBaseStyle = `display: inline-block; padding: 4px 10px; margin: 3px; border-radius: 12px; font-size: 12px; font-weight: 500; cursor: pointer; transition: transform 0.15s, box-shadow 0.15s;`;
            const greenTagStyle = `${tagBaseStyle} background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.4); color: #22c55e;`;
            const redTagStyle = `${tagBaseStyle} background: rgba(239,68,68,0.15); border: 1px solid rgba(239,68,68,0.4); color: #ef4444;`;

            // Gemeinsame BedÃ¼rfnisse Tags (max 8) - clickable
            // b.id ist jetzt #B-ID (z.B. "#B34"), b.key ist numerisch (34), b.label ist Display-Name
            const gemeinsamTags = gemeinsam.slice(0, 8).map(b => {
                const bidDisplay = b.id && b.id.startsWith('#B') ? `<span style="opacity: 0.6; font-size: 0.85em; margin-right: 4px;">${b.id}</span>` : '';
                return `<span style="${greenTagStyle}" onclick="openNeedWithResonance('${b.id}')" title="Klicken fÃ¼r Definition" onmouseover="this.style.transform='translateY(-1px)';this.style.boxShadow='0 2px 8px rgba(34,197,94,0.3)'" onmouseout="this.style.transform='';this.style.boxShadow=''">${bidDisplay}${b.label}</span>`;
            }).join('');

            // Unterschiedliche BedÃ¼rfnisse Tags (max 5) - clickable
            const unterschiedlichTags = unterschiedlich.slice(0, 5).map(b => {
                const bidDisplay = b.id && b.id.startsWith('#B') ? `<span style="opacity: 0.6; font-size: 0.85em; margin-right: 4px;">${b.id}</span>` : '';
                return `<span style="${redTagStyle}" onclick="openNeedWithResonance('${b.id}')" title="Klicken fÃ¼r Definition" onmouseover="this.style.transform='translateY(-1px)';this.style.boxShadow='0 2px 8px rgba(239,68,68,0.3)'" onmouseout="this.style.transform='';this.style.boxShadow=''">${bidDisplay}${b.label}</span>`;
            }).join('');

            return `
                <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid var(--border);">
                    ${isFallback ? `
                        <div style="
                            background: rgba(234, 179, 8, 0.1);
                            border: 1px solid rgba(234, 179, 8, 0.3);
                            border-radius: 6px;
                            padding: 8px 12px;
                            margin-bottom: 16px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        ">
                            <span style="font-size: 14px;">â„¹ï¸</span>
                            <div style="flex: 1;">
                                <div style="font-size: 11px; font-weight: 600; color: #eab308; margin-bottom: 2px;">Archetyp-Basis-Werte</div>
                                <div style="font-size: 10px; color: var(--text-muted); line-height: 1.4;">
                                    Individualisierte Werte nicht verfÃ¼gbar. Es werden Standard-Archetyp-Werte angezeigt.
                                </div>
                            </div>
                        </div>
                    ` : ''}
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 15px;">
                        <span style="font-size: 16px;">ğŸ¤</span>
                        <span style="font-size: 13px; color: var(--text-muted);">BedÃ¼rfnis-Ãœbereinstimmung:</span>
                        <span style="font-size: 18px; font-weight: 700; color: ${scoreColor};">${matching.score}%</span>
                    </div>
                    ${gemeinsamTags ? `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 11px; color: var(--success); font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Gemeinsame BedÃ¼rfnisse</div>
                            <div>${gemeinsamTags}</div>
                        </div>
                    ` : ''}
                    ${unterschiedlichTags ? `
                        <div>
                            <div style="font-size: 11px; color: var(--danger); font-weight: 600; margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.5px;">Herausfordernde Unterschiede</div>
                            <div>${unterschiedlichTags}</div>
                        </div>
                    ` : ''}
                </div>
            `;
        }

        /**
         * Generiert HTML fÃ¼r GFK-BedÃ¼rfnis-Tags im Pathos/Logos Modal
         * VEREINHEITLICHT: Nutzt berechneMatching (diff <= 15) statt analysiereWerBringtWasMit
         * @param {string} type - 'pathos' oder 'logos'
         * @returns {Object} HTML-Strings fÃ¼r gemeinsamSection, dynamikSection
         */
        function getGfkBeduerfnisAnalyse(type) {
            const result = {
                ichTags: '',
                partnerTags: '',
                gemeinsamSection: '',
                wachstumSection: '',
                dynamikSection: ''
            };

            // SchlÃ¼ssel unverÃ¤ndert verwenden (duo_flex bleibt duo_flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';

            if (!ichArchetyp || !partnerArchetyp) return result;

            // NEU: Direkt aus TiageState.flatNeeds lesen
            let matching = null;
            let isFallback = false;

            // PrimÃ¤r: Direkt aus TiageState.flatNeeds
            const matchResult = calculateNeedsMatchFromFlatNeeds();
            if (matchResult) {
                // Format-Konvertierung: need â†’ { label, id, wert1, wert2, stringKey }
                const formatNeed = (item) => {
                    const stringKey = item.need.startsWith('#B') && typeof BeduerfnisIds !== 'undefined' && BeduerfnisIds.toKey
                        ? BeduerfnisIds.toKey(item.need)
                        : item.need;
                    return {
                        label: formatBeduerfnisLabel(item.need),
                        id: item.need,
                        stringKey: stringKey,
                        wert1: item.wert1,
                        wert2: item.wert2,
                        diff: Math.abs(item.wert1 - item.wert2)
                    };
                };

                // Top 10 Ãœbereinstimmungen (gemeinsam + komplementÃ¤r)
                const allGemeinsam = [...matchResult.gemeinsam, ...matchResult.komplementaer].map(formatNeed);
                allGemeinsam.sort((a, b) => ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2));

                matching = {
                    topUebereinstimmungen: allGemeinsam.slice(0, 10)
                };
                console.log('[getGfkBeduerfnisAnalyse] âœ“ Verwende individualisierte Werte aus TiageState.flatNeeds');
            }

            // Fallback: Alte Methode (nur Archetyp - falls flatNeeds leer)
            if (!matching && typeof GfkBeduerfnisse !== 'undefined') {
                matching = GfkBeduerfnisse.berechneMatching(ichArchetyp, partnerArchetyp);
                isFallback = true;
                console.log('[getGfkBeduerfnisAnalyse] âš  Fallback: Verwende Archetyp-basierte BedÃ¼rfniswerte');
            }

            if (!matching || matching.fehler) return result;

            // Tag-Style
            const tagStyle = `display: inline-block; padding: 3px 8px; margin: 2px; border-radius: 10px; font-size: 11px; font-weight: 500;`;
            const tagStyleMatch = `${tagStyle} background: rgba(34,197,94,0.15); border: 1px solid rgba(34,197,94,0.5); color: #22c55e;`;

            // Gemeinsame BedÃ¼rfnisse Section - gefiltert nach pathos/logos
            const gemeinsam = (matching.topUebereinstimmungen || []).filter(b => {
                // b.stringKey fÃ¼r getPathosLogos verwenden (braucht string-key fÃ¼r definitionen-Lookup)
                const pl = GfkBeduerfnisse.getPathosLogos ? GfkBeduerfnisse.getPathosLogos(b.stringKey || b.id) : null;
                return !pl || pl === type; // Wenn keine Zuordnung, zeige in beiden
            });

            // HIDDEN: Direct needs comparison hidden per user request
            /*
            if (gemeinsam.length > 0) {
                const tags = gemeinsam.slice(0, 5).map(b => {
                    // b.label ist bereits der Display-Name
                    return `<span style="${tagStyleMatch}">${b.label}</span>`;
                }).join('');
                const sectionTitle = type === 'pathos'
                    ? TiageI18n.t('needs.sharedTitle', 'GEMEINSAME & KOMPATIBLE BEDÃœRFNISSE')
                    : TiageI18n.t('needs.valuesTitle', 'GEMEINSAME & KOMPATIBLE WERTE');

                // Fallback Banner
                let fallbackBanner = '';
                if (isFallback) {
                    fallbackBanner = `
                        <div style="
                            background: rgba(234, 179, 8, 0.1);
                            border: 1px solid rgba(234, 179, 8, 0.3);
                            border-radius: 6px;
                            padding: 8px 12px;
                            margin-bottom: 16px;
                            display: flex;
                            align-items: center;
                            gap: 8px;
                        ">
                            <span style="font-size: 14px;">â„¹ï¸</span>
                            <div style="flex: 1;">
                                <div style="font-size: 11px; font-weight: 600; color: #eab308; margin-bottom: 2px;">Archetyp-Basis-Werte</div>
                                <div style="font-size: 10px; color: var(--text-muted); line-height: 1.4;">
                                    Individualisierte Werte nicht verfÃ¼gbar. Es werden Standard-Archetyp-Werte angezeigt.
                                </div>
                            </div>
                        </div>
                    `;
                }

                result.gemeinsamSection = fallbackBanner + `
                <div style="margin-bottom: 16px;">
                    <div style="padding: 12px; background: rgba(34,197,94,0.08); border-radius: 10px; border: 1px solid rgba(34,197,94,0.25);">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                            <span style="font-size: 14px;">ğŸ¤</span>
                            <span style="font-size: 11px; color: #22c55e; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;">${sectionTitle}</span>
                        </div>
                        <div>${tags}</div>
                    </div>
                </div>`;
            }
            */

            // Dynamik + Wachstum als kombinierter FlieÃŸtext
            // Dynamik: Aus gemeinsam mit Kategorie 'dynamik'
            const dynamikNeeds = (matching.details?.uebereinstimmend || []).filter(b => {
                // b.stringKey fÃ¼r definitionen-Lookup verwenden
                const def = GfkBeduerfnisse.definitionen?.[b.stringKey || b.id];
                return def?.kategorie === 'dynamik';
            });

            // Wachstum: Aus Konflikten (einer stark, anderer schwach)
            const wachstum = (matching.topKonflikte || []).slice(0, 3);

            if (dynamikNeeds.length > 0 || wachstum.length > 0) {
                const dynamikNames = dynamikNeeds.slice(0, 2).map(b => {
                    // b.label ist bereits der Display-Name
                    return `<span style="color: #8B5CF6; font-weight: 500;">${b.label}</span>`;
                });

                const wachstumNames = wachstum.slice(0, 2).map(b => {
                    // b.label ist bereits der Display-Name
                    return `<span style="color: #a855f7; font-weight: 500;">${b.label}</span>`;
                });

                let sentence = '';
                if (dynamikNames.length > 0 && wachstumNames.length > 0) {
                    const dynamikPart = dynamikNames.length > 1 ? `${dynamikNames[0]} und ${dynamikNames[1]}` : dynamikNames[0];
                    const wachstumPart = wachstumNames.length > 1 ? `${wachstumNames[0]} und ${wachstumNames[1]}` : wachstumNames[0];
                    sentence = `Eure Dynamik lebt von ${dynamikPart} â€“ hier liegt Wachstumspotential in ${wachstumPart}.`;
                } else if (dynamikNames.length > 0) {
                    const dynamikPart = dynamikNames.length > 1 ? `${dynamikNames[0]} und ${dynamikNames[1]}` : dynamikNames[0];
                    sentence = `Eure Dynamik entfaltet sich durch ${dynamikPart}.`;
                } else if (wachstumNames.length > 0) {
                    const wachstumPart = wachstumNames.length > 1 ? `${wachstumNames[0]} und ${wachstumNames[1]}` : wachstumNames[0];
                    sentence = `Wachstumspotential zeigt sich in ${wachstumPart}.`;
                }

                if (sentence) {
                    result.dynamikSection = `<p style="margin-top: 12px; font-size: 13px; line-height: 1.6; color: var(--text-secondary);">${sentence}</p>`;
                }
            }

            return result;
        }

        /**
         * Generiert das Jung+GFK kombinierte Statement fÃ¼r die psychologische Einordnung
         * C.G. Jung: Logos â†’ "Denken", Pathos â†’ "FÃ¼hlen"
         * GFK (Rosenberg): Logos â†’ Klarheit, Ordnung, Kompetenz; Pathos â†’ Harmonie, Empathie, Verbundenheit
         */
        function generateJungGfkStatement() {
            // PrÃ¼fen ob GfkBeduerfnisse verfÃ¼gbar ist
            if (typeof GfkBeduerfnisse === 'undefined') {
                return '';
            }

            // SchlÃ¼ssel unverÃ¤ndert verwenden (duo_flex bleibt duo_flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';
            const ichArch = archetypeDescriptions[currentArchetype];
            const partnerArch = archetypeDescriptions[selectedPartner];
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';

            if (!ichArchetyp || !partnerArchetyp) return '';

            // Pathos/Logos Scores berechnen
            const scores = GfkBeduerfnisse.berechnePathosLogosScores(ichArchetyp, partnerArchetyp);
            const pathosScore = scores.pathos || 50;
            const logosScore = scores.logos || 50;

            // Jung-Funktion ableiten (wer tendiert wohin?)
            // Person A: Vergleiche individuelle StÃ¤rken
            const analyseA = GfkBeduerfnisse.analysiereWerBringtWasMit(ichArchetyp, ichArchetyp);
            const analyseB = GfkBeduerfnisse.analysiereWerBringtWasMit(partnerArchetyp, partnerArchetyp);

            // Logos-StÃ¤rke = Anzahl starker Logos-BedÃ¼rfnisse
            const ichLogosStaerke = (analyseA.ich?.staerken?.logos?.length || 0);
            const ichPathosStaerke = (analyseA.ich?.staerken?.pathos?.length || 0);
            const partnerLogosStaerke = (analyseB.ich?.staerken?.logos?.length || 0);
            const partnerPathosStaerke = (analyseB.ich?.staerken?.pathos?.length || 0);

            // Jung-Funktion bestimmen
            const jungFunktionA = ichLogosStaerke >= ichPathosStaerke ? 'Denken' : 'FÃ¼hlen';
            const jungFunktionB = partnerLogosStaerke >= partnerPathosStaerke ? 'Denken' : 'FÃ¼hlen';

            // GFK-BedÃ¼rfnisse sammeln
            const gfkAnalyse = GfkBeduerfnisse.analysiereWerBringtWasMit(ichArchetyp, partnerArchetyp);
            if (gfkAnalyse.fehler) return '';

            // Top-BedÃ¼rfnisse fÃ¼r die Liste (kombiniert Pathos + Logos)
            const gemeinsamPathos = (gfkAnalyse.gemeinsam?.pathos || []).slice(0, 2);
            const gemeinsamLogos = (gfkAnalyse.gemeinsam?.logos || []).slice(0, 2);
            const allGemeinsam = [...gemeinsamPathos, ...gemeinsamLogos];
            const beduerfnisListe = allGemeinsam.map(b => b.label).join(', ') || 'WertschÃ¤tzung, Vertrauen';

            // Jung-Dynamik-Text generieren
            let jungDynamikText = '';
            if (jungFunktionA === jungFunktionB) {
                if (jungFunktionA === 'Denken') {
                    jungDynamikText = 'Beide operieren primÃ¤r aus der rationalen Funktion â€“ eine analytische Partnerschaft mit klarem Fokus auf Struktur und Werte.';
                } else {
                    jungDynamikText = 'Beide operieren primÃ¤r aus der GefÃ¼hlsfunktion â€“ eine empathische Verbindung mit starkem emotionalem Fundament.';
                }
            } else {
                jungDynamikText = 'Diese komplementÃ¤re Konstellation vereint Ratio und Emotion â€“ eine fruchtbare Spannung, die beide Seiten bereichern kann.';
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RESONANZFAKTOREN aus State lesen (werden bei Archetyp-Wechsel berechnet)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let resonanzWerte = { R1: 1.0, R2: 1.0, R3: 1.0, R4: 1.0 };

            // Aus LoadedArchetypProfile.ich.resonanzFaktoren lesen
            const loadedIch = window.LoadedArchetypProfile?.ich?.resonanzFaktoren;
            if (loadedIch) {
                resonanzWerte = {
                    R1: loadedIch.R1?.value ?? loadedIch.R1 ?? 1.0,
                    R2: loadedIch.R2?.value ?? loadedIch.R2 ?? 1.0,
                    R3: loadedIch.R3?.value ?? loadedIch.R3 ?? 1.0,
                    R4: loadedIch.R4?.value ?? loadedIch.R4 ?? 1.0
                };
            }
            // Fallback: Aus ResonanzCard
            else if (typeof ResonanzCard !== 'undefined') {
                const cardValues = ResonanzCard.getValues('ich');
                resonanzWerte = {
                    R1: cardValues.R1 || 1.0,
                    R2: cardValues.R2 || 1.0,
                    R3: cardValues.R3 || 1.0,
                    R4: cardValues.R4 || 1.0
                };
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FAKTOR-PERSPEKTIVEN-GEWICHTUNGSMATRIX
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Definiert wie stark jeder Resonanzfaktor (R1-R4) jede Perspektive
            // (P1-P4) beeinflusst. Die Gewichte pro Faktor summieren sich zu 1.0.
            //
            // Theoretische BegrÃ¼ndung:
            //
            // R1 ORIENTIERUNG (Anziehung/SexualitÃ¤t)
            //   â†’ GFK (40%):  Rosenbergs GrundbedÃ¼rfnisse umfassen IntimitÃ¤t,
            //                 kÃ¶rperliche NÃ¤he - Orientierung ist fundamental
            //   â†’ Osho (30%): Tantra, sexuelle Energie, PolaritÃ¤t sind zentral
            //   â†’ Pirsig (15%): QualitÃ¤tsphilosophie fokussiert nicht auf SexualitÃ¤t
            //   â†’ Kink (15%):  Kink fokussiert auf Dynamik, nicht Orientierung
            //
            // R2 ARCHETYP (Beziehungsphilosophie)
            //   â†’ GFK (25%):  BedÃ¼rfnisse variieren leicht nach Beziehungsform
            //   â†’ Osho (15%): Nicht-Anhaften, aber kein Fokus auf Struktur
            //   â†’ Pirsig (45%): "Wie" einer Beziehung = QualitÃ¤t = Pirsigs Kern
            //   â†’ Kink (15%):  Kink ist dynamik-, nicht strukturbezogen
            //
            // R3 DOMINANZ (Machtdynamik)
            //   â†’ GFK (10%):  GFK behandelt Macht nicht explizit
            //   â†’ Osho (25%): PolaritÃ¤t, maskulin/feminin, Energie-Austausch
            //   â†’ Pirsig (15%): QualitÃ¤t unabhÃ¤ngig von Machtverteilung
            //   â†’ Kink (50%):  BDSM = konsensueller Machtaustausch per Definition
            //
            // R4 GESCHLECHT (IdentitÃ¤t)
            //   â†’ Alle (25%): GeschlechtsidentitÃ¤t ist querschnittlich relevant,
            //                 beeinflusst alle Perspektiven gleichermaÃŸen
            //
            // Dokumentation: docs/theory/faktor-perspektiven-matrix.md
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const gewichtMatrix = {
                R1: { P1: 0.40, P2: 0.30, P3: 0.15, P4: 0.15 },  // Orientierung
                R2: { P1: 0.25, P2: 0.15, P3: 0.45, P4: 0.15 },  // Archetyp
                R3: { P1: 0.10, P2: 0.25, P3: 0.15, P4: 0.50 },  // Dominanz
                R4: { P1: 0.25, P2: 0.25, P3: 0.25, P4: 0.25 }   // Geschlecht
            };

            // Perspektiven-Konfiguration
            const perspektiven = {
                P1: { icon: 'ğŸ“Š', label: 'Statistik', color: '#3B82F6', description: 'Empirisch nachgewiesene GrundbedÃ¼rfnisse' },
                P2: { icon: 'ğŸŒ±', label: 'Konditionierung', color: '#F59E0B', description: 'NatÃ¼rliche vs. anerzogene BedÃ¼rfnisse' },
                P3: { icon: 'âš–ï¸', label: 'QualitÃ¤t', color: '#10B981', description: 'Statische vs. dynamische QualitÃ¤tsaspekte' },
                P4: { icon: 'ğŸ’œ', label: 'SexPositiv', color: '#8B5CF6', description: 'Bewusste Machtdynamik und Consent' }
            };

            // Resonanzfaktor-Konfiguration
            const faktoren = {
                R1: { label: 'Orientierung', color: '#E63946' },
                R2: { label: 'Archetyp', color: '#2A9D8F' },
                R3: { label: 'Dominanz', color: '#8B5CF6' },
                R4: { label: 'Geschlecht', color: '#F4A261' }
            };

            // Berechne effektiven Einfluss: (R-Wert - 1.0) * Gewicht * 100 = Prozentuale Ã„nderung
            function berechneEinfluss(rWert, gewicht) {
                const abweichung = rWert - 1.0; // -0.5 bis +0.5
                const einfluss = abweichung * gewicht * 100; // Prozentuale Ã„nderung
                return einfluss;
            }

            // Einfluss-Anzeige mit Farbcodierung
            function getEinflussDisplay(einfluss, perspColor) {
                let color = 'var(--text-muted)'; // neutral
                let prefix = '';
                if (einfluss > 0.5) {
                    color = '#22c55e'; // positiv
                    prefix = '+';
                } else if (einfluss < -0.5) {
                    color = '#ef4444'; // negativ
                }
                const displayVal = einfluss.toFixed(1);
                return `<span style="color: ${color}; font-weight: 500; font-size: 11px;">${prefix}${displayVal}%</span>`;
            }

            // Wert-Anzeige mit Farbcodierung
            function getWertDisplay(wert) {
                let color = '#eab308'; // neutral
                if (wert >= 1.1) color = '#22c55e'; // verstÃ¤rkend
                else if (wert <= 0.9) color = '#ef4444'; // abschwÃ¤chend
                return `<span style="color: ${color}; font-weight: 600;">${wert.toFixed(2)}</span>`;
            }

            // Tabellen-Zeilen fÃ¼r jeden Resonanzfaktor
            let tableRows = '';
            const perspektivenSummen = { P1: 0, P2: 0, P3: 0, P4: 0 };

            ['R1', 'R2', 'R3', 'R4'].forEach(rf => {
                const faktor = faktoren[rf];
                const wert = resonanzWerte[rf] || 1.0;
                const gewichte = gewichtMatrix[rf];

                const einflussP1 = berechneEinfluss(wert, gewichte.P1);
                const einflussP2 = berechneEinfluss(wert, gewichte.P2);
                const einflussP3 = berechneEinfluss(wert, gewichte.P3);
                const einflussP4 = berechneEinfluss(wert, gewichte.P4);

                perspektivenSummen.P1 += einflussP1;
                perspektivenSummen.P2 += einflussP2;
                perspektivenSummen.P3 += einflussP3;
                perspektivenSummen.P4 += einflussP4;

                tableRows += `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <td style="padding: 8px 10px; font-size: 11px;">
                            <span style="color: ${faktor.color}; font-weight: 600;">${rf}</span>
                            <span style="color: var(--text-secondary); margin-left: 6px;">${faktor.label}</span>
                        </td>
                        <td style="padding: 8px 6px; text-align: center; font-size: 12px;">${getWertDisplay(wert)}</td>
                        <td style="padding: 8px 6px; text-align: center;">${getEinflussDisplay(einflussP1, perspektiven.P1.color)}</td>
                        <td style="padding: 8px 6px; text-align: center;">${getEinflussDisplay(einflussP2, perspektiven.P2.color)}</td>
                        <td style="padding: 8px 6px; text-align: center;">${getEinflussDisplay(einflussP3, perspektiven.P3.color)}</td>
                        <td style="padding: 8px 6px; text-align: center;">${getEinflussDisplay(einflussP4, perspektiven.P4.color)}</td>
                    </tr>`;
            });

            // Summen-Zeile
            const summenRow = `
                <tr style="border-top: 2px solid rgba(139,92,246,0.3); background: rgba(139,92,246,0.05);">
                    <td style="padding: 10px 10px; font-size: 11px; font-weight: 600; color: var(--text-primary);" colspan="2">Î£ Gesamt</td>
                    <td style="padding: 10px 6px; text-align: center;">${getEinflussDisplay(perspektivenSummen.P1, perspektiven.P1.color)}</td>
                    <td style="padding: 10px 6px; text-align: center;">${getEinflussDisplay(perspektivenSummen.P2, perspektiven.P2.color)}</td>
                    <td style="padding: 10px 6px; text-align: center;">${getEinflussDisplay(perspektivenSummen.P3, perspektiven.P3.color)}</td>
                    <td style="padding: 10px 6px; text-align: center;">${getEinflussDisplay(perspektivenSummen.P4, perspektiven.P4.color)}</td>
                </tr>`;

            // HTML generieren
            return `
            <div style="margin-top: 20px; padding: 16px; background: linear-gradient(135deg, rgba(139,92,246,0.08), rgba(59,130,246,0.05)); border-radius: 12px; border: 1px solid rgba(139,92,246,0.25);">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 14px;">
                    <span style="font-size: 16px;">ğŸ›ï¸</span>
                    <span style="font-size: 12px; color: #8B5CF6; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;">RESONANZFAKTOREN Ã— PERSPEKTIVEN</span>
                </div>
                <table style="width: 100%; border-collapse: collapse; font-size: 11px;">
                    <thead>
                        <tr style="border-bottom: 2px solid rgba(139,92,246,0.3);">
                            <th style="padding: 8px 10px; text-align: left; color: var(--text-muted); font-weight: 500;">Faktor</th>
                            <th style="padding: 8px 6px; text-align: center; color: var(--text-muted); font-weight: 500;">R</th>
                            <th style="padding: 8px 6px; text-align: center;" title="${perspektiven.P1.description}"><span style="color: ${perspektiven.P1.color}; font-size: 10px;">${perspektiven.P1.icon} ${perspektiven.P1.label}</span></th>
                            <th style="padding: 8px 6px; text-align: center;" title="${perspektiven.P2.description}"><span style="color: ${perspektiven.P2.color}; font-size: 10px;">${perspektiven.P2.icon} ${perspektiven.P2.label}</span></th>
                            <th style="padding: 8px 6px; text-align: center;" title="${perspektiven.P3.description}"><span style="color: ${perspektiven.P3.color}; font-size: 10px;">${perspektiven.P3.icon} ${perspektiven.P3.label}</span></th>
                            <th style="padding: 8px 6px; text-align: center;" title="${perspektiven.P4.description}"><span style="color: ${perspektiven.P4.color}; font-size: 10px;">${perspektiven.P4.icon} ${perspektiven.P4.label}</span></th>
                        </tr>
                    </thead>
                    <tbody>
                        ${tableRows}
                        ${summenRow}
                    </tbody>
                </table>
                <div style="display: flex; gap: 12px; margin-top: 12px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.05); flex-wrap: wrap; align-items: center;">
                    <span style="font-size: 10px; color: var(--text-muted); font-family: monospace;">(Resonanzwert âˆ’ 1) Ã— Gewicht Ã— 100 = %</span>
                    <span style="font-size: 10px; color: var(--text-muted);">R = similarityÂ² (0â€“1)</span>
                    <span style="font-size: 10px; color: #22c55e;">+% verstÃ¤rkt</span>
                    <span style="font-size: 10px; color: #ef4444;">âˆ’% schwÃ¤cht</span>
                </div>
            </div>`;
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // RESONANZFAKTOREN MODAL (Separates Modal mit Archetyp-Wechsel)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // State fÃ¼r Resonanzfaktoren Modal
        let resonanzModalArchetyp = 'ich'; // 'ich' oder 'partner'

        /**
         * Ã–ffnet das separate Resonanzfaktoren Modal
         * @param {string} initialArchetyp - 'ich' oder 'partner'
         */
        function openResonanzfaktorenModal(initialArchetyp = 'ich') {
            resonanzModalArchetyp = initialArchetyp;

            // Modal erstellen falls nicht vorhanden
            let modal = document.getElementById('resonanzfaktorenModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'resonanzfaktorenModal';
                modal.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.8);
                    z-index: 10000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                document.body.appendChild(modal);
            }

            // Modal Content rendern
            updateResonanzfaktorenModalContent();

            // Modal anzeigen
            modal.style.display = 'flex';
            requestAnimationFrame(() => {
                modal.style.opacity = '1';
            });

            // Click auÃŸerhalb schlieÃŸt Modal
            modal.onclick = (e) => {
                if (e.target === modal) {
                    closeResonanzfaktorenModal();
                }
            };

            // ESC-Taste schlieÃŸt Modal
            document.addEventListener('keydown', handleResonanzModalEsc);
        }
        window.openResonanzfaktorenModal = openResonanzfaktorenModal;

        function handleResonanzModalEsc(e) {
            if (e.key === 'Escape') {
                closeResonanzfaktorenModal();
            }
        }

        function closeResonanzfaktorenModal() {
            const modal = document.getElementById('resonanzfaktorenModal');
            if (modal) {
                modal.style.opacity = '0';
                setTimeout(() => {
                    modal.style.display = 'none';
                }, 300);
            }
            document.removeEventListener('keydown', handleResonanzModalEsc);
        }
        window.closeResonanzfaktorenModal = closeResonanzfaktorenModal;

        function switchResonanzArchetyp(archetyp) {
            resonanzModalArchetyp = archetyp;
            updateResonanzfaktorenModalContent();
        }
        window.switchResonanzArchetyp = switchResonanzArchetyp;

        /**
         * Navigiert zum nÃ¤chsten/vorherigen Archetyp im Resonanzfaktoren Modal
         * @param {string} person - 'ich' oder 'partner'
         * @param {number} direction - -1 fÃ¼r zurÃ¼ck, 1 fÃ¼r vor
         */
        function navigateResonanzArchetype(person, direction) {
            const archetypeKeys = Object.keys(archetypeDescriptions);
            const currentKey = person === 'ich' ? currentArchetype : selectedPartner;
            const currentIndex = archetypeKeys.indexOf(currentKey);

            let newIndex = currentIndex + direction;
            if (newIndex < 0) newIndex = archetypeKeys.length - 1;
            if (newIndex >= archetypeKeys.length) newIndex = 0;

            const newArchetype = archetypeKeys[newIndex];
            const personKey = person === 'ich' ? 'ich' : 'partner';

            if (person === 'ich') {
                currentArchetype = newArchetype;
                mobileIchArchetype = newArchetype;

                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('ich', newArchetype);
                }

                // Sync select dropdowns
                const ichSelect = document.getElementById('ichSelect');
                const mobileIchSelect = document.getElementById('mobileIchSelect');
                if (ichSelect) ichSelect.value = newArchetype;
                if (mobileIchSelect) mobileIchSelect.value = newArchetype;

                // Sync archetype grid highlighting
                if (typeof updateArchetypeGrid === 'function') {
                    updateArchetypeGrid('ich', currentArchetype);
                }
            } else {
                selectedPartner = newArchetype;
                mobilePartnerArchetype = newArchetype;

                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('partner', newArchetype);
                }

                // Sync select dropdowns
                const partnerSelect = document.getElementById('partnerSelect');
                const mobilePartnerSelect = document.getElementById('mobilePartnerSelect');
                if (partnerSelect) partnerSelect.value = newArchetype;
                if (mobilePartnerSelect) mobilePartnerSelect.value = newArchetype;

                // Sync archetype grid highlighting
                if (typeof updateArchetypeGrid === 'function') {
                    updateArchetypeGrid('partner', selectedPartner);
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RESONANZFAKTOREN neu berechnen bei Archetyp-Wechsel
            // Verwendet zentrale getPersonNeeds() fÃ¼r konsistente Datenquellen
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                // ZENTRALE HELPER-FUNKTION fÃ¼r korrekte Person-spezifische Needs
                const needs = ResonanzCard.getPersonNeeds
                    ? ResonanzCard.getPersonNeeds(personKey, newArchetype)
                    : null;

                const resonanzProfileContext = {
                    archetyp: newArchetype,
                    needs: needs,
                    dominanz: personDimensions[personKey]?.dominanz || null,
                    orientierung: personDimensions[personKey]?.orientierung || null,
                    geschlecht: personDimensions[personKey]?.geschlecht || null
                };

                // Berechne und aktualisiere Resonanzfaktoren
                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    const resonanzLoaded = ResonanzCard.loadCalculatedValues(resonanzProfileContext, personKey);
                    if (resonanzLoaded) {
                        // NOTE: LoadedArchetypProfile ist ein View auf TiageState.
                        // Nicht separat setzen - save() in setCalculatedValues hat TiageState bereits aktualisiert.
                        // Das wÃ¼rde sonst die Lock-Struktur {value, locked} mit nur Werten Ã¼berschreiben.
                        console.log('[TIAGE] Resonanzfaktoren nach Archetyp-Wechsel (Modal) aktualisiert fÃ¼r', personKey + ':', newArchetype);
                    }
                }
            }

            // Update main displays
            saveSelectionToStorage();
            if (typeof updateComparisonView === 'function') updateComparisonView();
            if (typeof updateMobileCardsContent === 'function') updateMobileCardsContent();

            // Update Resonanzfaktoren Modal
            updateResonanzfaktorenModalContent();
        }
        window.navigateResonanzArchetype = navigateResonanzArchetype;

        /**
         * Zeigt die vollstÃ¤ndige Herleitung eines R-Faktors an
         * @param {string} rKey - 'R1', 'R2', 'R3' oder 'R4'
         * @param {string} person - 'ich' oder 'partner'
         * @param {number} wert - Der angezeigte R-Wert
         */
        function showValueDerivation(rKey, person, wert) {
            // Mapping R-Key zu KohÃ¤renz-Dimension
            const rToDimension = {
                R1: { key: 'leben', name: 'Leben', emoji: 'ğŸ”¥' },
                R2: { key: 'philosophie', name: 'Philosophie', emoji: 'ğŸ§ ' },
                R3: { key: 'dynamik', name: 'Dynamik', emoji: 'âš¡' },
                R4: { key: 'identitaet', name: 'IdentitÃ¤t', emoji: 'ğŸ’š' }
            };

            const dimension = rToDimension[rKey];
            if (!dimension) return;

            // Archetyp bestimmen
            const archetyp = person === 'ich' ? currentArchetype : selectedPartner;
            const archetypName = archetypeDescriptions[archetyp]?.name || archetyp;

            // KohÃ¤renz-Daten laden (fÃ¼r BedÃ¼rfnis-Liste dieser Dimension)
            const kohaerenz = TiageSynthesis?.Constants?.ARCHETYP_KOHAERENZ?.[dimension.key]?.[archetyp];
            if (!kohaerenz) {
                console.warn('[showValueDerivation] Keine KohÃ¤renzdaten fÃ¼r', dimension.key, archetyp);
                return;
            }

            // Archetyp-Profil laden fÃ¼r KORREKTE typische Werte (Single Source of Truth)
            const archetypProfil = GfkBeduerfnisse?.archetypProfile?.[archetyp]?.umfrageWerte || {};

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PROFIL-ATTRIBUTE LADEN fÃ¼r Modifikator-AufschlÃ¼sselung
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            let profilDominanz = null;
            let profilGeschlecht = null;
            let profilOrientierung = null;

            if (typeof TiageState !== 'undefined') {
                profilDominanz = TiageState.getPrimaryDominanz(person);
                profilGeschlecht = TiageState.getPrimaryGeschlecht(person);
                profilOrientierung = TiageState.getPrimaryOrientierung(person);
            }

            // Modifikatoren-Objekte laden
            const modDominanz = (typeof BeduerfnisModifikatoren !== 'undefined' && profilDominanz)
                ? BeduerfnisModifikatoren.dominanz?.[profilDominanz] || {}
                : {};
            const modGeschlecht = (typeof BeduerfnisModifikatoren !== 'undefined' && profilGeschlecht)
                ? BeduerfnisModifikatoren.geschlecht?.[profilGeschlecht] || {}
                : {};
            const modOrientierung = (typeof BeduerfnisModifikatoren !== 'undefined' && profilOrientierung)
                ? BeduerfnisModifikatoren.orientierung?.[profilOrientierung] || {}
                : {};

            // Helper: Modifikator-AufschlÃ¼sselung fÃ¼r ein BedÃ¼rfnis berechnen
            const getModifikatorDetails = (needKey) => {
                const domMod = modDominanz[needKey] || 0;
                const geschMod = modGeschlecht[needKey] || 0;
                const oriMod = modOrientierung[needKey] || 0;
                const total = domMod + geschMod + oriMod;

                return {
                    dominanz: domMod,
                    geschlecht: geschMod,
                    orientierung: oriMod,
                    total: total,
                    hasModifiers: domMod !== 0 || geschMod !== 0 || oriMod !== 0
                };
            };

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // ZENTRALE HELPER-FUNKTION fÃ¼r korrekte Person-spezifische Needs
            // Verwendet ResonanzCard.getPersonNeeds() fÃ¼r konsistente Datenquellen
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const needs = (typeof ResonanzCard !== 'undefined' && ResonanzCard.getPersonNeeds)
                ? ResonanzCard.getPersonNeeds(person, archetyp)
                : null;

            // Lade flatNeeds mit Lock-Status fÃ¼r Anzeige
            const flatNeedsRaw = window.LoadedArchetypProfile?.[person]?.profileReview?.flatNeeds || [];
            const lockedNeedsMap = {};
            if (Array.isArray(flatNeedsRaw)) {
                flatNeedsRaw.forEach(n => {
                    if (n.locked && n.id) {
                        lockedNeedsMap[n.id] = true;
                    }
                    if (n.locked && n.stringKey) {
                        lockedNeedsMap[n.stringKey] = true;
                    }
                });
            }

            // Helper: PrÃ¼ft ob ein BedÃ¼rfnis gesperrt ist
            const isNeedLocked = (needId, stringKey) => {
                return lockedNeedsMap[needId] || lockedNeedsMap[stringKey] || false;
            };

            // Helper: Wert aus needs extrahieren (unterstÃ¼tzt id und stringKey lookup)
            const getNeedValue = (needId, stringKey) => {
                if (!needs) return null;
                // Versuche zuerst id
                if (needId && needs[needId] !== undefined) {
                    const entry = needs[needId];
                    return (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                }
                // Fallback: stringKey
                if (stringKey && needs[stringKey] !== undefined) {
                    const entry = needs[stringKey];
                    return (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                }
                return null;
            };

            // Berechnung durchfÃ¼hren
            let rows = [];
            let totalDiff = 0;
            let totalDiffTypisch = 0;  // Berechnung NUR mit typischen Werten (ohne gesperrte Ãœberschreibungen)
            let count = 0;
            let lockedNeedsCount = 0;

            for (const needKey in kohaerenz) {
                if (!kohaerenz.hasOwnProperty(needKey)) continue;

                const kohaerenzEntry = kohaerenz[needKey];
                const needId = (typeof kohaerenzEntry === 'object' && kohaerenzEntry.id)
                    ? kohaerenzEntry.id
                    : null;
                const needLabel = (typeof kohaerenzEntry === 'object' && kohaerenzEntry.label)
                    ? kohaerenzEntry.label
                    : needKey;

                // Typischer Wert aus Archetyp-Profil (Single Source of Truth)
                // Versuche zuerst Ã¼ber needId (#B34), dann Ã¼ber needKey (selbstbestimmung)
                let typischValue = null;
                if (needId && archetypProfil[needId] !== undefined) {
                    typischValue = archetypProfil[needId];
                } else if (archetypProfil[needKey] !== undefined) {
                    typischValue = archetypProfil[needKey];
                }

                // Verwende id UND stringKey fÃ¼r robustes Lookup (wie in NeedsIntegration._getNeedValue)
                const actualValue = getNeedValue(needId, needKey);

                // PrÃ¼fe ob dieses BedÃ¼rfnis gesperrt ist
                const needIsLocked = isNeedLocked(needId, needKey);
                if (needIsLocked) lockedNeedsCount++;

                if (actualValue !== null && typeof typischValue === 'number') {
                    // Modifikator-Details ZUERST berechnen (fÃ¼r korrekte Abweichung)
                    const modDetails = getModifikatorDetails(needKey);

                    // Modifizierten typischen Wert berechnen: Typ + D + G + O
                    const modifiedTypisch = typischValue +
                        (modDetails.dominanz || 0) +
                        (modDetails.geschlecht || 0) +
                        (modDetails.orientierung || 0);

                    // Abweichung gegen den MODIFIZIERTEN typischen Wert berechnen
                    const diff = Math.abs(actualValue - modifiedTypisch);
                    totalDiff += diff;

                    // FÃ¼r typische Berechnung: Wenn gesperrt, verwende 0 (= typischer Wert)
                    // sonst die normale Abweichung
                    totalDiffTypisch += needIsLocked ? 0 : diff;

                    count++;

                    // Farbcodierung fÃ¼r Abweichung
                    let diffColor = '#22c55e'; // grÃ¼n
                    if (diff > 30) diffColor = '#ef4444'; // rot
                    else if (diff > 15) diffColor = '#eab308'; // gelb

                    rows.push({
                        id: needId || needKey,  // Zeige id oder stringKey
                        label: needLabel,
                        typisch: typischValue,
                        modifiedTypisch: modifiedTypisch,  // NEU: FÃ¼r Anzeige
                        actual: actualValue,
                        diff: diff,
                        diffColor: diffColor,
                        modifiers: modDetails,
                        isLocked: needIsLocked  // NEU: Lock-Status
                    });
                }
            }

            const avgDiff = count > 0 ? totalDiff / count : 0;
            const uebereinstimmung = 1 - (avgDiff / 100);
            const calculatedR = Math.round((0.5 + (uebereinstimmung * 1.0)) * 1000) / 1000;

            // Berechne auch den "typischen" R-Wert (wenn gesperrte BedÃ¼rfnisse auf typische Werte gesetzt wÃ¤ren)
            const avgDiffTypisch = count > 0 ? totalDiffTypisch / count : 0;
            const uebereinstimmungTypisch = 1 - (avgDiffTypisch / 100);
            const calculatedRTypisch = Math.round((0.5 + (uebereinstimmungTypisch * 1.0)) * 1000) / 1000;

            // Lade gespeicherte Werte fÃ¼r Lock-Status Anzeige
            let storedValue = 1.0;
            let isLocked = false;

            // PrÃ¼fe ob der gespeicherte Wert vom berechneten abweicht und aktualisiere ihn
            // Nur wenn nicht gelockt und Differenz > 0.01
            if (typeof ResonanzCard !== 'undefined') {
                const storedData = ResonanzCard.load(person);
                storedValue = storedData[rKey]?.value || 1.0;
                isLocked = storedData[rKey]?.locked || false;
                const diff = Math.abs(storedValue - calculatedR);

                if (!isLocked && diff > 0.01) {
                    console.log(`[showValueDerivation] ${rKey} fÃ¼r ${person}: Gespeichert=${storedValue.toFixed(3)}, Berechnet=${calculatedR.toFixed(3)} - Aktualisiere...`);

                    // Aktualisiere den Wert
                    const newValues = {};
                    newValues[rKey] = calculatedR;
                    ResonanzCard.setCalculatedValues(newValues, false, person);

                    // Aktualisiere auch das Modal im Hintergrund falls offen
                    if (typeof updateResonanzfaktorenModalContent === 'function') {
                        setTimeout(() => updateResonanzfaktorenModalContent(), 100);
                    }
                }
            }

            // Sortiere nach Abweichung (grÃ¶ÃŸte zuerst)
            rows.sort((a, b) => b.diff - a.diff);

            // Sammle alle Modifikatorwerte fÃ¼r die Zusammenfassung
            const modSummary = {
                dominanz: { sum: 0, count: 0 },
                geschlecht: { sum: 0, count: 0 },
                orientierung: { sum: 0, count: 0 }
            };
            rows.forEach(r => {
                if (r.modifiers) {
                    modSummary.dominanz.sum += r.modifiers.dominanz || 0;
                    modSummary.geschlecht.sum += r.modifiers.geschlecht || 0;
                    modSummary.orientierung.sum += r.modifiers.orientierung || 0;
                    modSummary.dominanz.count++;
                    modSummary.geschlecht.count++;
                    modSummary.orientierung.count++;
                }
            });

            // Helper: Modifikator-Summe formatieren
            const formatModSum = (sum) => {
                const sign = sum > 0 ? '+' : '';
                return `${sign}${sum}`;
            };

            // HTML generieren mit Modifikator-Spalten
            const formatModValue = (val) => {
                if (val === 0) return '<span style="color: var(--text-muted); opacity: 0.4;">â€”</span>';
                const sign = val > 0 ? '+' : '';
                return `${sign}${val}`;
            };

            let tableHtml = rows.map(r => {
                const modD = r.modifiers?.dominanz || 0;
                const modG = r.modifiers?.geschlecht || 0;
                const modO = r.modifiers?.orientierung || 0;

                // Wenn nicht gelockt: Zeige modifizierten Wert (Typ + D + G + O)
                // Wenn gelockt: Zeige den tatsÃ¤chlichen (manuell gesetzten) Wert
                const displayValue = r.locked ? r.actual : r.modifiedTypisch;

                // Status-Symbol: ğŸ”’ nur wenn locked
                const statusSymbol = r.locked
                    ? '<span style="color: #f97316; margin-left: 2px;" title="Fixiert - bleibt bei Archetyp-Wechsel erhalten">ğŸ”’</span>'
                    : '';

                // Row background (empty for now, can be used for highlighting)
                const rowBg = '';

                // Lock icon for need ID (show if locked)
                const needLockIcon = '';

                return `
                <tr style="border-bottom: 1px solid rgba(255,255,255,0.06); ${rowBg}">
                    <td style="padding: 6px 8px; font-size: 11px; color: var(--text-secondary);">
                        <span style="color: var(--text-muted); font-size: 9px;">${r.id}${needLockIcon}</span><br>
                        ${r.label}
                    </td>
                    <td style="padding: 6px 4px; text-align: center; font-size: 12px; color: var(--text-muted);">${r.typisch}</td>
                    <td style="padding: 6px 4px; text-align: center; font-size: 12px; color: #a78bfa; font-weight: ${modD !== 0 ? '600' : '400'};">${formatModValue(modD)}</td>
                    <td style="padding: 6px 4px; text-align: center; font-size: 12px; color: #60a5fa; font-weight: ${modG !== 0 ? '600' : '400'};">${formatModValue(modG)}</td>
                    <td style="padding: 6px 4px; text-align: center; font-size: 12px; color: #f472b6; font-weight: ${modO !== 0 ? '600' : '400'};">${formatModValue(modO)}</td>
                    <td style="padding: 6px 4px; text-align: center; font-size: 12px; font-weight: 600;">${displayValue}${statusSymbol}</td>

                </tr>
            `}).join('');

            // Popup erstellen
            let popup = document.getElementById('valueDerivationPopup');
            if (!popup) {
                popup = document.createElement('div');
                popup.id = 'valueDerivationPopup';
                popup.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: rgba(0,0,0,0.85);
                    z-index: 10001;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    opacity: 0;
                    transition: opacity 0.2s ease;
                `;
                document.body.appendChild(popup);
            }

            const personLabel = person === 'ich' ? 'ICH' : 'PARTNER';
            const personColor = person === 'ich' ? 'var(--success)' : 'var(--danger)';

            popup.innerHTML = `
                <div style="background: var(--bg-primary); border-radius: 16px; max-width: 500px; width: 95%; max-height: 85vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.6); border: 1px solid rgba(139,92,246,0.4);">
                    <!-- Header -->
                    <div style="padding: 16px 20px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: space-between; background: linear-gradient(135deg, rgba(139,92,246,0.15), rgba(59,130,246,0.08));">
                        <div>
                            <h3 style="margin: 0; font-size: 16px; color: var(--text-primary);">
                                ${dimension.emoji} ${rKey} Herleitung
                            </h3>
                            <p style="margin: 4px 0 0 0; font-size: 12px; color: var(--text-muted);">
                                <span style="color: ${personColor}; font-weight: 600;">${personLabel}</span> â€¢ ${archetypName}
                            </p>
                        </div>
                        <button onclick="closeValueDerivationPopup()" style="background: rgba(255,255,255,0.1); border: none; border-radius: 8px; width: 32px; height: 32px; cursor: pointer; font-size: 16px; color: var(--text-secondary);">Ã—</button>
                    </div>

                    <!-- Ergebnis -->
                    <div style="padding: 16px 20px; background: rgba(0,0,0,0.2); border-bottom: 1px solid rgba(255,255,255,0.05);">
                        ${lockedNeedsCount > 0 ? `
                        <!-- Zwei Berechnungen: Typisch vs. Mit gesperrten Werten -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                            <!-- Typisch berechnet (wenn alle BedÃ¼rfnisse auf Archetyp-Werten wÃ¤ren) -->
                            <div style="background: rgba(34, 197, 94, 0.1); border: 1px solid rgba(34, 197, 94, 0.3); border-radius: 8px; padding: 10px; text-align: center;">
                                <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">Typisch berechnet</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${calculatedRTypisch >= 1.1 ? '#22c55e' : calculatedRTypisch <= 0.9 ? '#ef4444' : '#eab308'};">${calculatedRTypisch.toFixed(3)}</div>
                                <div style="font-size: 9px; color: var(--text-muted); margin-top: 2px;">ohne ${lockedNeedsCount} gesperrte</div>
                            </div>
                            <!-- Mit gesperrten Werten berechnet -->
                            <div style="background: rgba(245, 158, 11, 0.1); border: 1px solid rgba(245, 158, 11, 0.3); border-radius: 8px; padding: 10px; text-align: center;">
                                <div style="font-size: 10px; color: var(--text-muted); margin-bottom: 4px;">Mit gesperrten Werten</div>
                                <div style="font-size: 18px; font-weight: 700; color: ${calculatedR >= 1.1 ? '#22c55e' : calculatedR <= 0.9 ? '#ef4444' : '#eab308'};">${calculatedR.toFixed(3)}</div>
                                <div style="font-size: 9px; color: var(--text-muted); margin-top: 2px;">inkl. ${lockedNeedsCount} gesperrte</div>
                            </div>
                        </div>
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 12px; padding: 8px; background: rgba(139,92,246,0.08); border-radius: 6px;">
                            <strong>Î”</strong> = ${Math.abs(calculatedRTypisch - calculatedR).toFixed(3)} Differenz durch ${lockedNeedsCount} gesperrte BedÃ¼rfnisse
                        </div>
                        ` : `
                        <!-- Normale Anzeige ohne gesperrte BedÃ¼rfnisse -->
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                            <span style="font-size: 13px; color: var(--text-secondary);">Berechneter Wert:</span>
                            <span style="font-size: 20px; font-weight: 700; color: ${calculatedR >= 1.1 ? '#22c55e' : calculatedR <= 0.9 ? '#ef4444' : '#eab308'};">${calculatedR.toFixed(3)}</span>
                        </div>
                        `}

                        ${isLocked ? `
                        <!-- Locked Status Anzeige fÃ¼r R-Faktor selbst -->
                        <div style="background: linear-gradient(135deg, rgba(245, 158, 11, 0.15), rgba(245, 158, 11, 0.05)); border: 1px solid rgba(245, 158, 11, 0.4); border-radius: 8px; padding: 12px; margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                                <span style="font-size: 16px;">ğŸ”’</span>
                                <span style="font-size: 13px; font-weight: 600; color: #f59e0b;">${rKey} manuell gesperrt</span>
                            </div>
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                <span style="font-size: 12px; color: var(--text-secondary);">Verwendeter Wert:</span>
                                <span style="font-size: 18px; font-weight: 700; color: #f59e0b;">${storedValue.toFixed(2)}</span>
                            </div>
                            <div style="font-size: 11px; color: var(--text-muted); line-height: 1.4;">
                                <strong style="color: #f59e0b;">Konsequenz:</strong> Der berechnete Wert (${calculatedR.toFixed(3)}) wird ignoriert.
                                Stattdessen wird der manuell gesetzte Wert (${storedValue.toFixed(2)}) fÃ¼r alle Score-Berechnungen verwendet.
                            </div>
                            ${(function() {
                                // SSOT: Use centralized help text from help-texts.js
                                if (typeof TiageHelpTexts !== 'undefined') {
                                    const helpInfo = TiageHelpTexts.getRFactorInfluenceExplanation(rKey);
                                    return `
                                    <div style="margin-top: 10px; padding: 10px; background: rgba(139, 92, 246, 0.12); border-left: 3px solid #8B5CF6; border-radius: 4px; font-size: 11px; line-height: 1.5;">
                                        <strong style="color: #a78bfa;">${helpInfo.title}:</strong><br>
                                        ${helpInfo.description}<br>
                                        <span style="color: var(--text-muted); font-size: 10px;">
                                        Formel: ${helpInfo.formula.replace(rKey, '<strong style="color: #f59e0b;">' + rKey + '</strong>')}<br>
                                        ${helpInfo.interpretation.join(', ')}
                                        </span>
                                    </div>`;
                                }
                                // Fallback if help-texts.js not loaded
                                return `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(139, 92, 246, 0.12); border-left: 3px solid #8B5CF6; border-radius: 4px; font-size: 11px; line-height: 1.5;">
                                    <strong style="color: #a78bfa;">Einfluss auf Endscore:</strong><br>
                                    Der ${rKey}-Faktor wird direkt mit dem Score multipliziert.
                                </div>`;
                            })()}
                            <div style="margin-top: 8px; font-size: 10px; color: var(--text-muted); opacity: 0.8;">
                                Ã„ndern: Attribute â†’ Resonanzfaktoren â†’ Schloss-Symbol klicken
                            </div>
                        </div>
                        ` : ''}

                        <!-- Formel -->
                        <div style="background: rgba(139,92,246,0.1); border-radius: 8px; padding: 12px; font-family: monospace; font-size: 11px; color: var(--text-secondary); line-height: 1.8;">
                            <div><strong>Formel:</strong> R = 0.5 + (Ãœbereinstimmung Ã— 1.0)</div>
                            <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                                <div>Summe Abweichungen: <strong>${totalDiff.toFixed(0)}</strong>${lockedNeedsCount > 0 ? ` <span style="color: var(--text-muted);">(${totalDiffTypisch.toFixed(0)} ohne gesperrte)</span>` : ''}</div>
                                <div>Anzahl BedÃ¼rfnisse: <strong>${count}</strong>${lockedNeedsCount > 0 ? ` <span style="color: #f59e0b;">(${lockedNeedsCount} gesperrt)</span>` : ''}</div>
                                <div>Ã˜ Abweichung: <strong>${avgDiff.toFixed(1)}</strong>${lockedNeedsCount > 0 ? ` <span style="color: var(--text-muted);">(${avgDiffTypisch.toFixed(1)} ohne gesperrte)</span>` : ''}</div>
                                <div>Ãœbereinstimmung: <strong>${(uebereinstimmung * 100).toFixed(1)}%</strong></div>
                                <div style="margin-top: 4px;">R = 0.5 + (${uebereinstimmung.toFixed(3)} Ã— 1.0) = <strong>${calculatedR.toFixed(3)}</strong></div>
                            </div>
                        </div>
                    </div>

                    <!-- Modifikator-Farblegende -->
                    ${(profilDominanz || profilGeschlecht || profilOrientierung) ? `
                    <div style="padding: 12px 20px; background: rgba(139,92,246,0.08); border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <div style="font-size: 11px; color: var(--text-muted); margin-bottom: 8px;">
                            <strong>Modifikator-Formel:</strong> Erwartet = Typ + D + G + O &nbsp;â†’&nbsp; |Î”| = |Dein Wert âˆ’ Erwartet|
                        </div>
                        <div style="display: flex; flex-wrap: wrap; gap: 16px; font-size: 11px;">
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="display: inline-block; width: 12px; height: 12px; border-radius: 3px; background: #a78bfa;"></span>
                                <span style="color: var(--text-secondary);">D = Dominanz</span>
                                ${profilDominanz ? `<span style="color: var(--text-muted); font-size: 10px;">(${profilDominanz})</span>` : ''}
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="display: inline-block; width: 12px; height: 12px; border-radius: 3px; background: #60a5fa;"></span>
                                <span style="color: var(--text-secondary);">G = Geschlecht</span>
                                ${profilGeschlecht ? `<span style="color: var(--text-muted); font-size: 10px;">(${profilGeschlecht.replace(/_/g, ' ')})</span>` : ''}
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <span style="display: inline-block; width: 12px; height: 12px; border-radius: 3px; background: #f472b6;"></span>
                                <span style="color: var(--text-secondary);">O = Orientierung</span>
                                ${profilOrientierung ? `<span style="color: var(--text-muted); font-size: 10px;">(${profilOrientierung})</span>` : ''}
                            </div>
                        </div>
                    </div>
                    ` : ''}

                    <!-- BedÃ¼rfnis-Tabelle -->
                    <div style="padding: 16px 20px;">
                        <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 10px;">
                            ${count} BedÃ¼rfnisse verglichen (sortiert nach Abweichung)${rows.some(r => r.actual !== r.modifiedTypisch) ? ' Â· <span style="color: #eab308;">*</span> = Ã¼berschrieben' : ''}${lockedNeedsCount > 0 ? ` Â· <span style="color: #f59e0b;">ğŸ”’</span> = gesperrt (${lockedNeedsCount})` : ''}:
                        </div>
                        <div style="background: rgba(0,0,0,0.15); border-radius: 8px; overflow: hidden; border: 1px solid rgba(255,255,255,0.08);">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: rgba(0,0,0,0.3);">
                                        <th style="padding: 10px; text-align: left; font-size: 11px; color: var(--text-muted); font-weight: 500;">BedÃ¼rfnis</th>
                                        <th style="padding: 10px 4px; text-align: center; font-size: 11px; color: var(--text-muted); font-weight: 500;">Typ.</th>
                                        <th style="padding: 10px 4px; text-align: center; font-size: 11px; color: #a78bfa; font-weight: 500;" title="Dominanz">D</th>
                                        <th style="padding: 10px 4px; text-align: center; font-size: 11px; color: #60a5fa; font-weight: 500;" title="Geschlecht">G</th>
                                        <th style="padding: 10px 4px; text-align: center; font-size: 11px; color: #f472b6; font-weight: 500;" title="Orientierung">O</th>
                                        <th style="padding: 10px 4px; text-align: center; font-size: 11px; color: ${personColor}; font-weight: 500;">${person === 'ich' ? 'Wert' : 'P.Wert'}</th>
                                        <th style="padding: 10px 4px; text-align: center; font-size: 11px; color: var(--text-muted); font-weight: 500;">|Î”|</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tableHtml}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            `;

            popup.style.display = 'flex';
            requestAnimationFrame(() => popup.style.opacity = '1');

            popup.onclick = (e) => {
                if (e.target === popup) closeValueDerivationPopup();
            };
        }
        window.showValueDerivation = showValueDerivation;

        function closeValueDerivationPopup() {
            const popup = document.getElementById('valueDerivationPopup');
            if (popup) {
                popup.style.opacity = '0';
                setTimeout(() => popup.style.display = 'none', 200);
            }
        }
        window.closeValueDerivationPopup = closeValueDerivationPopup;

        function updateResonanzfaktorenModalContent() {
            const modal = document.getElementById('resonanzfaktorenModal');
            if (!modal) return;

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Resonanzwerte fÃ¼r BEIDE Personen laden und kombinieren
            // Kombination via Produkt (wie im synthesisCalculator)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

            // ICH Resonanzwerte laden (inkl. Lock-Status)
            let resonanzIch = { R1: 1.0, R2: 1.0, R3: 1.0, R4: 1.0 };
            let lockStatusIch = { R1: false, R2: false, R3: false, R4: false };

            if (typeof ResonanzCard !== 'undefined') {
                const fullDataIch = ResonanzCard.load('ich');
                resonanzIch = {
                    R1: fullDataIch.R1?.value || 1.0,
                    R2: fullDataIch.R2?.value || 1.0,
                    R3: fullDataIch.R3?.value || 1.0,
                    R4: fullDataIch.R4?.value || 1.0
                };
                lockStatusIch = {
                    R1: fullDataIch.R1?.locked || false,
                    R2: fullDataIch.R2?.locked || false,
                    R3: fullDataIch.R3?.locked || false,
                    R4: fullDataIch.R4?.locked || false
                };
            } else {
                const loadedIch = window.LoadedArchetypProfile?.ich?.resonanzFaktoren;
                if (loadedIch) {
                    resonanzIch = {
                        R1: loadedIch.R1?.value ?? loadedIch.R1 ?? 1.0,
                        R2: loadedIch.R2?.value ?? loadedIch.R2 ?? 1.0,
                        R3: loadedIch.R3?.value ?? loadedIch.R3 ?? 1.0,
                        R4: loadedIch.R4?.value ?? loadedIch.R4 ?? 1.0
                    };
                }
            }

            // PARTNER Resonanzwerte laden (inkl. Lock-Status)
            let resonanzPartner = { R1: 1.0, R2: 1.0, R3: 1.0, R4: 1.0 };
            let lockStatusPartner = { R1: false, R2: false, R3: false, R4: false };

            if (typeof ResonanzCard !== 'undefined') {
                const fullDataPartner = ResonanzCard.load('partner');
                resonanzPartner = {
                    R1: fullDataPartner.R1?.value || 1.0,
                    R2: fullDataPartner.R2?.value || 1.0,
                    R3: fullDataPartner.R3?.value || 1.0,
                    R4: fullDataPartner.R4?.value || 1.0
                };
                lockStatusPartner = {
                    R1: fullDataPartner.R1?.locked || false,
                    R2: fullDataPartner.R2?.locked || false,
                    R3: fullDataPartner.R3?.locked || false,
                    R4: fullDataPartner.R4?.locked || false
                };
            } else {
                const loadedPartner = window.LoadedArchetypProfile?.partner?.resonanzFaktoren;
                if (loadedPartner) {
                    resonanzPartner = {
                        R1: loadedPartner.R1?.value ?? loadedPartner.R1 ?? 1.0,
                        R2: loadedPartner.R2?.value ?? loadedPartner.R2 ?? 1.0,
                        R3: loadedPartner.R3?.value ?? loadedPartner.R3 ?? 1.0,
                        R4: loadedPartner.R4?.value ?? loadedPartner.R4 ?? 1.0
                    };
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PAARUNGS-Resonanz berechnen: R_PAARUNG = Summe Ã— Similarity (v3.6)
            // Formel: (R_ich + R_partner) Ã— (min/max) - belohnt Ã„hnlichkeit
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const combineR = (a, b) => {
                const summe = a + b;
                const similarity = Math.min(a, b) / Math.max(a, b);
                return Math.round(summe * similarity * 1000) / 1000;
            };

            const resonanzWerte = {
                R1: combineR(resonanzIch.R1, resonanzPartner.R1),
                R2: combineR(resonanzIch.R2, resonanzPartner.R2),
                R3: combineR(resonanzIch.R3, resonanzPartner.R3),
                R4: combineR(resonanzIch.R4, resonanzPartner.R4)
            };

            console.log('[ResonanzModal] ICH:', resonanzIch, 'PARTNER:', resonanzPartner, 'PAARUNG (SummeÃ—Similarity):', resonanzWerte);

            // R-Faktoren Konfiguration mit AGOD-Zuordnung (v3.3: 18 Kategorien)
            // Die 18 GFK-Kategorien werden auf 4 Resonanzfaktoren aggregiert.
            // SekundÃ¤re Kategorien flieÃŸen mit 30% Gewichtung ein.
            const rFaktoren = {
                R1: {
                    label: 'Leben',
                    icon: 'ğŸ”¥',
                    color: '#E63946',
                    agod: 'Orientierung',
                    agodIcon: 'O',
                    beschreibung: 'Existenz, Zuneigung, MuÃŸe, IntimitÃ¤t & Romantik',
                    kategorien: 4
                },
                R2: {
                    label: 'Philosophie',
                    icon: 'ğŸ§ ',
                    color: '#2A9D8F',
                    agod: 'Archetyp',
                    agodIcon: 'A',
                    beschreibung: 'Freiheit, Teilnahme, IdentitÃ¤t, Lebensplanung, Finanzen, Werte, Soziales, Praktisches',
                    kategorien: 8
                },
                R3: {
                    label: 'Dynamik',
                    icon: 'âš¡',
                    color: '#8B5CF6',
                    agod: 'Dominanz',
                    agodIcon: 'D',
                    beschreibung: 'Dynamik, Sicherheit',
                    kategorien: 2
                },
                R4: {
                    label: 'IdentitÃ¤t',
                    icon: 'ğŸ’š',
                    color: '#F4A261',
                    agod: 'Geschlecht',
                    agodIcon: 'G',
                    beschreibung: 'VerstÃ¤ndnis, Erschaffen, Verbundenheit, Kommunikation',
                    kategorien: 4
                }
            };

            // Wert-Anzeige mit Farbcodierung und Lock-Status (nur Anzeige, nicht Ã¤nderbar)
            function getWertDisplay(wert, isLocked, showLock) {
                let color = '#eab308';
                if (wert >= 1.1) color = '#22c55e';
                else if (wert <= 0.9) color = '#ef4444';

                const lockIcon = showLock
                    ? (isLocked
                        ? `<span style="margin-left: 4px; opacity: 0.9;" title="Manuell gesperrt (Ã¤ndern in Attribute)">ğŸ”’</span>`
                        : `<span style="margin-left: 4px; opacity: 0.3;" title="Automatisch berechnet">ğŸ”“</span>`)
                    : '';

                return `<span style="color: ${color}; font-weight: 600;">${wert.toFixed(2)}</span>${lockIcon}`;
            }

            // Tabellen-Zeilen fÃ¼r R-Faktoren
            let tableRows = '';

            ['R1', 'R2', 'R3', 'R4'].forEach(rk => {
                const rf = rFaktoren[rk];
                const wertIch = resonanzIch[rk] || 1.0;
                const wertPartner = resonanzPartner[rk] || 1.0;
                const wertKombi = resonanzWerte[rk] || 1.0;
                const lockedIch = lockStatusIch[rk];
                const lockedPartner = lockStatusPartner[rk];

                // Klickbare Zellen fÃ¼r Herleitung
                const clickStyleIch = 'cursor: pointer; transition: background 0.15s;';
                const clickStylePartner = 'cursor: pointer; transition: background 0.15s;';
                const hoverTitle = 'Klick fÃ¼r Herleitung';

                tableRows += `
                    <tr style="border-bottom: 1px solid rgba(255,255,255,0.08);">
                        <td style="padding: 12px 14px; font-size: 13px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="color: ${rf.color}; font-weight: 600;">${rf.icon} ${rk}</span>
                                <span style="color: var(--text-secondary);">${rf.label}</span>
                            </div>
                            <div style="font-size: 10px; color: var(--text-muted); margin-top: 2px;">
                                â†’ multipliziert <strong>${rf.agodIcon}</strong> (${rf.agod})
                            </div>
                        </td>
                        <td style="padding: 12px 10px; text-align: center; font-size: 14px; ${clickStyleIch}"
                            onclick="showValueDerivation('${rk}', 'ich', ${wertIch})"
                            title="${hoverTitle}"
                            onmouseover="this.style.background='rgba(34,197,94,0.15)'"
                            onmouseout="this.style.background=''">${getWertDisplay(wertIch, lockedIch, true)}</td>
                        <td style="padding: 12px 10px; text-align: center; font-size: 14px; ${clickStylePartner}"
                            onclick="showValueDerivation('${rk}', 'partner', ${wertPartner})"
                            title="${hoverTitle}"
                            onmouseover="this.style.background='rgba(239,68,68,0.15)'"
                            onmouseout="this.style.background=''">${getWertDisplay(wertPartner, lockedPartner, true)}</td>
                        <td style="padding: 12px 10px; text-align: center; font-size: 14px; background: rgba(139,92,246,0.1);">${getWertDisplay(wertKombi, false, false)}</td>
                    </tr>`;
            });

            // Archetyp-Buttons
            const ichArch = archetypeDescriptions[currentArchetype];
            const partnerArch = archetypeDescriptions[selectedPartner];
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';
            const ichIcon = ichArch?.icon || 'ğŸ‘¤';
            const partnerIcon = partnerArch?.icon || 'ğŸ‘¤';

            modal.innerHTML = `
                <div style="background: var(--bg-primary); border-radius: 16px; max-width: 600px; width: 95%; max-height: 90vh; overflow-y: auto; box-shadow: 0 20px 60px rgba(0,0,0,0.5); border: 1px solid rgba(139,92,246,0.3);">
                    <!-- Header -->
                    <div style="padding: 20px 24px; border-bottom: 1px solid rgba(255,255,255,0.1); display: flex; align-items: center; justify-content: space-between;">
                        <div style="display: flex; align-items: center; gap: 12px;">
                            <span style="font-size: 24px;">ğŸ›ï¸</span>
                            <div>
                                <h2 style="margin: 0; font-size: 18px; color: var(--text-primary);">Resonanzfaktoren (R1-R4)</h2>
                                <p style="margin: 4px 0 0 0; font-size: 12px; color: var(--text-muted);">KohÃ¤renz zwischen BedÃ¼rfnissen und Archetyp</p>
                            </div>
                        </div>
                        <button onclick="closeResonanzfaktorenModal()" style="background: rgba(255,255,255,0.1); border: none; border-radius: 8px; width: 36px; height: 36px; cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 18px; color: var(--text-secondary); transition: all 0.2s;">Ã—</button>
                    </div>

                    <!-- Archetyp-Switcher (gleicher Stil wie Ti-Age Synthese) -->
                    <div style="display: flex; justify-content: center; align-items: center; gap: 20px; padding: 16px 24px; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.05);">
                        <!-- ICH Navigation -->
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <button class="archetype-nav-btn" onclick="navigateResonanzArchetype('ich', -1)" title="Vorheriger Archetyp" style="width: 28px; height: 28px; font-size: 1.2rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; cursor: pointer; color: var(--text-secondary);">â€¹</button>
                            <div style="text-align: center; min-width: 120px;">
                                <div style="font-size: 10px; color: var(--success); font-weight: 600; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">ICH</div>
                                <div style="font-size: 13px; color: var(--text-primary); font-weight: 600;">${ichName}</div>
                            </div>
                            <button class="archetype-nav-btn" onclick="navigateResonanzArchetype('ich', 1)" title="NÃ¤chster Archetyp" style="width: 28px; height: 28px; font-size: 1.2rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; cursor: pointer; color: var(--text-secondary);">â€º</button>
                        </div>
                        <div style="font-size: 18px; color: var(--text-muted);">Ã—</div>
                        <!-- PARTNER Navigation -->
                        <div style="display: flex; align-items: center; gap: 6px;">
                            <button class="archetype-nav-btn" onclick="navigateResonanzArchetype('partner', -1)" title="Vorheriger Archetyp" style="width: 28px; height: 28px; font-size: 1.2rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; cursor: pointer; color: var(--text-secondary);">â€¹</button>
                            <div style="text-align: center; min-width: 120px;">
                                <div style="font-size: 10px; color: var(--danger); font-weight: 600; margin-bottom: 4px; text-transform: uppercase; letter-spacing: 0.5px;">PARTNER</div>
                                <div style="font-size: 13px; color: var(--text-primary); font-weight: 600;">${partnerName}</div>
                            </div>
                            <button class="archetype-nav-btn" onclick="navigateResonanzArchetype('partner', 1)" title="NÃ¤chster Archetyp" style="width: 28px; height: 28px; font-size: 1.2rem; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; cursor: pointer; color: var(--text-secondary);">â€º</button>
                        </div>
                    </div>

                    <!-- Tabelle -->
                    <div style="padding: 20px 24px;">
                        <div style="background: linear-gradient(135deg, rgba(139,92,246,0.1), rgba(59,130,246,0.06)); border-radius: 12px; border: 1px solid rgba(139,92,246,0.25); overflow: hidden;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="border-bottom: 2px solid rgba(139,92,246,0.3); background: rgba(0,0,0,0.2);">
                                        <th style="padding: 12px 14px; text-align: left; color: var(--text-muted); font-weight: 500; font-size: 12px;">R-Faktor â†’ AGOD</th>
                                        <th style="padding: 12px 10px; text-align: center; color: var(--success); font-weight: 500; font-size: 12px;">ICH</th>
                                        <th style="padding: 12px 10px; text-align: center; color: var(--danger); font-weight: 500; font-size: 12px;">PARTNER</th>
                                        <th style="padding: 12px 10px; text-align: center; color: #8B5CF6; font-weight: 600; font-size: 12px; background: rgba(139,92,246,0.1);">PAARUNG</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${tableRows}
                                </tbody>
                            </table>
                        </div>

                        <!-- ErlÃ¤uterung -->
                        <div style="margin-top: 16px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; font-size: 11px; color: var(--text-muted); line-height: 1.6;">
                            <div style="margin-bottom: 8px;">
                                <strong style="color: var(--text-secondary);">Was zeigt diese Tabelle?</strong>
                            </div>
                            <div>
                                <strong style="color: #22c55e;">ICH</strong> / <strong style="color: #ef4444;">PARTNER</strong>:
                                <em>KohÃ¤renz</em> zwischen BedÃ¼rfnissen und gewÃ¤hltem Archetyp.<br>
                                <strong style="color: #8B5CF6;">PAARUNG</strong>:
                                R_ICH Ã— R_PARTNER (Produkt der individuellen KohÃ¤renz-Werte).<br>
                                Der PAARUNGS-Wert multipliziert den jeweiligen AGOD-Score:
                            </div>
                            <div style="margin-top: 8px; font-family: monospace; font-size: 10px;">
                                Q = (O Ã— wO Ã— Râ‚) + (A Ã— wA Ã— Râ‚‚) + (D Ã— wD Ã— Râ‚ƒ) + (G Ã— wG Ã— Râ‚„)
                            </div>
                            <div style="margin-top: 8px; display: flex; gap: 12px; flex-wrap: wrap;">
                                <span style="color: #22c55e;">â— &gt;1.0 = verstÃ¤rkt Score</span>
                                <span style="color: #eab308;">â— =1.0 = neutral</span>
                                <span style="color: #ef4444;">â— &lt;1.0 = schwÃ¤cht Score</span>
                            </div>
                            <div style="margin-top: 10px; padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.1);">
                                <span>ğŸ”’ = manuell gesperrt (Ã¤ndert sich nicht bei Archetyp-Wechsel)</span><br>
                                <span>ğŸ”“ = automatisch (wird bei Archetyp-Wechsel neu berechnet)</span>
                            </div>
                            <div style="margin-top: 10px; padding: 8px; background: rgba(139,92,246,0.15); border-radius: 6px; border: 1px solid rgba(139,92,246,0.3);">
                                <span style="color: var(--text-secondary);">ğŸ’¡ <strong>Tipp:</strong> Klicke auf einen ICH- oder PARTNER-Wert, um die vollstÃ¤ndige Herleitung zu sehen!</span>
                            </div>
                        </div>
                    </div>
                </div>`;
        }

        /**
         * Generiert den Synthese-Quote-Text basierend auf dem aktuellen Score
         * Wird im CREATIVITY-Abschnitt des Modals angezeigt
         * Verwendet die ResonanceQuotesTable fÃ¼r Pirsig/Osho/SprichwÃ¶rter-Zitate
         */
        function getSyntheseQuoteText() {
            // Hole den aktuellen Score aus dem Display
            const scoreEl = document.getElementById('mainScoreValue') || document.getElementById('mobileScoreCircle');
            const scoreText = scoreEl?.textContent || '0';
            const score = parseInt(scoreText, 10) || 0;

            let noteText = '';
            let quoteText = '';
            let quoteSource = '';

            // Bestimme Resonanzlevel basierend auf Score
            let resonanceLevel = 'niedrig';
            if (score >= 80) resonanceLevel = 'hoch';
            else if (score >= 50) resonanceLevel = 'mittel';

            // Versuche Zitat aus ResonanceQuotesTable zu holen
            if (typeof ResonanceQuotesTable !== 'undefined') {
                const category = score >= 65 ? 'RESONANCE' : score >= 50 ? 'GROWTH' : 'AWARENESS';
                const result = ResonanceQuotesTable.generateResonanceText(resonanceLevel, category, 'de');

                if (result && result.quote) {
                    noteText = result.title;
                    quoteText = result.quote;
                    quoteSource = result.quoteSource;
                    return { noteText, quoteText, quoteSource };
                }
            }

            // Fallback zu hardcoded Texten
            if (score < 30) {
                noteText = 'Sehr niedrige Resonanz â€“ groÃŸe Unterschiede.';
                quoteText = 'Hier begegnen sich zwei Menschen, deren Frequenzen sich deutlich unterscheiden. Diese Beziehung erfordert besondere Achtsamkeit und die Bereitschaft, die Andersartigkeit des anderen als Bereicherung zu sehen.';
            } else if (score >= 80) {
                noteText = 'Hohe Resonanz â€“ Muster ergÃ¤nzen sich.';
                quoteText = 'Hier begegnen sich zwei Menschen, deren Frequenzen sich natÃ¼rlich ergÃ¤nzen. Diese Verbindung trÃ¤gt die QualitÃ¤t tiefer Resonanz â€“ ein Zusammenspiel, das beide bereichert und wachsen lÃ¤sst.';
            } else if (score >= 65) {
                noteText = 'Solide Balance mit Potenzial.';
                quoteText = 'Hier begegnen sich zwei Menschen mit guter Grundresonanz. Diese Verbindung bietet eine solide Balance und echtes Potenzial fÃ¼r gemeinsames Wachstum.';
            } else if (score >= 50) {
                noteText = 'Basis vorhanden, Arbeit erforderlich.';
                quoteText = 'Hier begegnen sich zwei Menschen mit einer tragfÃ¤higen Basis. Diese Verbindung hat QualitÃ¤t, die durch bewusste Kommunikation und gegenseitiges VerstÃ¤ndnis vertieft werden kann.';
            } else {
                noteText = 'Bewusste Reflexion erforderlich.';
                quoteText = 'Hier begegnen sich zwei Menschen mit unterschiedlichen Mustern. Diese Verbindung lÃ¤dt zur bewussten Reflexion ein â€“ ein Weg, der Offenheit und ehrliche Kommunikation erfordert.';
            }

            return { noteText, quoteText, quoteSource: '' };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // TEXT-TO-SPEECH (TTS) fÃ¼r CREATIVITY-Bereich
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Track which section is currently being read
        let currentTTSSection = null;

        /**
         * Toggle Text-to-Speech for the CREATIVITY section
         * @param {string} section - 'pathos' or 'logos'
         */
        function toggleCreativityTTS(section) {
            // Check if TTS is supported
            if (!TiageTTS || !TiageTTS.isSupported()) {
                const notSupportedMsg = TiageI18n.t('tts.notSupported', 'Vorlesen wird in diesem Browser nicht unterstÃ¼tzt');
                alert(notSupportedMsg);
                return;
            }

            const iconEl = document.getElementById(`ttsIcon${section.charAt(0).toUpperCase() + section.slice(1)}`);
            const buttonEl = document.getElementById(`ttsButton${section.charAt(0).toUpperCase() + section.slice(1)}`);
            const textEl = document.getElementById(`creativityText${section.charAt(0).toUpperCase() + section.slice(1)}`);

            if (!textEl || !iconEl) return;

            // If currently speaking the same section
            if (currentTTSSection === section && TiageTTS.isSpeaking()) {
                if (TiageTTS.isPaused()) {
                    // Resume
                    TiageTTS.resume();
                    iconEl.textContent = 'â¸ï¸';
                    buttonEl.title = TiageI18n.t('tts.pause', 'Pausieren');
                } else {
                    // Pause
                    TiageTTS.pause();
                    iconEl.textContent = 'â–¶ï¸';
                    buttonEl.title = TiageI18n.t('tts.resume', 'Fortsetzen');
                }
                return;
            }

            // If speaking a different section, stop first
            if (TiageTTS.isSpeaking()) {
                TiageTTS.stop();
                resetTTSButtons();
            }

            // Get text content and start speaking
            const text = textEl.textContent || textEl.innerText;
            if (!text.trim()) return;

            currentTTSSection = section;
            TiageTTS.speak(text);

            // Update button
            iconEl.textContent = 'â¸ï¸';
            buttonEl.title = TiageI18n.t('tts.pause', 'Pausieren');

            // Subscribe to TTS events for this speech
            const unsubscribe = TiageTTS.subscribe((event) => {
                if (event.type === 'end' || event.type === 'stop' || event.type === 'error') {
                    resetTTSButtons();
                    currentTTSSection = null;
                    unsubscribe();
                }
            });
        }

        /**
         * Reset all TTS buttons to their default state
         */
        function resetTTSButtons() {
            const playLabel = TiageI18n.t('tts.play', 'Vorlesen');

            ['Pathos', 'Logos'].forEach(section => {
                const iconEl = document.getElementById(`ttsIcon${section}`);
                const buttonEl = document.getElementById(`ttsButton${section}`);
                if (iconEl) iconEl.textContent = 'ğŸ”Š';
                if (buttonEl) buttonEl.title = playLabel;
            });
        }

        /**
         * Stop TTS when modal is closed
         */
        function stopTTSOnModalClose() {
            if (TiageTTS && TiageTTS.isSpeaking()) {
                TiageTTS.stop();
                resetTTSButtons();
                currentTTSSection = null;
            }
        }

        /**
         * Generate Osho Zen content - Top 5 gemeinsame BedÃ¼rfnisse mit Osho Zen Tarot Texten
         */
        function getOshoZenContent() {
            // Hole die Profile
            const profile1 = window.LoadedArchetypProfile?.ich || {};
            const profile2 = window.LoadedArchetypProfile?.partner || {};

            // Namen ermitteln
            const ichName = profile1.name || archetypeDescriptions[currentArchetype]?.name || 'Ich';
            const partnerName = profile2.name || archetypeDescriptions[selectedPartner]?.name || 'Partner';

            // PrÃ¼fe ob OshoZenTextGenerator verfÃ¼gbar ist
            if (typeof OshoZenTextGenerator === 'undefined') {
                return `
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        <p>Osho Zen Modul wird geladen...</p>
                        <p style="font-size: 0.85rem; margin-top: 10px;">
                            Bitte stelle sicher, dass <code>oshoZenTextGenerator.js</code> geladen ist.
                        </p>
                    </div>
                `;
            }

            // PrÃ¼fe ob Daten geladen sind
            if (!OshoZenTextGenerator.isDataLoaded()) {
                // Asynchron laden und dann Content aktualisieren
                OshoZenTextGenerator.loadData().then(() => {
                    const contentEl = document.getElementById('tiageSyntheseModalContent');
                    if (contentEl && currentTiageSyntheseType === 'oshozen') {
                        contentEl.innerHTML = getOshoZenContent();
                    }
                }).catch(err => {
                    console.error('Fehler beim Laden der Osho Zen Daten:', err);
                });

                return `
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        <div style="font-size: 2rem; margin-bottom: 10px;">ğŸ”¥</div>
                        <p>Lade Osho Zen Texte...</p>
                    </div>
                `;
            }

            // Generiere den Content
            return OshoZenTextGenerator.generateSync({
                profile1: profile1,
                profile2: profile2,
                name1: ichName,
                name2: partnerName,
                topN: 5
            });
        }

        function getPathosContent() {
            const ichArch = archetypeDescriptions[currentArchetype];
            const partnerArch = archetypeDescriptions[selectedPartner];
            const detailed = generateDetailedPathos(ichArch, partnerArch);
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';

            // GFK-BedÃ¼rfnis-Analyse holen
            const gfkAnalyse = getGfkBeduerfnisAnalyse('pathos');

            const creativityLabel = TiageI18n.t('synthesisSection.creativity', 'CREATIVITY');

            // Dynamik+Wachstum kombiniert als FlieÃŸtext
            const dynamikWachstumText = gfkAnalyse.dynamikSection || '';

            // Synthese-Quote-Text fÃ¼r CREATIVITY-Abschnitt
            const syntheseQuote = getSyntheseQuoteText();

            // TTS Button Label
            const ttsPlayLabel = TiageI18n.t('tts.play', 'Vorlesen');

            let html = `
                <!-- GEMEINSAME BEDÃœRFNISSE -->
                ${gfkAnalyse.gemeinsamSection}

                <!-- CREATIVITY -->
                <div style="margin-bottom: 16px;">
                    <div style="padding: 14px; background: linear-gradient(135deg, rgba(255,215,0,0.1), rgba(231,111,81,0.08)); border-radius: 10px; border: 1px solid rgba(231,111,81,0.3);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 14px;">ğŸ”¥</span>
                                <span style="font-size: 11px; color: #FFD700; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;">${creativityLabel}</span>
                            </div>
                            <button id="ttsButtonPathos" onclick="toggleCreativityTTS('pathos')" title="${ttsPlayLabel}" style="background: rgba(255,215,0,0.2); border: 1px solid rgba(255,215,0,0.4); border-radius: 6px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center; gap: 4px; transition: all 0.2s ease;">
                                <span id="ttsIconPathos" style="font-size: 14px;">ğŸ”Š</span>
                            </button>
                        </div>
                        <div id="creativityTextPathos">
                            <p style="font-size: 13px; margin: 0 0 10px 0; line-height: 1.5;"><strong style="color: var(--text-primary);">${syntheseQuote.noteText}</strong></p>
                            <p style="font-size: 13px; margin: 0 0 12px 0; line-height: 1.5; font-style: italic; color: var(--text-secondary); opacity: 0.9;">"${syntheseQuote.quoteText}"</p>
                            <p style="font-size: 14px; margin: 0; line-height: 1.6; font-style: italic;">${detailed.synthese}</p>
                        </div>
                        ${dynamikWachstumText}
                    </div>
                </div>`;

            return html;
        }

        function getLogosContent() {
            const ichArch = archetypeDescriptions[currentArchetype];
            const partnerArch = archetypeDescriptions[selectedPartner];
            const detailed = generateDetailedLogos(ichArch, partnerArch);
            const ichName = ichArch?.name || 'ICH';
            const partnerName = partnerArch?.name || 'Partner';

            // GFK-BedÃ¼rfnis-Analyse holen
            const gfkAnalyse = getGfkBeduerfnisAnalyse('logos');

            const creativityLabel = TiageI18n.t('synthesisSection.creativity', 'CREATIVITY');

            // Dynamik+Wachstum kombiniert als FlieÃŸtext
            const dynamikWachstumText = gfkAnalyse.dynamikSection || '';

            // Synthese-Quote-Text fÃ¼r CREATIVITY-Abschnitt
            const syntheseQuote = getSyntheseQuoteText();

            // TTS Button Label
            const ttsPlayLabel = TiageI18n.t('tts.play', 'Vorlesen');

            let html = `
                <!-- GEMEINSAME WERTE -->
                ${gfkAnalyse.gemeinsamSection}

                <!-- CREATIVITY -->
                <div style="margin-bottom: 16px;">
                    <div style="padding: 14px; background: linear-gradient(135deg, rgba(100,149,237,0.1), rgba(69,123,157,0.08)); border-radius: 10px; border: 1px solid rgba(69,123,157,0.3);">
                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                            <div style="display: flex; align-items: center; gap: 8px;">
                                <span style="font-size: 14px;">ğŸ§ </span>
                                <span style="font-size: 11px; color: #6495ED; font-weight: 600; text-transform: uppercase; letter-spacing: 1px;">${creativityLabel}</span>
                            </div>
                            <button id="ttsButtonLogos" onclick="toggleCreativityTTS('logos')" title="${ttsPlayLabel}" style="background: rgba(100,149,237,0.2); border: 1px solid rgba(100,149,237,0.4); border-radius: 6px; padding: 4px 8px; cursor: pointer; display: flex; align-items: center; gap: 4px; transition: all 0.2s ease;">
                                <span id="ttsIconLogos" style="font-size: 14px;">ğŸ”Š</span>
                            </button>
                        </div>
                        <div id="creativityTextLogos">
                            <p style="font-size: 13px; margin: 0 0 10px 0; line-height: 1.5;"><strong style="color: var(--text-primary);">${syntheseQuote.noteText}</strong></p>
                            <p style="font-size: 13px; margin: 0 0 12px 0; line-height: 1.5; font-style: italic; color: var(--text-secondary); opacity: 0.9;">"${syntheseQuote.quoteText}"</p>
                            <p style="font-size: 14px; margin: 0; line-height: 1.6; font-style: italic;">${detailed.synthese}</p>
                        </div>
                        ${dynamikWachstumText}
                    </div>
                </div>`;

            return html;
        }

        /**
         * Generate Needs content (BedÃ¼rfnis-Match mit Differenz)
         * Shows the full needs comparison with difference values
         */
        // Sortierung State fÃ¼r Needs Synthese
        let needsSyntheseSortBy = null; // 'ich', 'diff', 'partner'
        let needsSyntheseSortDir = 'desc';

        function sortNeedsSyntheseContent(column) {
            if (needsSyntheseSortBy === column) {
                needsSyntheseSortDir = needsSyntheseSortDir === 'desc' ? 'asc' : 'desc';
            } else {
                needsSyntheseSortBy = column;
                needsSyntheseSortDir = 'desc';
            }
            // Re-render content
            const contentEl = document.getElementById('tiageSyntheseModalContent');
            if (contentEl) {
                contentEl.innerHTML = getNeedsContent();
            }
        }
        window.sortNeedsSyntheseContent = sortNeedsSyntheseContent;

        /**
         * Helper function to get actual need value from TiageState
         * @param {string} person - 'ich' or 'partner'
         * @param {string} needId - Need ID like '#B1', '#B2', etc.
         * @returns {number|null} - The actual value or null if not found
         */
        function getActualNeedValue(person, needId) {
            if (typeof TiageState === 'undefined') {
                return null;
            }

            // Get locked and flat needs
            const lockedNeeds = TiageState.getLockedNeeds(person) || {};
            const flatNeeds = TiageState.getFlatNeeds(person) || {};

            // lockedNeeds have priority
            if (lockedNeeds[needId] !== undefined && lockedNeeds[needId] !== null) {
                return lockedNeeds[needId];
            }
            if (flatNeeds[needId] !== undefined && flatNeeds[needId] !== null) {
                return flatNeeds[needId];
            }
            return null;
        }

        /**
         * Helper function to check if a need is locked
         * @param {string} person - 'ich' or 'partner'
         * @param {string} needId - Need ID like '#B1', '#B2', etc.
         * @returns {boolean} - True if the need is locked
         */
        function isNeedLocked(person, needId) {
            if (typeof TiageState === 'undefined') {
                return false;
            }

            const lockedNeeds = TiageState.getLockedNeeds(person) || {};
            return lockedNeeds[needId] !== undefined && lockedNeeds[needId] !== null;
        }

        function getNeedsContent() {
            // Matching-Daten holen - SchlÃ¼ssel unverÃ¤ndert (duo_flex bleibt duo_flex)
            const ichArchetyp = currentArchetype || '';
            const partnerArchetyp = selectedPartner || '';

            if (!ichArchetyp || !partnerArchetyp) {
                return '<p style="color: var(--text-muted);">Keine Daten verfÃ¼gbar.</p>';
            }

            const ichName = archetypeDescriptions[currentArchetype]?.name || 'ICH';
            const partnerName = archetypeDescriptions[selectedPartner]?.name || 'Partner';

            // NEU: Direkt aus TiageState.flatNeeds lesen (inkl. lockedNeeds)
            let matching = null;
            let isFallback = false;

            // PrimÃ¤r: Direkt aus TiageState.flatNeeds
            const result = calculateNeedsMatchFromFlatNeeds();
            if (result) {
                // Format-Konvertierung: need â†’ { label, id, wert1, wert2, diff }
                const formatNeed = (item) => ({
                    label: formatBeduerfnisLabel(item.need),
                    id: item.need,
                    wert1: item.wert1,
                    wert2: item.wert2,
                    diff: Math.abs(item.wert1 - item.wert2)
                });

                matching = {
                    score: result.score,
                    details: {
                        uebereinstimmend: result.gemeinsam.map(formatNeed),
                        komplementaer: result.komplementaer.map(formatNeed),
                        konflikt: result.unterschiedlich.map(formatNeed)
                    }
                };
                console.log('[getNeedsContent] âœ“ Verwende individualisierte Werte aus TiageState.flatNeeds');
            }

            // Fallback: Alte Methode (nur Archetyp - falls flatNeeds leer)
            if (!matching && typeof GfkBeduerfnisse !== 'undefined') {
                matching = GfkBeduerfnisse.berechneMatching(ichArchetyp, partnerArchetyp);
                isFallback = true;
                console.log('[getNeedsContent] âš  Fallback: Verwende Archetyp-basierte BedÃ¼rfniswerte');
            }

            if (!matching) {
                return '<p style="color: var(--text-muted);">Keine Daten verfÃ¼gbar.</p>';
            }

            // Lock-Icons helper fÃ¼r Anzeige
            const ichLockedNeeds = typeof TiageState !== 'undefined' ? (TiageState.getLockedNeeds('ich') || {}) : {};
            const partnerLockedNeeds = typeof TiageState !== 'undefined' ? (TiageState.getLockedNeeds('partner') || {}) : {};

            const isNeedLocked = (person, needId) => {
                const lockedNeeds = person === 'ich' ? ichLockedNeeds : partnerLockedNeeds;
                return lockedNeeds[needId] !== undefined && lockedNeeds[needId] !== null;
            };

            // Score-Anzeige
            const scoreValue = matching.score || 0;
            let scoreColor = '#ef4444';
            if (scoreValue >= 80) {
                scoreColor = '#22c55e';
            } else if (scoreValue >= 60) {
                scoreColor = '#eab308';
            }

            // Score Header
            let html = `
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 48px; font-weight: 700; color: ${scoreColor};">${scoreValue}%</div>
                    <div style="font-size: 12px; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px;">
                        BedÃ¼rfnis-Ãœbereinstimmung
                        <span onclick="openNeedsScoreExplanation();" style="cursor: help; margin-left: 6px; opacity: 0.8; font-size: 14px;" title="Wie wird dieser Wert berechnet?">â„¹ï¸</span>
                    </div>
                </div>
            `;

            // Fallback-Hinweis (nur wenn Archetyp-basierte Werte verwendet werden)
            if (isFallback) {
                html += `
                    <div style="
                        background: rgba(234, 179, 8, 0.1);
                        border: 1px solid rgba(234, 179, 8, 0.3);
                        border-radius: 6px;
                        padding: 8px 12px;
                        margin-bottom: 16px;
                        display: flex;
                        align-items: center;
                        gap: 8px;
                    ">
                        <span style="font-size: 14px;">â„¹ï¸</span>
                        <div style="flex: 1;">
                            <div style="font-size: 11px; font-weight: 600; color: #eab308; margin-bottom: 2px;">Archetyp-Basis-Werte</div>
                            <div style="font-size: 10px; color: var(--text-muted); line-height: 1.4;">
                                Individualisierte Werte nicht verfÃ¼gbar. Es werden Standard-Archetyp-Werte angezeigt.
                            </div>
                        </div>
                    </div>
                `;
            }

            // Gemeinsame & Kompatible BedÃ¼rfnisse
            const uebereinstimmend = matching.details?.uebereinstimmend || [];
            const komplementaer = matching.details?.komplementaer || [];
            let gemeinsam = [...uebereinstimmend, ...komplementaer];

            // Unterschiedliche PrioritÃ¤ten
            let konflikt = [...(matching.details?.konflikt || [])];

            // Sortierung anwenden
            const sortItems = (items) => {
                if (!needsSyntheseSortBy) {
                    // Default: nach Durchschnitt sortieren
                    return items.sort((a, b) => ((b.wert1 + b.wert2) / 2) - ((a.wert1 + a.wert2) / 2));
                }
                return items.sort((a, b) => {
                    let valA, valB;
                    if (needsSyntheseSortBy === 'ich') {
                        valA = a.wert1 || 0;
                        valB = b.wert1 || 0;
                    } else if (needsSyntheseSortBy === 'diff') {
                        valA = Math.abs((a.wert1 || 0) - (a.wert2 || 0));
                        valB = Math.abs((b.wert1 || 0) - (b.wert2 || 0));
                    } else {
                        valA = a.wert2 || 0;
                        valB = b.wert2 || 0;
                    }
                    return needsSyntheseSortDir === 'desc' ? valB - valA : valA - valB;
                });
            };

            gemeinsam = sortItems(gemeinsam);
            konflikt = sortItems(konflikt);

            // Sort-Icons
            const ichSortIcon = needsSyntheseSortBy === 'ich'
                ? (needsSyntheseSortDir === 'desc' ? 'â–¼' : 'â–²')
                : 'â‡…';
            const diffSortIcon = needsSyntheseSortBy === 'diff'
                ? (needsSyntheseSortDir === 'desc' ? 'â–¼' : 'â–²')
                : 'â‡…';
            const partnerSortIcon = needsSyntheseSortBy === 'partner'
                ? (needsSyntheseSortDir === 'desc' ? 'â–¼' : 'â–²')
                : 'â‡…';
            const ichActive = needsSyntheseSortBy === 'ich';
            const diffActive = needsSyntheseSortBy === 'diff';
            const partnerActive = needsSyntheseSortBy === 'partner';

            // Header mit Archetyp-Namen und Sortier-Buttons
            html += `
                <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 10px; margin-bottom: 12px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.1);">
                    <button onclick="sortNeedsSyntheseContent('ich')" style="display: flex; align-items: center; justify-content: center; gap: 6px; background: ${ichActive ? 'rgba(34, 197, 94, 0.15)' : 'transparent'}; border: 1px solid ${ichActive ? 'rgba(34, 197, 94, 0.4)' : 'transparent'}; border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: all 0.2s;">
                        <span style="font-weight: 600; color: var(--success); font-size: 11px; text-transform: uppercase; letter-spacing: 1px;">${ichName}</span>
                        <span style="color: ${ichActive ? 'var(--success)' : 'var(--text-muted)'}; font-size: 10px;">${ichSortIcon}</span>
                    </button>
                    <button onclick="sortNeedsSyntheseContent('diff')" style="display: flex; align-items: center; justify-content: center; gap: 4px; background: ${diffActive ? 'rgba(234, 179, 8, 0.15)' : 'transparent'}; border: 1px solid ${diffActive ? 'rgba(234, 179, 8, 0.4)' : 'transparent'}; border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: all 0.2s; min-width: 60px;">
                        <span style="font-weight: 600; color: var(--warning, #eab308); font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px;">Diff</span>
                        <span style="color: ${diffActive ? 'var(--warning, #eab308)' : 'var(--text-muted)'}; font-size: 10px;">${diffSortIcon}</span>
                    </button>
                    <button onclick="sortNeedsSyntheseContent('partner')" style="display: flex; align-items: center; justify-content: center; gap: 6px; background: ${partnerActive ? 'rgba(239, 68, 68, 0.15)' : 'transparent'}; border: 1px solid ${partnerActive ? 'rgba(239, 68, 68, 0.4)' : 'transparent'}; border-radius: 6px; padding: 6px 8px; cursor: pointer; transition: all 0.2s;">
                        <span style="font-weight: 600; color: var(--danger); font-size: 11px; text-transform: uppercase; letter-spacing: 1px;">${partnerName}</span>
                        <span style="color: ${partnerActive ? 'var(--danger)' : 'var(--text-muted)'}; font-size: 10px;">${partnerSortIcon}</span>
                    </button>
                </div>
            `;

            // Gemeinsame BedÃ¼rfnisse Section
            if (gemeinsam.length > 0) {
                html += `
                    <div style="margin-bottom: 20px;">
                        <div style="font-size: 11px; color: #22c55e; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 14px;">âœ“</span> Gemeinsame & Kompatible BedÃ¼rfnisse
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto;">
                `;

                gemeinsam.forEach(item => {
                    // item.label ist bereits der Display-Name
                    const label = item.label;

                    // Use actual values from TiageState if available, otherwise fallback to archetyp values
                    const actualWert1 = getActualNeedValue('ich', item.id);
                    const actualWert2 = getActualNeedValue('partner', item.id);
                    const wert1 = actualWert1 !== null ? actualWert1 : (item.wert1 || 0);
                    const wert2 = actualWert2 !== null ? actualWert2 : (item.wert2 || 0);

                    // Check if needs are locked
                    const ichLocked = isNeedLocked('ich', item.id);
                    const partnerLocked = isNeedLocked('partner', item.id);

                    const diff = Math.abs(wert1 - wert2);

                    let statusColor = '#22c55e';
                    if (diff > 35) statusColor = '#ef4444';
                    else if (diff > 15) statusColor = '#eab308';

                    // Escape Namen fÃ¼r sichere JSON-Ãœbergabe
                    const safeIchName = (ichName || 'Du').replace(/'/g, "\\'");
                    const safePartnerName = (partnerName || 'Partner').replace(/'/g, "\\'");

                    html += `
                        <div style="background: rgba(255,255,255,0.03); border-radius: 6px; padding: 10px 12px; border-left: 3px solid ${statusColor};">
                            <div onclick="openNeedWithResonance('${item.id}', 'resonance', {wert1: ${wert1}, wert2: ${wert2}, ichName: '${safeIchName}', partnerName: '${safePartnerName}'})" style="font-weight: 500; color: var(--text-primary); font-size: 13px; margin-bottom: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s;" onmouseover="this.style.color='var(--primary)'" onmouseout="this.style.color='var(--text-primary)'">
                                ${label}
                                <span style="font-size: 10px; opacity: 0.5;">â“˜</span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    ${ichLocked ? '<span style="font-size: 10px; color: #eab308;" title="Verschlossen">ğŸ”’</span>' : ''}
                                    <div style="flex: 1; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert1}%; height: 100%; background: var(--success); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 32px; text-align: right;">${wert1}</span>
                                </div>
                                <div style="display: flex; align-items: center; justify-content: center; min-width: 50px;">
                                    <span style="font-size: 11px; font-weight: 600; color: ${statusColor}; background: ${statusColor}22; padding: 2px 6px; border-radius: 4px;">${diff}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    ${partnerLocked ? '<span style="font-size: 10px; color: #eab308;" title="Verschlossen">ğŸ”’</span>' : ''}
                                    <div style="flex: 1; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert2}%; height: 100%; background: var(--danger); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 32px; text-align: right;">${wert2}</span>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        <div style="text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 8px;">
                            ${gemeinsam.length} gemeinsame & kompatible BedÃ¼rfnisse
                        </div>
                    </div>
                `;
            }

            // Unterschiedliche PrioritÃ¤ten Section
            if (konflikt.length > 0) {
                html += `
                    <div style="margin-bottom: 10px;">
                        <div style="font-size: 11px; color: #ef4444; font-weight: 600; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 10px; display: flex; align-items: center; gap: 6px;">
                            <span style="font-size: 14px;">âœ—</span> Herausfordernde Unterschiede
                        </div>
                        <div style="display: flex; flex-direction: column; gap: 6px; max-height: 200px; overflow-y: auto;">
                `;

                konflikt.forEach(item => {
                    // item.label ist bereits der Display-Name
                    const label = item.label;

                    // Use actual values from TiageState if available, otherwise fallback to archetyp values
                    const actualWert1 = getActualNeedValue('ich', item.id);
                    const actualWert2 = getActualNeedValue('partner', item.id);
                    const wert1 = actualWert1 !== null ? actualWert1 : (item.wert1 || 0);
                    const wert2 = actualWert2 !== null ? actualWert2 : (item.wert2 || 0);

                    // Check if needs are locked
                    const ichLocked = isNeedLocked('ich', item.id);
                    const partnerLocked = isNeedLocked('partner', item.id);

                    const diff = Math.abs(wert1 - wert2);

                    let statusColor = '#22c55e';
                    if (diff > 35) statusColor = '#ef4444';
                    else if (diff > 15) statusColor = '#eab308';

                    // Escape Namen fÃ¼r sichere JSON-Ãœbergabe
                    const safeIchName = (ichName || 'Du').replace(/'/g, "\\'");
                    const safePartnerName = (partnerName || 'Partner').replace(/'/g, "\\'");

                    html += `
                        <div style="background: rgba(255,255,255,0.03); border-radius: 6px; padding: 10px 12px; border-left: 3px solid ${statusColor};">
                            <div onclick="openNeedWithResonance('${item.id}', 'resonance', {wert1: ${wert1}, wert2: ${wert2}, ichName: '${safeIchName}', partnerName: '${safePartnerName}'})" style="font-weight: 500; color: var(--text-primary); font-size: 13px; margin-bottom: 6px; cursor: pointer; display: flex; align-items: center; gap: 6px; transition: color 0.2s;" onmouseover="this.style.color='var(--primary)'" onmouseout="this.style.color='var(--text-primary)'">
                                ${label}
                                <span style="font-size: 10px; opacity: 0.5;">â“˜</span>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr auto 1fr; gap: 8px; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    ${ichLocked ? '<span style="font-size: 10px; color: #eab308;" title="Verschlossen">ğŸ”’</span>' : ''}
                                    <div style="flex: 1; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert1}%; height: 100%; background: var(--success); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 32px; text-align: right;">${wert1}</span>
                                </div>
                                <div style="display: flex; align-items: center; justify-content: center; min-width: 50px;">
                                    <span style="font-size: 11px; font-weight: 600; color: ${statusColor}; background: ${statusColor}22; padding: 2px 6px; border-radius: 4px;">${diff}</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 6px;">
                                    ${partnerLocked ? '<span style="font-size: 10px; color: #eab308;" title="Verschlossen">ğŸ”’</span>' : ''}
                                    <div style="flex: 1; height: 5px; background: rgba(255,255,255,0.1); border-radius: 3px; overflow: hidden;">
                                        <div style="width: ${wert2}%; height: 100%; background: var(--danger); border-radius: 3px;"></div>
                                    </div>
                                    <span style="font-size: 11px; color: var(--text-muted); min-width: 32px; text-align: right;">${wert2}</span>
                                </div>
                            </div>
                        </div>
                    `;
                });

                html += `
                        </div>
                        <div style="text-align: center; font-size: 11px; color: var(--text-muted); margin-top: 8px;">
                            ${konflikt.length} unterschiedliche PrioritÃ¤ten
                        </div>
                    </div>
                `;
            }

            return html;
        }

        // Navigate archetypes within Ti-Age Synthese Modal
        function navigateTiageSyntheseArchetype(person, direction) {
            const archetypes = archetypeOrder;
            let currentIndex;

            if (person === 'ich') {
                currentIndex = archetypes.indexOf(currentArchetype);
                currentIndex = (currentIndex + direction + archetypes.length) % archetypes.length;
                currentArchetype = archetypes[currentIndex];
                mobileIchArchetype = archetypes[currentIndex];

                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('ich', currentArchetype);
                }

                // Sync dropdowns
                const ichSelect = document.getElementById('ichSelect');
                const mobileIchSelect = document.getElementById('mobileIchSelect');
                if (ichSelect) ichSelect.value = currentArchetype;
                if (mobileIchSelect) mobileIchSelect.value = currentArchetype;

                // Sync archetype grid highlighting
                updateArchetypeGrid('ich', currentArchetype);
            } else {
                currentIndex = archetypes.indexOf(selectedPartner);
                currentIndex = (currentIndex + direction + archetypes.length) % archetypes.length;
                selectedPartner = archetypes[currentIndex];
                mobilePartnerArchetype = archetypes[currentIndex];

                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('partner', selectedPartner);
                }

                // Sync dropdowns
                const partnerSelect = document.getElementById('partnerSelect');
                const mobilePartnerSelect = document.getElementById('mobilePartnerSelect');
                if (partnerSelect) partnerSelect.value = selectedPartner;
                if (mobilePartnerSelect) mobilePartnerSelect.value = selectedPartner;

                // Sync archetype grid highlighting
                updateArchetypeGrid('partner', selectedPartner);
            }

            // Update the modal display
            const ichArch = archetypeDescriptions[currentArchetype];
            const partnerArch = archetypeDescriptions[selectedPartner];

            const ichDisplay = document.getElementById('tiageSyntheseModalIch');
            const partnerDisplay = document.getElementById('tiageSyntheseModalPartner');
            if (ichDisplay) ichDisplay.textContent = ichArch?.name || currentArchetype;
            if (partnerDisplay) partnerDisplay.textContent = partnerArch?.name || selectedPartner;

            // Regenerate content with new archetypes
            currentTiageSyntheseContent.pathos = generateCombinedPathos(ichArch, partnerArch);
            currentTiageSyntheseContent.logos = generateCombinedLogos(ichArch, partnerArch);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RESONANZFAKTOREN neu berechnen und in State speichern (VOR Content-Anzeige!)
            // Die Tabelle in getScoreContent() liest dann die gespeicherten Werte
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined' && typeof ResonanzCard.loadCalculatedValues === 'function') {
                const personKey = person === 'ich' ? 'ich' : 'partner';
                const newArchetype = person === 'ich' ? currentArchetype : selectedPartner;

                // Sammle Profil-Kontext fÃ¼r Resonanz-Berechnung
                let needs = null;

                // 1. Aus LoadedArchetypProfile.profileReview.flatNeeds (User-Eingaben!)
                const flatNeeds = window.LoadedArchetypProfile?.[personKey]?.profileReview?.flatNeeds;
                if (flatNeeds) {
                    needs = {};
                    if (Array.isArray(flatNeeds)) {
                        flatNeeds.forEach(n => {
                            if (n.id) needs[n.id] = n.value;
                            if (n.stringKey) needs[n.stringKey] = n.value;
                        });
                    } else {
                        for (const key in flatNeeds) {
                            if (flatNeeds.hasOwnProperty(key)) {
                                const entry = flatNeeds[key];
                                needs[key] = (typeof entry === 'object' && entry.value !== undefined) ? entry.value : entry;
                            }
                        }
                    }
                }

                // 2. Fallback: Aus AttributeSummaryCard
                if ((!needs || Object.keys(needs).length === 0) &&
                    typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.getFlatNeeds) {
                    const cardNeeds = AttributeSummaryCard.getFlatNeeds();
                    if (cardNeeds) {
                        needs = {};
                        if (Array.isArray(cardNeeds)) {
                            cardNeeds.forEach(n => {
                                if (n.id) needs[n.id] = n.value;
                                if (n.stringKey) needs[n.stringKey] = n.value;
                            });
                        }
                    }
                }

                // 3. Fallback: Standard-Werte des Archetyps
                if (!needs || Object.keys(needs).length === 0) {
                    if (typeof GfkBeduerfnisse !== 'undefined' &&
                        GfkBeduerfnisse.archetypProfile && GfkBeduerfnisse.archetypProfile[newArchetype]) {
                        needs = GfkBeduerfnisse.archetypProfile[newArchetype].umfrageWerte || {};
                    }
                }

                const resonanzProfileContext = {
                    archetyp: newArchetype,
                    needs: needs,
                    dominanz: personDimensions[personKey]?.dominanz || null,
                    orientierung: personDimensions[personKey]?.orientierung || null,
                    geschlecht: personDimensions[personKey]?.geschlecht || null
                };

                // Berechne und aktualisiere Resonanzfaktoren
                if (resonanzProfileContext.needs && Object.keys(resonanzProfileContext.needs).length > 0) {
                    const resonanzLoaded = ResonanzCard.loadCalculatedValues(resonanzProfileContext, personKey);
                    if (resonanzLoaded) {
                        // NOTE: LoadedArchetypProfile ist ein View auf TiageState.
                        // Nicht separat setzen - save() in setCalculatedValues hat TiageState bereits aktualisiert.
                        // Das wÃ¼rde sonst die Lock-Struktur {value, locked} mit nur Werten Ã¼berschreiben.
                        console.log('[TIAGE] Resonanzfaktoren nach Archetyp-Wechsel aktualisiert fÃ¼r', personKey + ':', newArchetype);
                    }
                }
            }

            // Refresh the displayed content (NACH Resonanzfaktoren-Update!)
            showTiageSyntheseContent(currentTiageSyntheseType);

            // Save to localStorage and update main view
            saveSelectionToStorage();
            if (typeof updateComparisonView === 'function') updateComparisonView();
            if (typeof updateMobileCardsContent === 'function') updateMobileCardsContent();

            // Update Score Cycle with new score
            updateSyntheseScoreCycle();
        }

        // Legacy alias
        function navigatePathosLogosArchetype(person, direction) {
            navigateTiageSyntheseArchetype(person, direction);
        }

        function getTiageTheoryContent() {
            return `
                <div style="space-y: 20px;">
                    <div style="margin-bottom: 20px;">
                        <h4 style="color: var(--primary); margin-bottom: 10px; font-size: 14px;">Die Synthese</h4>
                        <p style="margin-bottom: 10px;">Das Tiage-Beziehungsmodell verbindet zwei philosophische Traditionen zu einem praktischen Analyse-Tool:</p>
                        <ul style="padding-left: 20px; margin-bottom: 15px;">
                            <li style="margin-bottom: 6px;"><strong>Robert M. Pirsig (MOQ):</strong> Metaphysik der QualitÃ¤t â€“ statische vs. dynamische QualitÃ¤t als Grundstruktur</li>
                            <li style="margin-bottom: 6px;"><strong>OSHO:</strong> Bewusstsein durch Meditation â€“ PolaritÃ¤t, Balance, Schwingung</li>
                        </ul>
                    </div>

                    <div style="margin-bottom: 20px; padding: 15px; background: rgba(255,255,255,0.03); border-radius: 8px; border-left: 3px solid var(--primary);">
                        <h4 style="color: var(--text-primary); margin-bottom: 10px; font-size: 14px;">Logos vs. Pathos (25:75)</h4>
                        <p style="margin-bottom: 8px;"><strong style="color: var(--text-muted);">Logos (25%):</strong> Die rationale, strukturgebende Dimension. Pirsig nennt dies "statische QualitÃ¤t" â€“ bewÃ¤hrte Muster, die StabilitÃ¤t schaffen.</p>
                        <p><strong style="color: var(--text-muted);">Pathos (75%):</strong> Die emotionale, anziehende Dimension. "Pathos vor Logos" â€“ Das Leben/Erleben kommt vor der Interpretation.</p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="color: var(--primary); margin-bottom: 10px; font-size: 14px;">Tiage's Widerspruch zu Pirsig</h4>
                        <p style="margin-bottom: 10px;">Pirsig argumentierte, dass Definitionen die unmittelbare QualitÃ¤t des Erlebens zerstÃ¶ren.</p>
                        <p style="margin-bottom: 10px;"><strong>Diese App basiert auf der gegenteiligen Erfahrung:</strong></p>
                        <p style="font-style: italic; padding: 10px; background: rgba(255,255,255,0.03); border-radius: 6px;">"Definition und Erleben sind nicht getrennt. Sie entstehen gleichzeitig â€“ im Dialog, in Resonanz, in extremer KÃ¼rze."</p>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <h4 style="color: var(--primary); margin-bottom: 10px; font-size: 14px;">OSHO & Dialog als Meditation</h4>
                        <p style="margin-bottom: 10px;">OSHOs Philosophie verbindet sich mit Tiages Widerspruch:</p>
                        <ul style="padding-left: 20px;">
                            <li style="margin-bottom: 6px;"><strong>OSHO:</strong> "Worte kÃ¶nnen lebendig sein, wenn Bewusstheit dahinter steht."</li>
                            <li style="margin-bottom: 6px;"><strong>Tiage:</strong> Im bewussten Dialog <em>ist</em> die Definition das Erleben.</li>
                        </ul>
                        <p style="margin-top: 10px; font-style: italic; color: var(--text-muted);">Die QualitÃ¤t entsteht nicht trotz der Sprache, sondern durch sie â€“ wenn zwei Menschen auf derselben WellenlÃ¤nge schwingen.</p>
                    </div>

                    <div style="text-align: center; padding-top: 10px; border-top: 1px solid var(--border);">
                        <p style="font-size: 12px; color: var(--text-muted);">Tiage's Beitrag: Die Verbindung beider Philosophien zu einem konkreten Beziehungs-Rechner mit eigener Gewichtung (40:60 Logos:Pathos) und 6 Archetypen.</p>
                    </div>
                </div>
            `;
        }

        // Factor Modal Archetype Navigation
        let currentFactorType = null;
        let currentFactorSource = 'mobile';

        function navigateFactorArchetype(person, direction) {
            // Get current archetype for the person
            let currentArch;
            if (person === 'ich') {
                currentArch = mobileIchArchetype;
            } else {
                currentArch = mobilePartnerArchetype;
            }

            // Find current index and calculate new index
            let currentIdx = archetypeOrder.indexOf(currentArch);
            if (currentIdx === -1) currentIdx = 0;

            let newIndex = currentIdx + direction;
            if (newIndex < 0) newIndex = archetypeOrder.length - 1;
            if (newIndex >= archetypeOrder.length) newIndex = 0;

            const newArchetype = archetypeOrder[newIndex];

            // Update the actual selections and sync both mobile and desktop
            if (person === 'ich') {
                mobileIchArchetype = newArchetype;
                currentArchetype = newArchetype; // Sync desktop variable
                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('ich', newArchetype);
                    TiageState.saveToStorage(); // Sofort speichern
                }
                // Update mobile and desktop select elements
                const mobileSelect = document.getElementById('mobileIchSelect');
                const desktopSelect = document.getElementById('ichSelect');
                if (mobileSelect) mobileSelect.value = newArchetype;
                if (desktopSelect) desktopSelect.value = newArchetype;
            } else {
                mobilePartnerArchetype = newArchetype;
                selectedPartner = newArchetype; // Sync desktop variable
                // Sync with TiageState for persistence
                if (typeof TiageState !== 'undefined') {
                    TiageState.setArchetype('partner', newArchetype);
                    TiageState.saveToStorage(); // Sofort speichern
                }
                // Update mobile and desktop select elements
                const mobileSelect = document.getElementById('mobilePartnerSelect');
                const desktopSelect = document.getElementById('partnerSelect');
                if (mobileSelect) mobileSelect.value = newArchetype;
                if (desktopSelect) desktopSelect.value = newArchetype;
            }

            // Update the display in the modal
            updateFactorModalArchetypeDisplay();

            // Preserve selection state: sync Dominanz and Orientierung UI with stored state
            syncDominanzUI('ich');
            syncDominanzUI('partner');
            syncOrientierungUI('ich');
            syncOrientierungUI('partner');

            // Trigger full recalculation for both mobile and desktop views
            if (typeof updateComparisonView === 'function') {
                updateComparisonView();
            }
            if (typeof updateMobileResultPage === 'function') {
                updateMobileResultPage();
            }
            if (typeof updateMobileProContraPage === 'function') {
                updateMobileProContraPage();
            }

            // Recalculate and update the modal content after views are updated
            if (currentFactorType) {
                // Get updated score from display elements
                const prefix = currentFactorSource === 'desktop' ? 'desktopFactor' : 'mobileFactor';
                let score = 0;
                if (currentFactorType === 'archetyp') {
                    score = parseInt(document.getElementById(prefix + 'Archetyp')?.textContent) || 0;
                } else if (currentFactorType === 'dominanz') {
                    score = parseInt(document.getElementById(prefix + 'Dominanz')?.textContent) || 0;
                } else if (currentFactorType === 'orientierung') {
                    score = parseInt(document.getElementById(prefix + 'Orientierung')?.textContent) || 0;
                } else if (currentFactorType === 'geschlecht') {
                    score = parseInt(document.getElementById(prefix + 'Geschlecht')?.textContent) || 0;
                }

                const factor = factorExplanations[currentFactorType];
                if (factor) {
                    const ich = mobileIchArchetype;
                    const partner = mobilePartnerArchetype;
                    const dimensions = currentFactorSource === 'desktop' ? personDimensions : mobilePersonDimensions;

                    document.getElementById('factorModalScore').textContent = score;
                    document.getElementById('factorModalExplanation').textContent = factor.getExplanation(ich, partner, score, dimensions);

                    const meaningList = document.getElementById('factorModalMeaning');
                    meaningList.innerHTML = '';
                    factor.getMeaning(score, ich, partner).forEach(item => {
                        const li = document.createElement('li');
                        // Support both old (string) and new (object with title+desc) formats
                        if (typeof item === 'object' && item.title) {
                            li.innerHTML = `<strong>${item.title}</strong>${item.desc ? ` â€“ ${item.desc}` : ''}`;
                        } else {
                            li.textContent = item;
                        }
                        meaningList.appendChild(li);
                    });
                }
            }
        }

        function updateFactorModalArchetypeDisplay() {
            const ichCodeEl = document.getElementById('factorModalIchCode');
            const partnerCodeEl = document.getElementById('factorModalPartnerCode');

            if (ichCodeEl) {
                const ichDef = archetypeDescriptions[mobileIchArchetype];
                ichCodeEl.textContent = ichDef ? ichDef.name : mobileIchArchetype;
            }
            if (partnerCodeEl) {
                const partnerDef = archetypeDescriptions[mobilePartnerArchetype];
                partnerCodeEl.textContent = partnerDef ? partnerDef.name : mobilePartnerArchetype;
            }

            // Update combo code if visible
            const comboCodeEl = document.getElementById('factorModalComboCode');
            if (comboCodeEl && comboCodeEl.style.display !== 'none') {
                comboCodeEl.textContent = `Code: ${mobileIchArchetype}_${mobilePartnerArchetype}`;
            }
        }

        // Close modals with Escape key
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                const factorModal = document.getElementById('factorModal');
                if (factorModal && factorModal.classList.contains('active')) {
                    closeFactorModal();
                    return;
                }
                const helpModal = document.getElementById('helpModal');
                if (helpModal && helpModal.classList.contains('active')) {
                    closeHelpModal();
                    return;
                }
                const commentModal = document.getElementById('commentModal');
                if (commentModal && commentModal.classList.contains('active')) {
                    closeCommentModal();
                    return;
                }
            }
        });

        // ========================================
        // COMMENT MODAL FUNCTIONS
        // ========================================

        function openCommentModal() {
            document.getElementById('commentModal').classList.add('active');
            // Pre-fill name field with visitor number
            const visitorId = localStorage.getItem('tiage_visitor_id');
            if (visitorId) {
                document.getElementById('commentName').value = '#' + visitorId;
            }
            // Push state for back button to close modal
            history.pushState({ mobilePage: currentMobilePage, modal: 'comment' }, '', `#seite${currentMobilePage}-comment`);
        }

        function closeCommentModal(event, skipHistoryBack = false) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('commentModal').classList.remove('active');
            // Reset form
            document.getElementById('commentText').value = '';
            // Go back in history if not triggered by back button
            if (!skipHistoryBack && history.state && history.state.modal === 'comment') {
                history.back();
            }
        }

        async function submitComment() {
            const name = document.getElementById('commentName').value.trim();
            const typ = 'feedback'; // Default type since dropdown removed
            const text = document.getElementById('commentText').value.trim();

            // Rate limiting check
            const rateCheck = canSubmitComment();
            if (!rateCheck.allowed) {
                alert(`Bitte warte noch ${rateCheck.secondsRemaining} Sekunden bevor du einen weiteren Kommentar sendest.`);
                return;
            }

            // Validation
            if (!name) {
                alert('Bitte gib deinen Namen/KÃ¼rzel ein.');
                return;
            }
            if (name.length > 50) {
                alert('Name darf maximal 50 Zeichen haben.');
                return;
            }
            if (!text) {
                alert('Bitte schreibe einen Kommentar.');
                return;
            }
            if (text.length > 2000) {
                alert('Kommentar darf maximal 2000 Zeichen haben.');
                return;
            }

            // Get visitor ID
            const visitorId = getOrCreateVisitorId();

            const commentEntry = {
                type: 'comment',  // Wichtig fÃ¼r das Google Script
                id: 'com_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                visitorId: visitorId,
                name: name,
                kommentarTyp: typ,
                kommentar: text,
                timestamp: new Date().toISOString(),
                page: 'hilfe-modal'
            };

            const submitBtn = document.getElementById('commentSubmitBtn');
            submitBtn.disabled = true;
            submitBtn.textContent = 'Sende...';

            try {
                if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                    await fetch(GOOGLE_SCRIPT_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(commentEntry)
                    });
                }

                // Also save locally as backup
                const stored = JSON.parse(localStorage.getItem('tiage_comments') || '[]');
                stored.unshift(commentEntry);
                localStorage.setItem('tiage_comments', JSON.stringify(stored));

                // Record submission time for rate limiting
                recordCommentSubmission();

                alert('Danke fÃ¼r deinen Kommentar!');
                closeCommentModal();

            } catch (error) {
                console.error('Comment error:', error);
                // Save locally on error
                const stored = JSON.parse(localStorage.getItem('tiage_comments') || '[]');
                stored.unshift(commentEntry);
                localStorage.setItem('tiage_comments', JSON.stringify(stored));
                recordCommentSubmission();
                alert('Kommentar lokal gespeichert. (Server nicht erreichbar)');
                closeCommentModal();
            }

            submitBtn.disabled = false;
            submitBtn.textContent = 'Absenden';
        }

        // ========================================
        // COMMENTS LIST MODAL FUNCTIONS
        // ========================================

        let allCommentsData = [];
        let currentSearchQuery = '';

        function openCommentsListModal() {
            console.log('openCommentsListModal called');
            document.getElementById('commentsListModal').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Reset search field
            const searchInput = document.getElementById('commentsSearchInput');
            if (searchInput) searchInput.value = '';
            currentSearchQuery = '';
            const clearBtn = document.getElementById('commentsSearchClear');
            if (clearBtn) clearBtn.classList.remove('visible');
            const resultsDiv = document.getElementById('commentsSearchResults');
            if (resultsDiv) resultsDiv.style.display = 'none';

            loadAllComments();
        }

        function closeCommentsListModal(event) {
            if (event && event.target !== event.currentTarget) return;
            document.getElementById('commentsListModal').classList.remove('active');
            document.body.style.overflow = '';
        }

        async function loadAllComments() {
            const container = document.getElementById('commentsListBody');
            container.innerHTML = '<div class="no-comments"><div class="no-comments-icon">â³</div><p>Lade Kommentare...</p></div>';

            try {
                // Load from localStorage - nur eine Quelle: tiage_comments
                const localComments = JSON.parse(localStorage.getItem('tiage_comments') || '[]');

                // Deduplizierung basierend auf Name + Titel + Text
                const seen = new Set();
                const getUniqueKey = (item) => {
                    const name = (item.Name || item.name || '').toLowerCase().trim();
                    const titel = (item.Titel || item.titel || '').toLowerCase().trim();
                    const text = (item.Kommentar || item.kommentar || item.text || item.comment || '').toLowerCase().trim();
                    return `${name}|${titel}|${text}`;
                };

                allCommentsData = [];

                // Add local comments
                localComments.forEach(item => {
                    const key = getUniqueKey(item);
                    if (!seen.has(key)) {
                        seen.add(key);
                        allCommentsData.push(item);
                    }
                });

                // Try to load from server if available
                if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                    try {
                        const response = await fetch(GOOGLE_SCRIPT_URL);
                        const serverData = await response.json();
                        // Merge server data (avoiding duplicates)
                        serverData.forEach(item => {
                            const key = getUniqueKey(item);
                            if (!seen.has(key)) {
                                seen.add(key);
                                allCommentsData.push(item);
                            }
                        });
                    } catch (e) {
                        console.log('Server not available, using local data only');
                    }
                }

                // Sort by date (newest first)
                allCommentsData.sort((a, b) => {
                    const dateA = new Date(a.timestamp || a.Timestamp || a.datum || 0);
                    const dateB = new Date(b.timestamp || b.Timestamp || b.datum || 0);
                    return dateB - dateA;
                });

                renderCommentsList();
            } catch (error) {
                console.error('Error loading comments:', error);
                container.innerHTML = '<div class="no-comments"><div class="no-comments-icon">âŒ</div><p>Fehler beim Laden der Kommentare</p></div>';
            }
        }

        function renderCommentsList() {
            const container = document.getElementById('commentsListBody');

            if (allCommentsData.length === 0) {
                container.innerHTML = `
                    <div class="no-comments">
                        <div class="no-comments-icon">ğŸ’¬</div>
                        <p>Noch keine Kommentare vorhanden.</p>
                        <p style="font-size: 12px; margin-top: 10px;">Sei der Erste, der einen Kommentar hinterlÃ¤sst!</p>
                    </div>
                `;
                return;
            }

            // Separate main comments from replies
            const mainComments = allCommentsData.filter(c => !(c.AntwortAuf || c.antwortAuf || c.replyTo));
            const replies = allCommentsData.filter(c => (c.AntwortAuf || c.antwortAuf || c.replyTo));

            let html = '';

            mainComments.forEach((comment, index) => {
                const id = comment.id || comment.ID || `comment-${index}`;
                const name = comment.Name || comment.name || 'Anonym';
                const visitorId = comment.visitorId || comment.VisitorId || '';
                const titel = comment.Titel || comment.titel || comment.type || '';
                const text = comment.Kommentar || comment.kommentar || comment.text || comment.comment || '';
                const kontext = comment.KontextID || comment.kontextId || comment.context || '';
                const typ = comment.Typ || comment.typ || comment.kommentarTyp || comment.type || 'comment';
                const timestamp = comment.timestamp || comment.Timestamp || comment.datum;
                const date = timestamp ? formatCommentDate(timestamp) : '';

                // Find replies to this comment
                const commentReplies = replies.filter(r =>
                    (r.AntwortAuf || r.antwortAuf || r.replyTo) === id
                );

                html += `
                    <div class="comment-card" data-id="${id}">
                        <div class="comment-card-header">
                            <div>
                                <span class="comment-author">${escapeHtml(name)}</span>
                                ${visitorId ? `<span class="comment-visitor-id">#${escapeHtml(visitorId)}</span>` : ''}
                                <span class="comment-date">${date}</span>
                            </div>
                            <span class="comment-type-badge type-${typ || 'comment'}">${getTypeBadge(typ)}</span>
                        </div>
                        <div class="comment-card-body">
                            ${titel ? `<div class="comment-title">${escapeHtml(titel)}</div>` : ''}
                            <div class="comment-text">${escapeHtml(text)}</div>
                            ${kontext ? `<div class="comment-context">ğŸ“ Kontext: ${escapeHtml(kontext)}</div>` : ''}
                        </div>
                        ${commentReplies.length > 0 ? renderReplies(commentReplies) : ''}
                        <div class="comment-card-footer">
                            <span style="font-size: 11px; color: var(--text-muted);">${commentReplies.length} Antwort${commentReplies.length !== 1 ? 'en' : ''}</span>
                            <button class="reply-btn" onclick="toggleReplyForm('${id}')">â†© Antworten</button>
                        </div>
                        <div class="reply-form" id="reply-form-${id}">
                            <input type="text" id="reply-name-${id}" placeholder="Dein Name" style="width: 100%; padding: 8px; margin-bottom: 10px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                            <textarea id="reply-text-${id}" placeholder="Deine Antwort..."></textarea>
                            <div class="reply-form-buttons">
                                <button class="reply-cancel-btn" onclick="toggleReplyForm('${id}')">Abbrechen</button>
                                <button class="reply-submit-btn" onclick="submitReply('${id}')">Antworten</button>
                            </div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        function renderReplies(replies) {
            let html = '<div class="replies-section">';
            replies.forEach(reply => {
                const name = reply.Name || reply.name || 'Anonym';
                const text = reply.Kommentar || reply.kommentar || reply.text || '';
                const timestamp = reply.timestamp || reply.Timestamp;
                const date = timestamp ? formatCommentDate(timestamp) : '';

                html += `
                    <div class="reply-card">
                        <div class="reply-header">
                            <span class="reply-author">${escapeHtml(name)}</span>
                            <span class="reply-date">${date}</span>
                        </div>
                        <div class="reply-text">${escapeHtml(text)}</div>
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }

        // Convert wildcard pattern to regex
        function wildcardToRegex(pattern) {
            // Escape special regex characters except *
            const escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
            // Convert * to .* for wildcard matching
            const regex = escaped.replace(/\*/g, '.*');
            return new RegExp(regex, 'i'); // Case insensitive
        }

        // Check if a comment matches the search query
        function commentMatchesSearch(comment, query) {
            if (!query || query.trim() === '') return true;

            const searchPattern = wildcardToRegex(query.trim());

            // Get all searchable fields
            const name = comment.Name || comment.name || '';
            const titel = comment.Titel || comment.titel || comment.type || '';
            const text = comment.Kommentar || comment.kommentar || comment.text || comment.comment || '';
            const kontext = comment.KontextID || comment.kontextId || comment.context || '';
            const typ = comment.Typ || comment.typ || comment.kommentarTyp || comment.type || 'comment';
            const typLabel = getTypeBadge(typ);

            // Check if any field matches
            return searchPattern.test(name) ||
                   searchPattern.test(titel) ||
                   searchPattern.test(text) ||
                   searchPattern.test(kontext) ||
                   searchPattern.test(typ) ||
                   searchPattern.test(typLabel);
        }

        // Filter and render comments based on search query
        function filterComments(query) {
            currentSearchQuery = query;

            // Update clear button visibility
            const clearBtn = document.getElementById('commentsSearchClear');
            if (clearBtn) {
                clearBtn.classList.toggle('visible', query.length > 0);
            }

            renderFilteredComments();
        }

        // Clear search and show all comments
        function clearCommentsSearch() {
            const input = document.getElementById('commentsSearchInput');
            if (input) {
                input.value = '';
            }
            currentSearchQuery = '';

            const clearBtn = document.getElementById('commentsSearchClear');
            if (clearBtn) {
                clearBtn.classList.remove('visible');
            }

            const resultsDiv = document.getElementById('commentsSearchResults');
            if (resultsDiv) {
                resultsDiv.style.display = 'none';
            }

            renderCommentsList();
        }

        // Render comments with current filter applied
        function renderFilteredComments() {
            const container = document.getElementById('commentsListBody');
            const resultsDiv = document.getElementById('commentsSearchResults');

            if (!currentSearchQuery || currentSearchQuery.trim() === '') {
                if (resultsDiv) resultsDiv.style.display = 'none';
                renderCommentsList();
                return;
            }

            // Filter comments
            const filteredComments = allCommentsData.filter(c => commentMatchesSearch(c, currentSearchQuery));

            // Show results count
            if (resultsDiv) {
                resultsDiv.style.display = 'block';
                resultsDiv.innerHTML = `${filteredComments.length} von ${allCommentsData.length} Kommentare${filteredComments.length !== 1 ? 'n' : ''} gefunden`;
            }

            if (filteredComments.length === 0) {
                container.innerHTML = `
                    <div class="no-comments">
                        <div class="no-comments-icon">ğŸ”</div>
                        <p>Keine Kommentare gefunden.</p>
                        <p style="font-size: 12px; margin-top: 10px;">Versuche einen anderen Suchbegriff oder verwende * als Platzhalter.</p>
                    </div>
                `;
                return;
            }

            // Separate main comments from replies
            const mainComments = filteredComments.filter(c => !(c.AntwortAuf || c.antwortAuf || c.replyTo));
            const allReplies = allCommentsData.filter(c => (c.AntwortAuf || c.antwortAuf || c.replyTo));
            const filteredReplies = filteredComments.filter(c => (c.AntwortAuf || c.antwortAuf || c.replyTo));

            let html = '';

            // Render matching main comments
            mainComments.forEach((comment, index) => {
                const id = comment.id || comment.ID || `comment-${index}`;
                const name = comment.Name || comment.name || 'Anonym';
                const titel = comment.Titel || comment.titel || comment.type || '';
                const text = comment.Kommentar || comment.kommentar || comment.text || comment.comment || '';
                const kontext = comment.KontextID || comment.kontextId || comment.context || '';
                const typ = comment.Typ || comment.typ || comment.kommentarTyp || comment.type || 'comment';
                const timestamp = comment.timestamp || comment.Timestamp || comment.datum;
                const date = timestamp ? formatCommentDate(timestamp) : '';

                // Find all replies to this comment (not filtered)
                const commentReplies = allReplies.filter(r =>
                    (r.AntwortAuf || r.antwortAuf || r.replyTo) === id
                );

                html += `
                    <div class="comment-card" data-id="${id}">
                        <div class="comment-card-header">
                            <div>
                                <span class="comment-author">${highlightMatch(escapeHtml(name), currentSearchQuery)}</span>
                                <span class="comment-date">${date}</span>
                            </div>
                            <span class="comment-type-badge type-${typ || 'comment'}">${getTypeBadge(typ)}</span>
                        </div>
                        <div class="comment-card-body">
                            ${titel ? `<div class="comment-title">${highlightMatch(escapeHtml(titel), currentSearchQuery)}</div>` : ''}
                            <div class="comment-text">${highlightMatch(escapeHtml(text), currentSearchQuery)}</div>
                            ${kontext ? `<div class="comment-context">ğŸ“ Kontext: ${highlightMatch(escapeHtml(kontext), currentSearchQuery)}</div>` : ''}
                        </div>
                        ${commentReplies.length > 0 ? renderRepliesWithHighlight(commentReplies, currentSearchQuery) : ''}
                        <div class="comment-card-footer">
                            <span style="font-size: 11px; color: var(--text-muted);">${commentReplies.length} Antwort${commentReplies.length !== 1 ? 'en' : ''}</span>
                            <button class="reply-btn" onclick="toggleReplyForm('${id}')">â†© Antworten</button>
                        </div>
                        <div class="reply-form" id="reply-form-${id}">
                            <input type="text" id="reply-name-${id}" placeholder="Dein Name" style="width: 100%; padding: 8px; margin-bottom: 10px; background: var(--bg-dark); border: 1px solid var(--border); border-radius: 6px; color: var(--text-primary);">
                            <textarea id="reply-text-${id}" placeholder="Deine Antwort..."></textarea>
                            <div class="reply-form-buttons">
                                <button class="reply-cancel-btn" onclick="toggleReplyForm('${id}')">Abbrechen</button>
                                <button class="reply-submit-btn" onclick="submitReply('${id}')">Antworten</button>
                            </div>
                        </div>
                    </div>
                `;
            });

            // Also show replies that match but their parent doesn't
            const orphanReplies = filteredReplies.filter(reply => {
                const parentId = reply.AntwortAuf || reply.antwortAuf || reply.replyTo;
                return !mainComments.some(c => (c.id || c.ID) === parentId);
            });

            if (orphanReplies.length > 0) {
                html += `<div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid var(--border);">
                    <div style="font-size: 12px; color: var(--text-muted); margin-bottom: 10px;">Passende Antworten:</div>
                `;
                orphanReplies.forEach(reply => {
                    const name = reply.Name || reply.name || 'Anonym';
                    const text = reply.Kommentar || reply.kommentar || reply.text || '';
                    const timestamp = reply.timestamp || reply.Timestamp;
                    const date = timestamp ? formatCommentDate(timestamp) : '';

                    html += `
                        <div class="reply-card" style="margin-left: 0; background: var(--bg-secondary); padding: 12px; border-radius: 8px; margin-bottom: 10px;">
                            <div class="reply-header">
                                <span class="reply-author">${highlightMatch(escapeHtml(name), currentSearchQuery)}</span>
                                <span class="reply-date">${date}</span>
                            </div>
                            <div class="reply-text">${highlightMatch(escapeHtml(text), currentSearchQuery)}</div>
                        </div>
                    `;
                });
                html += '</div>';
            }

            container.innerHTML = html;
        }

        // Highlight matching text in search results
        function highlightMatch(text, query) {
            if (!query || query.trim() === '') return text;

            try {
                const pattern = wildcardToRegex(query.trim());
                return text.replace(pattern, match => `<span class="search-highlight">${match}</span>`);
            } catch (e) {
                return text;
            }
        }

        // Render replies with search highlighting
        function renderRepliesWithHighlight(replies, query) {
            let html = '<div class="replies-section">';
            replies.forEach(reply => {
                const name = reply.Name || reply.name || 'Anonym';
                const text = reply.Kommentar || reply.kommentar || reply.text || '';
                const timestamp = reply.timestamp || reply.Timestamp;
                const date = timestamp ? formatCommentDate(timestamp) : '';

                html += `
                    <div class="reply-card">
                        <div class="reply-header">
                            <span class="reply-author">${highlightMatch(escapeHtml(name), query)}</span>
                            <span class="reply-date">${date}</span>
                        </div>
                        <div class="reply-text">${highlightMatch(escapeHtml(text), query)}</div>
                    </div>
                `;
            });
            html += '</div>';
            return html;
        }

        function toggleReplyForm(commentId) {
            const form = document.getElementById(`reply-form-${commentId}`);
            if (form) {
                form.classList.toggle('active');
            }
        }

        async function submitReply(parentId) {
            const nameInput = document.getElementById(`reply-name-${parentId}`);
            const textInput = document.getElementById(`reply-text-${parentId}`);

            const name = nameInput?.value.trim() || 'Anonym';
            const text = textInput?.value.trim();

            if (!text) {
                alert('Bitte gib eine Antwort ein.');
                return;
            }

            const reply = {
                id: 'reply_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
                Name: name,
                Kommentar: text,
                AntwortAuf: parentId,
                timestamp: new Date().toISOString(),
                Typ: 'antwort'
            };

            // Save locally
            const stored = JSON.parse(localStorage.getItem('tiage_comments') || '[]');
            stored.push(reply);
            localStorage.setItem('tiage_comments', JSON.stringify(stored));

            // Try to save to server
            if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                try {
                    await fetch(GOOGLE_SCRIPT_URL, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(reply)
                    });
                } catch (e) {
                    console.log('Server save failed, reply saved locally');
                }
            }

            // Clear form and reload
            if (nameInput) nameInput.value = '';
            if (textInput) textInput.value = '';
            toggleReplyForm(parentId);

            // Reload comments
            loadAllComments();
        }

        function formatCommentDate(timestamp) {
            try {
                const date = new Date(timestamp);
                return date.toLocaleDateString('de-DE', {
                    day: '2-digit',
                    month: '2-digit',
                    year: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                });
            } catch (e) {
                return '';
            }
        }

        function getTypeBadge(typ) {
            const types = {
                'frage': 'Frage',
                'feedback': 'Comment',  // Feedback = Comment (vereinheitlicht)
                'fehler': 'Fehler',
                'verbesserung': 'Vorschlag',
                'doku': 'Doku',
                'antwort': 'Antwort',
                'comment': 'Comment'
            };
            return types[typ] || 'Comment';  // Default ist jetzt "Comment"
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ========================================
        // VISITOR ID & RATE LIMITING
        // ========================================

        // Browser fingerprinting for additional security
        function generateBrowserFingerprint() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            ctx.textBaseline = 'top';
            ctx.font = '14px Arial';
            ctx.fillText('TIAGE', 2, 2);
            const canvasHash = canvas.toDataURL().slice(-50);

            const fingerprint = {
                userAgent: navigator.userAgent,
                language: navigator.language,
                platform: navigator.platform,
                screenResolution: `${screen.width}x${screen.height}`,
                timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
                canvasHash: canvasHash
            };

            const fpString = JSON.stringify(fingerprint);
            let hash = 0;
            for (let i = 0; i < fpString.length; i++) {
                const char = fpString.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return 'FP' + Math.abs(hash).toString(36);
        }

        // Get or create a unique visitor ID
        function getOrCreateVisitorId() {
            return localStorage.getItem('tiage_visitor_id') || null;
        }

        // Get browser fingerprint
        function getBrowserFingerprint() {
            let fingerprint = localStorage.getItem('tiage_fingerprint');
            if (!fingerprint) {
                fingerprint = generateBrowserFingerprint();
                localStorage.setItem('tiage_fingerprint', fingerprint);
            }
            return fingerprint;
        }

        // LocalStorage backup for total visitors count
        function getCachedTotalVisitors() {
            const cached = localStorage.getItem('tiage_total_visitors');
            const timestamp = localStorage.getItem('tiage_total_visitors_timestamp');
            const maxAge = 5 * 60 * 1000; // 5 minutes

            if (cached && timestamp && (Date.now() - parseInt(timestamp)) < maxAge) {
                return parseInt(cached);
            }
            return null;
        }

        function setCachedTotalVisitors(total) {
            if (total !== null && total !== undefined) {
                localStorage.setItem('tiage_total_visitors', total.toString());
                localStorage.setItem('tiage_total_visitors_timestamp', Date.now().toString());
            }
        }

        // Retry logic with exponential backoff
        async function fetchWithRetry(url, options = {}, maxRetries = 3) {
            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const controller = new AbortController();
                    const timeout = setTimeout(() => controller.abort(), 10000); // 10s timeout

                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });

                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }

                    return await response.json();
                } catch (e) {
                    const isLastAttempt = attempt === maxRetries - 1;

                    if (isLastAttempt) {
                        console.log(`Fetch failed after ${maxRetries} attempts:`, e.message);
                        throw e;
                    }

                    // Exponential backoff: 1s, 2s, 4s
                    const delay = Math.pow(2, attempt) * 1000;
                    console.log(`Retry attempt ${attempt + 1} after ${delay}ms`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        // Fetch total visitors count from server with backup
        async function fetchTotalVisitors() {
            // Try cached value first
            const cached = getCachedTotalVisitors();

            if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                try {
                    const fingerprint = getBrowserFingerprint();
                    const data = await fetchWithRetry(
                        GOOGLE_SCRIPT_URL + '?action=getStats&fp=' + encodeURIComponent(fingerprint),
                        { method: 'GET' }
                    );

                    if (data.totalVisitors !== null && data.totalVisitors !== undefined) {
                        setCachedTotalVisitors(data.totalVisitors);
                        return data.totalVisitors;
                    }
                } catch (e) {
                    console.log('Could not fetch stats, using backup');
                }
            }

            // Return cached value as backup
            return cached;
        }

        // Fetch visitor ID from server or generate local fallback
        async function fetchOrCreateVisitorId() {
            let visitorId = localStorage.getItem('tiage_visitor_id');
            const fingerprint = getBrowserFingerprint();

            // Existing visitor - just fetch stats
            if (visitorId) {
                const total = await fetchTotalVisitors();
                return { visitorId, totalVisitors: total, fingerprint };
            }

            // Try to get new ID from server with retry logic
            if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                try {
                    const data = await fetchWithRetry(
                        GOOGLE_SCRIPT_URL + '?action=getVisitorId&fp=' + encodeURIComponent(fingerprint),
                        { method: 'GET' }
                    );

                    if (data.visitorId) {
                        visitorId = data.visitorId;
                        localStorage.setItem('tiage_visitor_id', visitorId);

                        // Cache total visitors count
                        if (data.totalVisitors !== null && data.totalVisitors !== undefined) {
                            setCachedTotalVisitors(data.totalVisitors);
                        }

                        return { visitorId, totalVisitors: data.totalVisitors || null, fingerprint };
                    }
                } catch (e) {
                    console.log('Server not available, using local ID');
                }
            }

            // Fallback: local generation
            const timestamp = Date.now().toString().slice(-4);
            const random = Math.floor(Math.random() * 100).toString().padStart(2, '0');
            visitorId = 'L' + timestamp + random; // L prefix = local
            localStorage.setItem('tiage_visitor_id', visitorId);

            // Try to use cached total visitors count
            const cachedTotal = getCachedTotalVisitors();
            return { visitorId, totalVisitors: cachedTotal, fingerprint };
        }

        // Format visitor display text
        function formatVisitorDisplay(visitorId, totalVisitors, pageViews) {
            let text = '#' + visitorId;
            if (totalVisitors && !visitorId.startsWith('L')) {
                text += ' von ' + totalVisitors;
            }
            if (pageViews) {
                text += ' (' + pageViews + ')';
            }
            return text;
        }

        // Track page view (bei jedem Seitenaufruf, auch fÃ¼r wiederkehrende Besucher)
        async function trackPageView() {
            if (typeof GOOGLE_SCRIPT_URL !== 'undefined' && GOOGLE_SCRIPT_URL) {
                try {
                    const fingerprint = getBrowserFingerprint();
                    const response = await fetch(
                        GOOGLE_SCRIPT_URL + '?action=trackPageView&fp=' + encodeURIComponent(fingerprint),
                        { method: 'GET' }
                    );
                    const data = await response.json();
                    return data.pageViews || null;
                } catch (e) {
                    // Silently ignore - page view tracking is not critical
                    console.log('PageView tracking failed:', e.message);
                    return null;
                }
            }
            return null;
        }

        // Initialize visitor ID display
        async function initVisitorId() {
            const { visitorId, totalVisitors } = await fetchOrCreateVisitorId();

            // Track page view and get updated count
            const pageViews = await trackPageView();

            const displayText = formatVisitorDisplay(visitorId, totalVisitors, pageViews);

            // Update comment form display
            const display = document.getElementById('visitorIdDisplay');
            if (display) {
                display.textContent = displayText;
            }
            // Update header display
            const headerDisplay = document.getElementById('headerVisitorId');
            if (headerDisplay) {
                headerDisplay.textContent = displayText;
            }
        }

        // Rate limiting for comments (1 per minute)
        const COMMENT_COOLDOWN_MS = 60000; // 60 seconds

        function canSubmitComment() {
            const lastSubmit = localStorage.getItem('tiage_last_comment_time');
            if (!lastSubmit) return { allowed: true };

            const elapsed = Date.now() - parseInt(lastSubmit);
            if (elapsed >= COMMENT_COOLDOWN_MS) {
                return { allowed: true };
            }

            const remaining = Math.ceil((COMMENT_COOLDOWN_MS - elapsed) / 1000);
            return { allowed: false, secondsRemaining: remaining };
        }

        function recordCommentSubmission() {
            localStorage.setItem('tiage_last_comment_time', Date.now().toString());
        }

        // ========================================
        // FEATURE 4: Archetype Info Modal (merged with definitionModal)
        // ========================================

        function openArchetypeInfo(archetypeId, person = null) {
            // Redirect to definitionModal (zusammengefÃ¼hrt)
            console.log('openArchetypeInfo called with:', archetypeId, 'person:', person);

            // Track which person this modal is for
            currentDefinitionPerson = person;

            // Update current index
            currentDefinitionIndex = archetypeOrder.indexOf(archetypeId);
            if (currentDefinitionIndex === -1) currentDefinitionIndex = 0;

            // Use the detailed definition modal
            showArchetypeInfoByType(archetypeId);

            document.getElementById('definitionModal').classList.add('active');
            document.body.style.overflow = 'hidden';

            // Add touch swipe support
            const modal = document.querySelector('#definitionModal .modal');
            modal.ontouchstart = handleDefinitionTouchStart;
            modal.ontouchend = handleDefinitionTouchEnd;
        }

        // ========================================
        // FEATURE 5: LocalStorage Persistence
        // ========================================

        function saveSelectionToStorage() {
            const selection = {
                ich: {
                    archetyp: mobileIchArchetype,
                    geschlecht: personDimensions.ich.geschlecht,
                    dominanz: personDimensions.ich.dominanz, // Multi-select object
                    orientierung: personDimensions.ich.orientierung // Multi-select object
                },
                partner: {
                    archetyp: mobilePartnerArchetype,
                    geschlecht: personDimensions.partner.geschlecht,
                    dominanz: personDimensions.partner.dominanz, // Multi-select object
                    orientierung: personDimensions.partner.orientierung // Multi-select object
                }
            };

            try {
                // TiageState als SSOT - selection und personDimensions speichern
                if (typeof TiageState !== 'undefined') {
                    TiageState.set('ui.selection', selection);
                    TiageState.set('personDimensions.ich', personDimensions.ich);
                    TiageState.set('personDimensions.partner', personDimensions.partner);
                    TiageState.saveToStorage();
                }
            } catch (e) {
                console.warn('TiageState not available:', e);
            }
        }

        function loadSelectionFromStorage() {
            try {
                // Lade von TiageState (SSOT) mit localStorage Fallback
                let selection = null;
                if (typeof TiageState !== 'undefined') {
                    selection = TiageState.get('ui.selection');
                }
                // Fallback: alte localStorage-Daten (werden bei loadFromStorage migriert)
                if (!selection) {
                    const saved = localStorage.getItem('tiage-selection');
                    if (!saved) return false;
                    selection = JSON.parse(saved);
                }
                if (!selection) return false;

                // Mapping von alten #A1-#A8 Keys zu neuen String-Keys
                const archetypeIdToKey = {
                    '#A1': 'single',
                    '#A2': 'duo',
                    '#A3': 'duo_flex',
                    '#A4': 'solopoly',
                    '#A5': 'polyamor',
                    '#A6': 'ra',
                    '#A7': 'lat',
                    '#A8': 'aromantisch'
                };
                const convertArchetypeId = (id) => {
                    if (!id) return id;
                    return archetypeIdToKey[id] || id;
                };

                // Restore ICH
                if (selection.ich) {
                    const ichArchetyp = convertArchetypeId(selection.ich.archetyp);
                    mobileIchArchetype = ichArchetyp;
                    currentArchetype = ichArchetyp;
                    document.getElementById('mobileIchSelect').value = ichArchetyp;
                    const ichSelect = document.getElementById('ichSelect');
                    if (ichSelect) ichSelect.value = ichArchetyp;

                    if (selection.ich.geschlecht) {
                        // Handle new primary/secondary format
                        if (typeof selection.ich.geschlecht === 'object' && 'primary' in selection.ich.geschlecht) {
                            // New format: { primary: 'cis-mann', secondary: null }
                            personDimensions.ich.geschlecht = selection.ich.geschlecht;
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.geschlecht = selection.ich.geschlecht;
                            }
                        } else {
                            // Old format: string like "cis-mann" - convert to new format
                            personDimensions.ich.geschlecht = { primary: selection.ich.geschlecht, secondary: null };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.geschlecht = { primary: selection.ich.geschlecht, secondary: null };
                            }
                        }
                        // Sync UI
                        if (typeof syncGeschlechtUI === 'function') {
                            syncGeschlechtUI('ich');
                        }
                        if (personDimensions.ich.geschlecht.primary) {
                            const dimension = document.querySelector('[data-dimension="ich-geschlecht-new"]');
                            if (dimension) dimension.classList.remove('needs-selection');
                        }
                    }

                    if (selection.ich.dominanz) {
                        // Handle new primary/secondary format
                        if (typeof selection.ich.dominanz === 'object' && 'primary' in selection.ich.dominanz) {
                            // New format: { primary: 'dominant', secondary: null }
                            personDimensions.ich.dominanz = selection.ich.dominanz;
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.dominanz = selection.ich.dominanz;
                            }
                            // Sync UI
                            if (typeof syncDominanzUI === 'function') {
                                syncDominanzUI('ich');
                            }
                            if (selection.ich.dominanz.primary) {
                                const dimension = document.querySelector('[data-dimension="ich-dominanz-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else if (typeof selection.ich.dominanz === 'object') {
                            // Old format: { dominant: 'gelebt', submissiv: null, ... }
                            // Convert to new format
                            let primary = null;
                            let secondary = null;
                            for (const [type, status] of Object.entries(selection.ich.dominanz)) {
                                if (status === 'gelebt' && !primary) {
                                    primary = type;
                                } else if (status === 'interessiert' && !secondary) {
                                    secondary = type;
                                }
                            }
                            personDimensions.ich.dominanz = { primary, secondary };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.dominanz = { primary, secondary };
                            }
                            // Sync UI
                            if (typeof syncDominanzUI === 'function') {
                                syncDominanzUI('ich');
                            }
                            if (primary) {
                                const dimension = document.querySelector('[data-dimension="ich-dominanz-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else {
                            // Legacy: string format - convert to new primary/secondary format
                            personDimensions.ich.dominanz = { primary: selection.ich.dominanz, secondary: null };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.dominanz = { primary: selection.ich.dominanz, secondary: null };
                            }
                            // Sync UI
                            if (typeof syncDominanzUI === 'function') {
                                syncDominanzUI('ich');
                            }
                            const dimension = document.querySelector('[data-dimension="ich-dominanz-multi"]');
                            if (dimension) dimension.classList.remove('needs-selection');
                        }
                    }

                    if (selection.ich.orientierung) {
                        // Handle new primary/secondary format
                        if (typeof selection.ich.orientierung === 'object' && 'primary' in selection.ich.orientierung) {
                            // New format: { primary: 'heterosexuell', secondary: null }
                            personDimensions.ich.orientierung = selection.ich.orientierung;
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.orientierung = selection.ich.orientierung;
                            }
                            // Sync UI
                            if (typeof syncOrientierungUI === 'function') {
                                syncOrientierungUI('ich');
                            }
                            if (selection.ich.orientierung.primary) {
                                const dimension = document.querySelector('[data-dimension="ich-orientierung-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else if (typeof selection.ich.orientierung === 'object') {
                            // Old format: { heterosexuell: 'gelebt', homosexuell: null, ... }
                            // Convert to new format
                            let primary = null;
                            let secondary = null;
                            for (const [type, status] of Object.entries(selection.ich.orientierung)) {
                                if (status === 'gelebt' && !primary) {
                                    primary = type;
                                } else if (status === 'interessiert' && !secondary) {
                                    secondary = type;
                                }
                            }
                            personDimensions.ich.orientierung = { primary, secondary };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.orientierung = { primary, secondary };
                            }
                            // Sync UI
                            if (typeof syncOrientierungUI === 'function') {
                                syncOrientierungUI('ich');
                            }
                            if (primary) {
                                const dimension = document.querySelector('[data-dimension="ich-orientierung-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else {
                            // Legacy: string format - convert to new primary/secondary format
                            personDimensions.ich.orientierung = { primary: selection.ich.orientierung, secondary: null };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.ich.orientierung = { primary: selection.ich.orientierung, secondary: null };
                            }
                            // Sync UI
                            if (typeof syncOrientierungUI === 'function') {
                                syncOrientierungUI('ich');
                            }
                            const dimension = document.querySelector('[data-dimension="ich-orientierung-multi"]');
                            if (dimension) dimension.classList.remove('needs-selection');
                        }
                    }
                }

                // Restore PARTNER
                if (selection.partner) {
                    const partnerArchetyp = convertArchetypeId(selection.partner.archetyp);
                    mobilePartnerArchetype = partnerArchetyp;
                    selectedPartner = partnerArchetyp;
                    document.getElementById('mobilePartnerSelect').value = partnerArchetyp;
                    const partnerSelect = document.getElementById('partnerSelect');
                    if (partnerSelect) partnerSelect.value = partnerArchetyp;

                    if (selection.partner.geschlecht) {
                        // Handle new primary/secondary format
                        if (typeof selection.partner.geschlecht === 'object' && 'primary' in selection.partner.geschlecht) {
                            // New format: { primary: 'cis-mann', secondary: null }
                            personDimensions.partner.geschlecht = selection.partner.geschlecht;
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.geschlecht = selection.partner.geschlecht;
                            }
                        } else {
                            // Old format: string like "cis-mann" - convert to new format
                            personDimensions.partner.geschlecht = { primary: selection.partner.geschlecht, secondary: null };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.geschlecht = { primary: selection.partner.geschlecht, secondary: null };
                            }
                        }
                        // Sync UI
                        if (typeof syncGeschlechtUI === 'function') {
                            syncGeschlechtUI('partner');
                        }
                        if (personDimensions.partner.geschlecht.primary) {
                            const dimension = document.querySelector('[data-dimension="partner-geschlecht-new"]');
                            if (dimension) dimension.classList.remove('needs-selection');
                        }
                    }

                    if (selection.partner.dominanz) {
                        // Handle new primary/secondary format
                        if (typeof selection.partner.dominanz === 'object' && 'primary' in selection.partner.dominanz) {
                            // New format: { primary: 'dominant', secondary: null }
                            personDimensions.partner.dominanz = selection.partner.dominanz;
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.dominanz = selection.partner.dominanz;
                            }
                            // Sync UI
                            if (typeof syncDominanzUI === 'function') {
                                syncDominanzUI('partner');
                            }
                            if (selection.partner.dominanz.primary) {
                                const dimension = document.querySelector('[data-dimension="partner-dominanz-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else if (typeof selection.partner.dominanz === 'object') {
                            // Old format: { dominant: 'gelebt', submissiv: null, ... }
                            // Convert to new format
                            let primary = null;
                            let secondary = null;
                            for (const [type, status] of Object.entries(selection.partner.dominanz)) {
                                if (status === 'gelebt' && !primary) {
                                    primary = type;
                                } else if (status === 'interessiert' && !secondary) {
                                    secondary = type;
                                }
                            }
                            personDimensions.partner.dominanz = { primary, secondary };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.dominanz = { primary, secondary };
                            }
                            // Sync UI
                            if (typeof syncDominanzUI === 'function') {
                                syncDominanzUI('partner');
                            }
                            if (primary) {
                                const dimension = document.querySelector('[data-dimension="partner-dominanz-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else {
                            // Legacy: string format - convert to new primary/secondary format
                            personDimensions.partner.dominanz = { primary: selection.partner.dominanz, secondary: null };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.dominanz = { primary: selection.partner.dominanz, secondary: null };
                            }
                            // Sync UI
                            if (typeof syncDominanzUI === 'function') {
                                syncDominanzUI('partner');
                            }
                            const dimension = document.querySelector('[data-dimension="partner-dominanz-multi"]');
                            if (dimension) dimension.classList.remove('needs-selection');
                        }
                    }

                    if (selection.partner.orientierung) {
                        // Handle new primary/secondary format
                        if (typeof selection.partner.orientierung === 'object' && 'primary' in selection.partner.orientierung) {
                            // New format: { primary: 'heterosexuell', secondary: null }
                            personDimensions.partner.orientierung = selection.partner.orientierung;
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.orientierung = selection.partner.orientierung;
                            }
                            // Sync UI
                            if (typeof syncOrientierungUI === 'function') {
                                syncOrientierungUI('partner');
                            }
                            if (selection.partner.orientierung.primary) {
                                const dimension = document.querySelector('[data-dimension="partner-orientierung-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else if (typeof selection.partner.orientierung === 'object') {
                            // Old format: { heterosexuell: 'gelebt', homosexuell: null, ... }
                            // Convert to new format
                            let primary = null;
                            let secondary = null;
                            for (const [type, status] of Object.entries(selection.partner.orientierung)) {
                                if (status === 'gelebt' && !primary) {
                                    primary = type;
                                } else if (status === 'interessiert' && !secondary) {
                                    secondary = type;
                                }
                            }
                            personDimensions.partner.orientierung = { primary, secondary };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.orientierung = { primary, secondary };
                            }
                            // Sync UI
                            if (typeof syncOrientierungUI === 'function') {
                                syncOrientierungUI('partner');
                            }
                            if (primary) {
                                const dimension = document.querySelector('[data-dimension="partner-orientierung-multi"]');
                                if (dimension) dimension.classList.remove('needs-selection');
                            }
                        } else {
                            // Legacy: string format - convert to new primary/secondary format
                            personDimensions.partner.orientierung = { primary: selection.partner.orientierung, secondary: null };
                            if (typeof mobilePersonDimensions !== 'undefined') {
                                mobilePersonDimensions.partner.orientierung = { primary: selection.partner.orientierung, secondary: null };
                            }
                            // Sync UI
                            if (typeof syncOrientierungUI === 'function') {
                                syncOrientierungUI('partner');
                            }
                            const dimension = document.querySelector('[data-dimension="partner-orientierung-multi"]');
                            if (dimension) dimension.classList.remove('needs-selection');
                        }
                    }
                }

                // Sync mobilePersonDimensions to personDimensions for desktop view
                personDimensions.ich = { ...mobilePersonDimensions.ich };
                personDimensions.partner = { ...mobilePersonDimensions.partner };

                // Sync all UIs (Desktop, Mobile, Modal) for dominanz
                if (typeof syncDominanzUI === 'function') {
                    syncDominanzUI('ich');
                    syncDominanzUI('partner');
                }

                // Sync all UIs (Desktop, Mobile, Modal) for orientierung
                if (typeof syncOrientierungUI === 'function') {
                    syncOrientierungUI('ich');
                    syncOrientierungUI('partner');
                }

                // Update comparison view with loaded data
                if (typeof updateComparisonView === 'function') {
                    updateComparisonView();
                }

                // Sync archetype grid highlighting with loaded selections
                if (typeof updateArchetypeGrid === 'function') {
                    if (selection.ich && selection.ich.archetyp) {
                        updateArchetypeGrid('ich', convertArchetypeId(selection.ich.archetyp));
                    }
                    if (selection.partner && selection.partner.archetyp) {
                        updateArchetypeGrid('partner', convertArchetypeId(selection.partner.archetyp));
                    }
                }

                return true;
            } catch (e) {
                console.warn('Failed to load from LocalStorage:', e);
                return false;
            }
        }

        function resetAll() {
            if (!confirm('MÃ¶chtest du wirklich alle Eingaben zurÃ¼cksetzen?')) {
                return;
            }

            // Clear TiageState selection (SSOT)
            try {
                if (typeof TiageState !== 'undefined') {
                    TiageState.set('ui.selection', null);
                }
            } catch (e) {
                console.warn('TiageState not available:', e);
            }

            // Reset mobile selections
            mobileIchArchetype = 'single';
            mobilePartnerArchetype = 'duo';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // PHASE 1: PROXY-LAYER MIGRATION
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Verwende TiageState.reset() statt direkter Zuweisung
            // GOD-Auswahl (personDimensions) bleibt erhalten!
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof TiageState !== 'undefined' && TiageState.reset) {
                TiageState.reset();
                console.log('[resetAll] TiageState reset durchgefÃ¼hrt');

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // FIX: Nach Reset flatNeeds und resonanzFaktoren neu berechnen
                // mit aktuellen GOD-Modifikatoren (falls vorhanden)
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                if (typeof ProfileCalculator !== 'undefined') {
                    ['ich', 'partner'].forEach(person => {
                        const archetyp = person === 'ich' ? 'single' : 'duo';
                        const profileData = {
                            archetyp: archetyp,
                            geschlecht: TiageState.get(`personDimensions.${person}.geschlecht`),
                            dominanz: TiageState.get(`personDimensions.${person}.dominanz`),
                            orientierung: TiageState.get(`personDimensions.${person}.orientierung`)
                        };
                        console.log(`[resetAll] Berechne Profil fÃ¼r ${person} mit GOD:`, JSON.stringify(profileData));
                        ProfileCalculator.loadProfile(person, profileData);

                        // FIX: Baseline mit berechneten flatNeeds synchronisieren
                        // Damit nach Reset nichts als "geÃ¤ndert" markiert ist
                        if (typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.syncBaselineWithFlatNeeds) {
                            AttributeSummaryCard.syncBaselineWithFlatNeeds(person, archetyp);
                        }
                    });
                    console.log('[resetAll] flatNeeds, resonanzFaktoren und Baseline neu berechnet mit GOD-Modifikatoren');
                }
            }

            // Reset dropdowns
            document.getElementById('mobileIchSelect').value = 'single';
            document.getElementById('mobilePartnerSelect').value = 'duo';

            // Reset all radio buttons
            document.querySelectorAll('.mobile-page input[type="radio"]').forEach(radio => {
                radio.checked = false;
                const dimension = radio.closest('.compact-dimension');
                if (dimension) {
                    dimension.classList.add('needs-selection');
                }
            });

            // Reset Desktop, Mobile and Modal multi-select checkboxes and status dropdowns
            const shortIds = ['dom', 'sub', 'sw', 'aus'];
            ['ich', 'partner'].forEach(person => {
                shortIds.forEach(shortId => {
                    // Desktop
                    const checkbox = document.getElementById(person + '-d-' + shortId);
                    if (checkbox) checkbox.checked = false;
                    const statusSelect = document.getElementById(person + '-d-' + shortId + '-status');
                    if (statusSelect) {
                        statusSelect.style.display = 'none';
                        statusSelect.value = 'gelebt';
                    }
                    // Mobile
                    const mobileCheckbox = document.getElementById('m-' + person + '-d-' + shortId);
                    if (mobileCheckbox) mobileCheckbox.checked = false;
                    const mobileStatusSelect = document.getElementById('m-' + person + '-d-' + shortId + '-status');
                    if (mobileStatusSelect) {
                        mobileStatusSelect.style.display = 'none';
                        mobileStatusSelect.value = 'gelebt';
                    }
                    // Modal
                    const modalCheckbox = document.getElementById('modal-' + person + '-d-' + shortId);
                    if (modalCheckbox) modalCheckbox.checked = false;
                    const modalStatusSelect = document.getElementById('modal-' + person + '-d-' + shortId + '-status');
                    if (modalStatusSelect) {
                        modalStatusSelect.style.display = 'none';
                        modalStatusSelect.value = 'gelebt';
                    }
                });
                // Mark dominanz as needing selection (Desktop, Mobile & Modal)
                const dimension = document.querySelector('[data-dimension="' + person + '-dominanz-multi"]');
                if (dimension) dimension.classList.add('needs-selection');
                const mobileDimension = document.querySelector('[data-dimension="mobile-' + person + '-dominanz-multi"]');
                if (mobileDimension) mobileDimension.classList.add('needs-selection');
                const modalDimension = document.querySelector('[data-dimension="modal-' + person + '-dominanz-multi"]');
                if (modalDimension) modalDimension.classList.add('needs-selection');

                // Mark orientierung as needing selection (Desktop, Mobile & Modal)
                const orientDimension = document.querySelector('[data-dimension="' + person + '-orientierung-multi"]');
                if (orientDimension) orientDimension.classList.add('needs-selection');
                const mobileOrientDimension = document.querySelector('[data-dimension="mobile-' + person + '-orientierung-multi"]');
                if (mobileOrientDimension) mobileOrientDimension.classList.add('needs-selection');
                const modalOrientDimension = document.querySelector('[data-dimension="modal-' + person + '-orientierung-multi"]');
                if (modalOrientDimension) modalOrientDimension.classList.add('needs-selection');
            });

            // Go to page 1
            mobileGoToPage(1);

            // Show confirmation
            const warning = document.createElement('div');
            warning.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: rgba(46, 204, 113, 0.95);
                color: white;
                padding: 15px 25px;
                border-radius: 10px;
                font-size: 14px;
                font-weight: 600;
                z-index: 9999;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            warning.textContent = 'âœ“ Alle Eingaben wurden zurÃ¼ckgesetzt';
            document.body.appendChild(warning);

            setTimeout(() => warning.remove(), 3000);
        }

        /**
         * LÃ¶scht die aktuelle Auswahl und setzt die UI zurÃ¼ck.
         * WICHTIG: Die gespeicherten Profile (Memory-Slots) bleiben erhalten!
         */
        function clearAllStorage() {
            const confirmMsg = TiageI18n && TiageI18n.currentLang === 'en'
                ? 'Reset current selection and UI?\n\nThis will remove:\nâ€¢ Current archetype selections\nâ€¢ Current dimension settings\nâ€¢ Current preferences\n\nSaved profiles (memory slots) will be PRESERVED!'
                : 'Aktuelle Auswahl und UI zurÃ¼cksetzen?\n\nDies entfernt:\nâ€¢ Aktuelle Archetyp-Auswahlen\nâ€¢ Aktuelle Dimensions-Einstellungen\nâ€¢ Aktuelle PrÃ¤ferenzen\n\nGespeicherte Profile (SpeicherplÃ¤tze) bleiben ERHALTEN!';

            if (!confirm(confirmMsg)) {
                return;
            }

            try {
                // Besucher-ID und Memory-Slots vor dem LÃ¶schen sichern
                const visitorId = localStorage.getItem('tiage_visitor_id');

                // Memory-Slots sichern (tiage_memory_ME001-004 und tiage_memory_PART001-004)
                const memorySlots = {};
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('tiage_memory_')) {
                        memorySlots[key] = localStorage.getItem(key);
                    }
                }

                // LÃ¶sche alle tiage_* EintrÃ¤ge AUSSER Memory-Slots
                const keysToDelete = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    if (key && key.startsWith('tiage') && !key.startsWith('tiage_memory_')) {
                        keysToDelete.push(key);
                    }
                }
                keysToDelete.forEach(key => localStorage.removeItem(key));

                // Besucher-ID wiederherstellen
                if (visitorId) {
                    localStorage.setItem('tiage_visitor_id', visitorId);
                }

                // Memory-Slots wiederherstellen
                Object.entries(memorySlots).forEach(([key, value]) => {
                    if (value) {
                        localStorage.setItem(key, value);
                    }
                });

                // Legacy Keys lÃ¶schen (Migration zu TiageState)
                localStorage.removeItem('tiage-selection');
                localStorage.removeItem('matchModalView');
                localStorage.removeItem('tiageSyntheseType');
                localStorage.removeItem('pathosLogosType');

                // TiageState UI-Settings zurÃ¼cksetzen
                if (typeof TiageState !== 'undefined') {
                    TiageState.set('ui.selection', null);
                    TiageState.set('ui.matchModalView', 'pathos');
                    TiageState.set('ui.syntheseType', 'score');
                }

                // Kurze BestÃ¤tigung anzeigen
                const toast = document.createElement('div');
                toast.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    background: linear-gradient(135deg, #10B981, #059669);
                    color: white;
                    padding: 20px 30px;
                    border-radius: 12px;
                    font-size: 16px;
                    font-weight: 600;
                    z-index: 99999;
                    box-shadow: 0 8px 24px rgba(0,0,0,0.4);
                    text-align: center;
                `;
                toast.innerHTML = TiageI18n && TiageI18n.currentLang === 'en'
                    ? 'âœ“ Selection cleared!<br><small>Saved profiles preserved. Reloading...</small>'
                    : 'âœ“ Auswahl gelÃ¶scht!<br><small>Profile erhalten. Lade neu...</small>';
                document.body.appendChild(toast);

                // Seite nach kurzer VerzÃ¶gerung neu laden
                setTimeout(() => {
                    window.location.reload();
                }, 1000);

            } catch (e) {
                console.error('[clearAllStorage] Fehler:', e);
                alert(TiageI18n && TiageI18n.currentLang === 'en'
                    ? 'Error clearing selection: ' + e.message
                    : 'Fehler beim ZurÃ¼cksetzen: ' + e.message);
            }
        }

        // Auto-save on changes
        function initAutoSave() {
            // Save on archetype change
            document.getElementById('mobileIchSelect')?.addEventListener('change', saveSelectionToStorage);
            document.getElementById('mobilePartnerSelect')?.addEventListener('change', saveSelectionToStorage);

            // Save on dimension change
            document.querySelectorAll('.mobile-page input[type="radio"]').forEach(radio => {
                radio.addEventListener('change', saveSelectionToStorage);
            });
        }

        // Load saved data on startup - fallback for legacy data
        // TiageState is now loaded in DOMContentLoaded, so we only need
        // to check for legacy 'tiage-selection' data if TiageState is empty
        setTimeout(() => {
            // Check if TiageState already has data (loaded in DOMContentLoaded)
            // v4.0: geschlecht is a direct string, not an object with .primary
            const hasStateData = typeof TiageState !== 'undefined' &&
                (TiageState.get('personDimensions.ich.geschlecht') ||
                 TiageState.get('personDimensions.partner.geschlecht') ||
                 TiageState.get('personDimensions.ich.dominanz.primary') ||
                 TiageState.get('personDimensions.partner.dominanz.primary'));

            // Only load from legacy storage if TiageState is empty
            if (!hasStateData) {
                loadSelectionFromStorage();
            }
            initAutoSave();
        }, 100); // Reduced timeout since DOMContentLoaded already loads TiageState

        // Update comparison view when data is loaded
        const originalLoadData = loadData;
        async function loadDataAndUpdateComparison() {
            await originalLoadData();
            setTimeout(() => {
                updateComparisonView();
                updateSyntheseScoreCycle();
            }, 100);
        }
        loadDataAndUpdateComparison();

        // Make key functions globally accessible for onclick handlers
        window.showArchetypeInfo = showArchetypeInfo;
        window.openArchetypeInfo = openArchetypeInfo;
        window.openFactorModal = openFactorModal;
        window.closeFactorModal = closeFactorModal;
        window.navigateFactorArchetype = navigateFactorArchetype;
        window.closeCategoryModal = closeCategoryModal;
        window.closeDefinitionModal = closeDefinitionModal;
        window.navigateDefinition = navigateDefinition;
        window.navigateDefinitionToIndex = navigateDefinitionToIndex;
        window.showArchetypeInfoByType = showArchetypeInfoByType;
        window.openCommentModal = openCommentModal;
        window.closeCommentModal = closeCommentModal;
        window.closeFeedbackModal = closeFeedbackModal;
        window.navigateArchetype = navigateArchetype;
        window.openCommentsListModal = openCommentsListModal;
        window.closeCommentsListModal = closeCommentsListModal;
        window.toggleReplyForm = toggleReplyForm;
        window.submitReply = submitReply;
        // Pro/Contra Modal functions
        window.openProContraModal = openProContraModal;
        window.closeProContraModal = closeProContraModal;
        window.navigateProContraArchetype = navigateProContraArchetype;

        // Archetype selection functions (critical for main page buttons)
        window.selectArchetypeFromGrid = selectArchetypeFromGrid;
        window.updateArchetypeGrid = updateArchetypeGrid;
        window.navigateArchetypeOnPage2 = navigateArchetypeOnPage2;
        window.navigateArchetypeOnPage3 = navigateArchetypeOnPage3;
        window.findBestPartnerMatch = findBestPartnerMatch;

        // AGOD Weight functions (for synthesis weight inputs)
        window.updateAgodWeight = updateAgodWeight;
        window.adjustAgodWeight = adjustAgodWeight;
        window.getAgodWeights = getAgodWeights;
        window.initAgodWeightInputs = initAgodWeightInputs;

        // Pathos/Logos Modal functions
        window.closePathosLogosModal = closePathosLogosModal;
        window.showPathosLogosContent = showPathosLogosContent;
        window.navigatePathosLogosArchetype = navigatePathosLogosArchetype;

        // Ti-Age Synthese Modal functions
        window.openTiageSyntheseModal = openTiageSyntheseModal;
        window.closeTiageSyntheseModal = closeTiageSyntheseModal;
        window.showTiageSyntheseContent = showTiageSyntheseContent;
        window.navigateTiageSyntheseArchetype = navigateTiageSyntheseArchetype;
        console.log('[TIAGE] openTiageSyntheseModal exported to window:', typeof window.openTiageSyntheseModal);

        // Additional modal functions for needs
        window.closeNeedsCompareModal = closeNeedsCompareModal;
        window.openNeedDefinitionModal = openNeedDefinitionModal;
        window.openNeedWithResonance = openNeedWithResonance;
        window.getResonanceDataForNeed = getResonanceDataForNeed;
        window.closeNeedDefinitionModal = closeNeedDefinitionModal;
        window.openGfkExplanationModal = openGfkExplanationModal;
        window.openPaarungExplanationModal = openPaarungExplanationModal;
        window.closePaarungExplanationModal = closePaarungExplanationModal;
        console.log('[NEEDS] Modal functions exported to window:', typeof window.openNeedDefinitionModal);

        // Needs comparison modal functions
        window.openNeedsFullModal = openNeedsFullModal;
        window.openNeedDefinitionModal = openNeedDefinitionModal;
        window.switchNeedsFullModalTab = switchNeedsFullModalTab;
        window.sortNeedsFullModal = sortNeedsFullModal;
        window.openGfkExplanationModal = openGfkExplanationModal;
        window.openPaarungExplanationModal = openPaarungExplanationModal;

        // Dimension toggle and collapse functions
        window.toggleAllDimensionsCollapse = toggleAllDimensionsCollapse;
        window.toggleDimensionCollapse = toggleDimensionCollapse;
        window.showDimensionTooltip = showDimensionTooltip;
        window.closeDimensionTooltip = closeDimensionTooltip;
        window.showGeschlechtInfoModal = showGeschlechtInfoModal;
        window.closeGeschlechtInfoModal = closeGeschlechtInfoModal;
        window.showDominanzInfoModal = showDominanzInfoModal;
        window.closeDominanzInfoModal = closeDominanzInfoModal;
        window.showOrientierungInfoModal = showOrientierungInfoModal;
        window.closeOrientierungInfoModal = closeOrientierungInfoModal;
        window.showBodySoulModal = showBodySoulModal;
        window.closeBodySoulModal = closeBodySoulModal;
        window.closeGfkExplanationModal = closeGfkExplanationModal;

        // Dimension click handlers
        window.handleGeschlechtClick = handleGeschlechtClick;
        window.handleGeschlechtPClick = handleGeschlechtPClick;
        window.handleGeschlechtSClick = handleGeschlechtSClick;
        window.handleDominanzClick = handleDominanzClick;
        window.handleOrientierungClick = handleOrientierungClick;
        window.handleGfkClick = handleGfkClick;

        // Mobile status toggle handlers (Gelebt/Interessiert buttons)
        window.handleDominanzStatusToggle = handleDominanzStatusToggle;
        window.handleOrientierungStatusToggle = handleOrientierungStatusToggle;
        window.syncMobileDominanzStatusButtons = syncMobileDominanzStatusButtons;
        window.syncMobileOrientierungStatusButtons = syncMobileOrientierungStatusButtons;

        // UI Sync functions (for MemoryManager)
        window.syncGeschlechtUI = syncGeschlechtUI;
        window.syncDominanzUI = syncDominanzUI;
        window.syncOrientierungUI = syncOrientierungUI;
        window.updateAll = updateAll;
        window.saveSelectionToStorage = saveSelectionToStorage;

        // State variables - HINWEIS: window.personDimensions und window.mobilePersonDimensions
        // werden jetzt in state.js als Proxy zu TiageState definiert.
        // Diese Zeilen sind nicht mehr nÃ¶tig (Proxy-Layer Migration Phase 1).

        // Pathos/Logos Modal open function
        window.openPathosLogosModal = openPathosLogosModal;

        // Comment and feedback functions
        window.submitComment = submitComment;
        window.clearCommentsSearch = clearCommentsSearch;

        // Partner selection
        window.selectPartner = selectPartner;

        // Navigation functions (for nav dots and carousel)
        window.navigatePrev = navigatePrev;
        window.navigateNext = navigateNext;
        window.scrollToCard = scrollToCard;

        // i18n translation update function (for language toggle button)
        window.updateAllTranslations = updateAllTranslations;

        // Additional modal functions
        window.openCategoryModal = openCategoryModal;
        window.openDefinitionModal = openDefinitionModal;
        window.openMatchModal = openMatchModal;

        // Category and tag related functions
        window.openSingleCategoryModal = openSingleCategoryModal;
        window.navigateCategoryPrev = navigateCategoryPrev;
        window.navigateCategoryNext = navigateCategoryNext;
        window.navigateCategoryArchetype = navigateCategoryArchetype;
        window.showCategoryDetails = showCategoryDetails;
        window.openTagTooltip = openTagTooltip;
        window.closeTagTooltip = closeTagTooltip;

        // Definition modal functions
        window.navigateDefinitionModal = navigateDefinitionModal;
        window.confirmDefinitionSelection = confirmDefinitionSelection;

        // Match modal functions
        window.toggleMatchModalView = toggleMatchModalView;

        // Feedback and reply functions
        window.openFeedbackModalWithContext = openFeedbackModalWithContext;
        window.openReplyModal = openReplyModal;

        // Pathos/Logos info functions
        window.toggleLogosWarning = toggleLogosWarning;
        window.showPathosLogosInfo = showPathosLogosInfo;
        window.showSubDimensionInfo = showSubDimensionInfo;

        // Mobile navigation functions
        window.mobileGoToPage = mobileGoToPage;
        window.toggleMobileCategory = toggleMobileCategory;

        // Utility functions
        window.toggleCollapsible = toggleCollapsible;
        window.resetAll = resetAll;

        // Wrapper functions for secondary interessiert buttons (used in modal)
        // These call the status toggle with 'interessiert' as the status
        window.handleSecondaryInteressiert = function(person, dominanzType, btn) {
            handleDominanzStatusToggle(person, dominanzType, 'interessiert', btn);
        };
        window.handleOrientierungSecondaryInteressiert = function(person, orientierungType, btn) {
            handleOrientierungStatusToggle(person, orientierungType, 'interessiert', btn);
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // PROFILE REVIEW MODAL - Funktionen
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        var profileReviewChangesCount = 0;
        var profileReviewInitialState = {};

        // Info-Daten fÃ¼r Attribute (Keys = attrIds aus profile-config.js)
        var profileReviewInfoData = {
            // GESCHLECHTSIDENTITÃ„T
            'pr-geschlecht-sekundaer': {
                title: "GeschlechtsidentitÃ¤t",
                stats: "Ca. 1-2% der BevÃ¶lkerung identifizieren sich als trans oder nonbinÃ¤r",
                research: '"Gender identity is a deeply personal sense of one\'s own gender, which may or may not align with sex assigned at birth." <i>(American Psychological Association, 2023)</i>',
                pirsig: "IdentitÃ¤t als dynamische QualitÃ¤t - das Selbst jenseits biologischer Muster entdecken.",
                osho: "Du bist nicht dein KÃ¶rper, du bist nicht dein Geist. Du bist das Bewusstsein, das beides beobachtet."
            },
            // LEBENSPLANUNG
            'pr-kinder': {
                title: "Kinder erwÃ¼nscht",
                stats: "75% der Duo-Menschen wollen Kinder",
                research: '"Monogamous couples show significantly higher desire for offspring due to stable pair-bonding patterns." <i>(Journal of Family Psychology, 2022)</i>',
                pirsig: "Static Pattern sucht Fortsetzung durch Nachkommen - die biologische Form der QualitÃ¤tserhaltung.",
                osho: "Kinder sind die BrÃ¼cke zwischen Liebe und Ewigkeit. Aber wahre Liebe braucht keine BrÃ¼cke."
            },
            'pr-ehe': {
                title: "Ehe erwÃ¼nscht",
                stats: "80% der Duo-Menschen wollen heiraten",
                research: '"Legal commitment correlates with relationship stability and long-term satisfaction in monogamous pairs." <i>(Marriage & Family Review, 2021)</i>',
                pirsig: "Die Ehe als statisches Muster institutionalisiert dynamische QualitÃ¤t - formalisiert die Liebe.",
                osho: "Ehe ist die Gesellschaft, die in dein Schlafzimmer eindringt. Aber manche brauchen die Form fÃ¼r den Inhalt."
            },
            'pr-zusammen': {
                title: "Zusammenleben",
                stats: "90% der Duo-Menschen leben zusammen",
                research: '"Co-habitation strengthens emotional bonds and daily intimacy in committed relationships." <i>(Journal of Social Psychology, 2020)</i>',
                pirsig: "Gemeinsamer physischer Raum verstÃ¤rkt das statische Muster - NÃ¤he durch PrÃ¤senz.",
                osho: "Zusammen schlafen ist leicht. Zusammen aufwachen ist die Kunst."
            },
            'pr-haustiere': {
                title: "Haustiere wichtig",
                stats: "50% der Paare haben Haustiere, 35% planen welche",
                research: '"Pet ownership increases relationship satisfaction and provides shared caregiving experience." <i>(AnthrozoÃ¶s Journal, 2021)</i>',
                pirsig: "Haustiere als Erweiterung des statischen Musters - gemeinsame Verantwortung.",
                osho: "Ein Hund lehrt bedingungslose Liebe. Menschen kÃ¶nnten davon lernen."
            },
            'pr-umzug': {
                title: "Umzugsbereitschaft",
                stats: "Duo-Menschen sind moderat flexibel (mittlere Umzugsbereitschaft)",
                research: '"Committed couples balance stability needs with career/life opportunities." <i>(Journal of Vocational Behavior, 2020)</i>',
                pirsig: "Balance zwischen statischem Muster (Verwurzelung) und dynamischer Anpassung.",
                osho: "Heimat ist nicht ein Ort - Heimat ist ein GefÃ¼hl."
            },
            'pr-familie': {
                title: "Familie-Wichtigkeit",
                stats: "Duo bewerten Familie als Ã¼berdurchschnittlich wichtig (70%)",
                research: '"Monogamous couples prioritize family connections and intergenerational bonds." <i>(Family Relations, 2020)</i>',
                pirsig: "Familie als erweitertes statisches Muster - ZugehÃ¶rigkeit Ã¼ber die Dyade hinaus.",
                osho: "Familie kann GefÃ¤ngnis oder FlÃ¼gel sein. Es kommt auf die Bewusstheit an."
            },
            // FINANZEN & KARRIERE
            'pr-finanzen': {
                title: "Finanzen",
                stats: "65% der Duo-Paare fÃ¼hren gemeinsame Konten",
                research: '"Financial merging correlates with relationship commitment and long-term stability." <i>(Journal of Consumer Finance, 2021)</i>',
                pirsig: "Gemeinsame Finanzen als Symbol fÃ¼r statisches Muster - materielle Verschmelzung.",
                osho: "Geld ist Energie. Wer teilt, vervielfacht."
            },
            'pr-karriere': {
                title: "Karriere vs. Familie",
                stats: "Duo suchen Balance zwischen Karriere und Familie (55% 'ausgeglichen')",
                research: '"Dual-career couples increasingly value work-life balance over pure career focus." <i>(Work & Occupations, 2021)</i>',
                pirsig: "Balance zwischen zwei statischen Mustern - Integration statt Polarisierung.",
                osho: "Arbeit und Liebe sind nicht GegensÃ¤tze. Beide sind Wege zu dir selbst."
            }
        };

        // Get selected archetype for a person (ich/partner)
        function getSelectedArchetype(person) {
            var selectId = person === 'ich' ? 'ichSelect' : 'partnerSelect';
            var select = document.getElementById(selectId);
            return select ? select.value : 'duo';
        }
        window.getSelectedArchetype = getSelectedArchetype;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GEWICHTUNGS-EINSTELLUNGEN - ausgelagert nach js/components/GewichtungCard.js
        // Alle Funktionen sind weiterhin Ã¼ber window.* verfÃ¼gbar (Legacy-KompatibilitÃ¤t)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Open Profile Review Modal
        // Hinweis: currentProfileReviewContext ist am Anfang der Datei definiert.
        // person: 'ich' oder 'partner' - wird benÃ¶tigt um Gender-Modifikatoren anzuwenden
        function openProfileReviewModal(archetypeKey, person) {
            console.log('[TIAGE] openProfileReviewModal called:', archetypeKey, person);
            var modal = document.getElementById('profileReviewModal');
            if (!modal) {
                console.log('[TIAGE] profileReviewModal not found!');
                return;
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Zeige Ladeindikator wÃ¤hrend Daten geladen werden
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzProfileHeaderCard !== 'undefined' && ResonanzProfileHeaderCard.setLoading) {
                ResonanzProfileHeaderCard.setLoading(true);
            }
            // Auch Modal-Card in Ladezustand versetzen
            var modalValuesContainer = document.getElementById('resonanzProfileModalValues');
            if (modalValuesContainer) {
                modalValuesContainer.classList.add('loading');
            }

            // Speichere Kontext fÃ¼r spÃ¤tere Neuladung bei Gender-Ã„nderung
            var previousPerson = currentProfileReviewContext.person;
            currentProfileReviewContext.archetypeKey = archetypeKey || 'duo';
            currentProfileReviewContext.person = person || 'ich';

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX v1.8.455: Person-spezifische Filter und Sortierung wiederherstellen
            // Bei Wechsel zwischen ICH/PARTNER werden Filter und Sort-Mode gespeichert/geladen
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            var newPerson = person || 'ich';
            if (previousPerson && previousPerson !== newPerson) {
                // FIX v1.8.687: CRITICAL - Speichere Daten der VORHERIGEN Person VOR dem Kontextwechsel
                // Ohne diesen Code gehen Resonanzfaktoren und BedÃ¼rfniswerte beim Tab-Wechsel verloren!
                if (typeof TiageState !== 'undefined' && TiageState.saveToStorage) {
                    TiageState.saveToStorage();
                    console.log('[ProfileReview] TiageState gespeichert vor Kontextwechsel von', previousPerson, 'zu', newPerson);
                }

                // Filter-State wechseln (DimensionKategorieFilter)
                if (typeof DimensionKategorieFilter !== 'undefined' && DimensionKategorieFilter.switchPerson) {
                    DimensionKategorieFilter.switchPerson(newPerson);
                    console.log('[ProfileReview] Filter-State gewechselt von', previousPerson, 'zu', newPerson);
                }
                // Sort-State wechseln (AttributeSummaryCard)
                if (typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.switchSortPerson) {
                    AttributeSummaryCard.switchSortPerson(newPerson);
                    console.log('[ProfileReview] Sort-State gewechselt von', previousPerson, 'zu', newPerson);
                }
            } else if (!previousPerson) {
                // Erster Aufruf: Initialisiere States fÃ¼r die Person
                if (typeof DimensionKategorieFilter !== 'undefined' && DimensionKategorieFilter.loadStateForPerson) {
                    DimensionKategorieFilter.loadStateForPerson(newPerson);
                }
                if (typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.loadSortModeForPerson) {
                    AttributeSummaryCard.loadSortModeForPerson(newPerson);
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // FIX v1.8.455: Lade BedÃ¼rfnisse UND gesperrte Werte aus TiageState
            // 1. flatNeeds.{person} = berechnete Werte
            // 2. profileReview.{person}.lockedNeeds = manuell gesperrte Werte (Ã¼berschreiben flatNeeds)
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof AttributeSummaryCard !== 'undefined') {
                try {
                    var loadedFromTiageState = false;

                    // PRIMÃ„R: Lade aus TiageState (Single Source of Truth)
                    if (typeof TiageState !== 'undefined') {
                        var tiageStateFlatNeeds = TiageState.get('flatNeeds.' + person);
                        var lockedNeeds = TiageState.getLockedNeeds ? TiageState.getLockedNeeds(person) : {};

                        if (tiageStateFlatNeeds && Object.keys(tiageStateFlatNeeds).length > 0) {
                            // FIX: Konvertiere zu Array-Format mit Lock-Status aus lockedNeeds
                            var needsArray = [];
                            Object.keys(tiageStateFlatNeeds).forEach(function(needId) {
                                var value = tiageStateFlatNeeds[needId];
                                var isLocked = lockedNeeds && lockedNeeds[needId] !== undefined;
                                // Wenn gesperrt, verwende den gesperrten Wert (Ã¼berschreibt flatNeeds)
                                var finalValue = isLocked ? lockedNeeds[needId] : value;

                                needsArray.push({
                                    id: needId,
                                    value: finalValue,
                                    locked: isLocked
                                });
                            });

                            if (AttributeSummaryCard.setFlatNeeds) {
                                AttributeSummaryCard.setFlatNeeds(needsArray);
                                // FIX v1.8.559: Synchronisiere Locks aus TiageState fÃ¼r korrekte Person
                                if (AttributeSummaryCard.syncLocksFromState) {
                                    AttributeSummaryCard.syncLocksFromState();
                                }
                                // Lade auch gelockte Hauptfragen
                                if (AttributeSummaryCard.loadLockedHauptfragen) {
                                    AttributeSummaryCard.loadLockedHauptfragen(person);
                                }
                                var lockedCount = Object.keys(lockedNeeds || {}).length;
                                console.log('[ProfileReview] BedÃ¼rfnisse aus TiageState geladen fÃ¼r', person, ':', needsArray.length, 'EintrÃ¤ge,', lockedCount, 'gesperrt');
                                loadedFromTiageState = true;
                            }
                        } else {
                            console.log('[ProfileReview] TiageState.flatNeeds.' + person + ' ist leer, versuche localStorage Fallback');
                        }
                    }

                    // FALLBACK: localStorage nur wenn TiageState leer
                    if (!loadedFromTiageState) {
                        var storedFlatNeeds = localStorage.getItem('tiage_flat_needs');
                        if (storedFlatNeeds) {
                            var parsedNeeds = JSON.parse(storedFlatNeeds);
                            if (AttributeSummaryCard.setFlatNeeds) {
                                AttributeSummaryCard.setFlatNeeds(parsedNeeds);
                                // FIX v1.8.559: Auch bei Fallback Locks synchronisieren
                                if (AttributeSummaryCard.syncLocksFromState) {
                                    AttributeSummaryCard.syncLocksFromState();
                                }
                                if (AttributeSummaryCard.loadLockedHauptfragen) {
                                    AttributeSummaryCard.loadLockedHauptfragen(person);
                                }
                                console.log('[ProfileReview] BedÃ¼rfnisse aus localStorage geladen (Fallback):', Object.keys(parsedNeeds).length, 'EintrÃ¤ge');
                            }
                        }
                    }
                } catch (e) {
                    console.warn('[ProfileReview] Fehler beim Laden der BedÃ¼rfnisse:', e);
                }
            }

            // Initialisiere Modal-Content dynamisch - FLACHE Darstellung ohne Kategorien
            if (typeof ProfileReviewRenderer !== 'undefined') {
                console.log('[TIAGE] ProfileReviewRenderer exists, initializing flat view...');
                // Hole Archetyp-Label fÃ¼r die flache Darstellung
                var archetypLabel = 'Profil';
                var archDef = typeof archetypeDefinitions !== 'undefined' ? archetypeDefinitions[archetypeKey || 'duo'] : null;
                if (archDef && archDef.name) {
                    archetypLabel = archDef.name;
                }
                ProfileReviewRenderer.initializeFlatModal(archetypeKey || 'duo', archetypLabel);
                console.log('[DEBUG] Step 0a: initializeFlatModal done');
            } else {
                console.log('[TIAGE] ProfileReviewRenderer NOT defined!');
            }
            console.log('[DEBUG] Step 0b: before loadGewichtungenIntoUI');

            // Lade Gewichtungen in UI
            loadGewichtungenIntoUI();
            console.log('[DEBUG] Step 1: loadGewichtungenIntoUI done');

            // Get archetype data
            archetypeKey = archetypeKey || 'duo';
            person = person || 'ich';
            var archetype = typeof archetypeDefinitions !== 'undefined' ? archetypeDefinitions[archetypeKey] : null;

            // Update badge mit Profil-Info
            var badge = document.getElementById('profileReviewBadge');
            if (badge) {
                if (person === 'ich') {
                    badge.textContent = 'Deine Profileinstellung';
                } else {
                    badge.textContent = 'Partner-Profileinstellung';
                }
            }

            // Versuche komponiertes Profil mit Gender-Modifikatoren zu laden
            var inferences = null;
            var personData = personDimensions[person];

            // Hole Dominanz und Orientierung (auch fÃ¼r Source-Explanation benÃ¶tigt)
            var dominanz = 'ausgeglichen';
            var orientierung = 'heterosexuell';

            if (personData) {
                if (personData.dominanz && personData.dominanz.primary) {
                    dominanz = personData.dominanz.primary;
                }
                if (personData.orientierung && personData.orientierung.primary) {
                    orientierung = personData.orientierung.primary;
                }
            }

            if (personData && personData.geschlecht &&
                personData.geschlecht.primary && personData.geschlecht.secondary &&
                typeof TiageProfileStore !== 'undefined') {

                // Komponiertes Profil mit allen Modifikatoren laden
                var composedProfile = TiageProfileStore.getProfileSync(
                    archetypeKey,
                    personData.geschlecht.primary,
                    personData.geschlecht.secondary,
                    dominanz,
                    orientierung
                );

                if (composedProfile && composedProfile.attributes) {
                    inferences = composedProfile.attributes;
                    console.log('[ProfileReview] Komponiertes Profil geladen:',
                        archetypeKey, personData.geschlecht.primary + '-' + personData.geschlecht.secondary);
                }
            }

            // Fallback: nur Archetyp-Defaults wenn kein Gender ausgewÃ¤hlt
            if (!inferences && archetype && archetype.defaultInferences) {
                inferences = archetype.defaultInferences;
                console.log('[ProfileReview] Fallback auf Archetyp-Defaults (kein vollstÃ¤ndiges Gender ausgewÃ¤hlt)');
            }

            // Update Source Explanation with current factors
            console.log('[DEBUG] Step 2: before updateSourceExplanation');
            updateSourceExplanation(archetypeKey, personData, dominanz, orientierung);
            console.log('[DEBUG] Step 3: after updateSourceExplanation');

            // Load default values from profile
            if (inferences) {

                // Toggle-Buttons
                setProfileBtnState('pr-kinder', inferences.kinderWunsch === 'ja');
                setProfileBtnState('pr-ehe', inferences.eheWunsch === 'ja');
                setProfileBtnState('pr-zusammen', inferences.wohnform === 'zusammen');
                setProfileBtnState('pr-haustiere', inferences.haustiere === 'ja' || inferences.haustiere === 'ja-gemeinsam' || inferences.haustiere === 'ja-eigene');

                // Hilfsfunktion: Numerischen Wert (0-1) auf Triple-Button-Wert (25/50/75) mappen
                function mapToTripleValue(numValue) {
                    if (numValue === undefined || numValue === null) return 50;
                    if (numValue <= 0.33) return 25;
                    if (numValue >= 0.67) return 75;
                    return 50;
                }

                // Triple-Buttons basierend auf numerischen Profil-Werten setzen
                // Diese Werte werden durch Gender-Modifikatoren beeinflusst!

                // Umzugsbereitschaft
                var umzugValue = 50;
                if (inferences.umzugsbereitschaft === 'sehr-flexibel') umzugValue = 75;
                else if (inferences.umzugsbereitschaft === 'flexibel') umzugValue = 75;
                else if (inferences.umzugsbereitschaft === 'verhandelbar') umzugValue = 50;
                else if (inferences.umzugsbereitschaft === 'nur-gemeinsam') umzugValue = 25;
                else if (inferences.umzugsbereitschaft === 'sesshaft') umzugValue = 25;
                setTripleBtnValue('pr-umzug', umzugValue);

                // Familie-Wichtigkeit (numerisch 0-1, beeinflusst durch Gender)
                setTripleBtnValue('pr-familie', mapToTripleValue(inferences.familieWichtigkeit));

                // Finanzen
                var finanzenValue = 50;
                if (inferences.finanzen === 'getrennt') finanzenValue = 25;
                else if (inferences.finanzen === 'hybrid') finanzenValue = 50;
                else if (inferences.finanzen === 'gemeinsam') finanzenValue = 75;
                setTripleBtnValue('pr-finanzen', finanzenValue);

                // Karriere-PrioritÃ¤t (numerisch 0-1)
                setTripleBtnValue('pr-karriere', mapToTripleValue(inferences.karrierePrioritaet));

                // KOMMUNIKATION - stark beeinflusst durch Gender-Untergruppen
                setTripleBtnValue('pr-gespraech', mapToTripleValue(inferences.gespraechsBeduernis));
                setTripleBtnValue('pr-emotional', mapToTripleValue(inferences.emotionaleOffenheit));
                setTripleBtnValue('pr-konflikt', mapToTripleValue(inferences.konfliktverhalten));

                // SOZIALES
                // IntroExtro: -1 = intro, 0 = ambivert, 1 = extro
                var introExtroValue = 50;
                if (typeof inferences.introExtro === 'number') {
                    if (inferences.introExtro <= -0.33) introExtroValue = 25;
                    else if (inferences.introExtro >= 0.33) introExtroValue = 75;
                } else if (inferences.introExtro === 'introvertiert') introExtroValue = 25;
                else if (inferences.introExtro === 'extrovertiert') introExtroValue = 75;
                setTripleBtnValue('pr-introextro', introExtroValue);

                setTripleBtnValue('pr-alleinzeit', mapToTripleValue(inferences.alleinZeitBeduernis));
                setTripleBtnValue('pr-freunde', mapToTripleValue(inferences.freundeskreis));

                // INTIMITÃ„T
                setTripleBtnValue('pr-naehe', mapToTripleValue(inferences.koerperlicheNaehe));
                setTripleBtnValue('pr-romantik', mapToTripleValue(inferences.romantikBeduernis));
                setTripleBtnValue('pr-sex', mapToTripleValue(inferences.sexFrequenz));

                // WERTE - beeinflusst durch Gender (z.B. traditionenWichtigkeit)
                setTripleBtnValue('pr-religion', mapToTripleValue(inferences.religiositaet));
                // traditionVsModern: niedrige traditionenWichtigkeit = modern (75), hohe = traditionell (25)
                var traditionValue = 50;
                if (typeof inferences.traditionenWichtigkeit === 'number') {
                    // Invertiert: hohe traditionenWichtigkeit â†’ traditionell (25), niedrige â†’ modern (75)
                    if (inferences.traditionenWichtigkeit >= 0.67) traditionValue = 25;
                    else if (inferences.traditionenWichtigkeit <= 0.33) traditionValue = 75;
                }
                setTripleBtnValue('pr-tradition', traditionValue);

                setTripleBtnValue('pr-umwelt', mapToTripleValue(inferences.umweltbewusstsein));
                setTripleBtnValue('pr-politik', mapToTripleValue(inferences.politischesInteresse));
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEU: Lade BedÃ¼rfniswerte aus composedProfile.needs in AttributeSummaryCard
            // Dies fÃ¼llt die Slider mit den echten Profil-Werten statt defaultValue 50
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (composedProfile && composedProfile.needs &&
                typeof AttributeSummaryCard !== 'undefined' &&
                AttributeSummaryCard.ATTRIBUTE_NEEDS_MAPPING) {

                console.log('[ProfileReview] Lade BedÃ¼rfniswerte aus composedProfile.needs (' + Object.keys(composedProfile.needs).length + ' BedÃ¼rfnisse)');

                // FÃ¼r jedes Attribut-Mapping die zugehÃ¶rigen Needs aus dem Profil setzen
                Object.keys(AttributeSummaryCard.ATTRIBUTE_NEEDS_MAPPING).forEach(function(attrId) {
                    var mapping = AttributeSummaryCard.ATTRIBUTE_NEEDS_MAPPING[attrId];
                    if (!mapping || !mapping.needs) return;

                    var needValues = {};
                    var foundCount = 0;

                    mapping.needs.forEach(function(needId) {
                        if (composedProfile.needs[needId] !== undefined) {
                            needValues[needId] = composedProfile.needs[needId];
                            foundCount++;
                        } else {
                            // Fallback auf 50 wenn BedÃ¼rfnis nicht im Profil definiert
                            needValues[needId] = 50;
                        }
                    });

                    // Nur setzen wenn mindestens ein Wert gefunden wurde
                    if (foundCount > 0) {
                        AttributeSummaryCard.setNeedsValues(attrId, needValues);
                    }
                });

                console.log('[ProfileReview] BedÃ¼rfniswerte geladen:', Object.keys(composedProfile.needs).length, 'BedÃ¼rfnisse');
            } else {
                console.log('[ProfileReview] Keine BedÃ¼rfniswerte verfÃ¼gbar (composedProfile.needs fehlt oder AttributeSummaryCard nicht geladen)');
            }

            // Load geschlechtsidentitÃ¤t from current main gender selection
            // KOPPLUNG: Nur wenn auf Hauptseite etwas ausgewÃ¤hlt ist, wird hier auch etwas ausgewÃ¤hlt
            if (typeof TiageState !== 'undefined') {
                var primaryGeschlecht = TiageState.getPrimaryGeschlecht(person);
                var secondaryGeschlecht = TiageState.getSecondaryGeschlecht(person);

                // Update geschlechtsidentitÃ¤t options + Auswahl basierend auf Hauptseite
                // Wenn secondaryGeschlecht null ist, wird keine Option aktiviert
                updateGeschlechtsidentitaetOptions(primaryGeschlecht, secondaryGeschlecht);

                if (primaryGeschlecht && secondaryGeschlecht) {
                    console.log('[ProfileReview] GeschlechtsidentitÃ¤t geladen:', primaryGeschlecht, '/', secondaryGeschlecht);
                } else {
                    console.log('[ProfileReview] GeschlechtsidentitÃ¤t: Keine Auswahl (Hauptseite nicht vollstÃ¤ndig)');
                }
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // RESONANZFAKTOREN: IMMER berechnen - gelockte Werte werden automatisch respektiert
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof ResonanzCard !== 'undefined') {
                var currentPerson = currentProfileReviewContext?.person || 'ich';

                // Bevorzuge recalculate() - es ist die modernere, einfachere Methode
                if (typeof ResonanzCard.recalculate === 'function') {
                    ResonanzCard.recalculate(currentPerson);
                    console.log('[ProfileReview] Resonanzfaktoren berechnet fÃ¼r', currentPerson);
                } else if (typeof ResonanzCard.loadCalculatedValues === 'function') {
                    // Fallback: Legacy loadCalculatedValues
                    var needs = ResonanzCard.getPersonNeeds
                        ? ResonanzCard.getPersonNeeds(currentPerson, archetypeKey || 'duo')
                        : null;

                    if (needs) {
                        var resonanzProfileContext = {
                            archetyp: archetypeKey || 'duo',
                            needs: needs,
                            dominanz: dominanz,
                            orientierung: orientierung,
                            geschlecht: personData ? personData.geschlecht : null
                        };
                        ResonanzCard.loadCalculatedValues(resonanzProfileContext, currentPerson);
                        console.log('[ProfileReview] Resonanzfaktoren berechnet fÃ¼r', currentPerson, '(legacy)');
                    }
                }
            }

            console.log('[DEBUG] Step 4: before reset changes counter');
            // Reset changes counter
            profileReviewChangesCount = 0;
            var badge = document.getElementById('profileReviewChangesBadge');
            if (badge) badge.style.display = 'none';

            // Save initial state
            console.log('[DEBUG] Step 5: before getProfileReviewState');
            profileReviewInitialState = getProfileReviewState();
            console.log('[DEBUG] Step 6: after getProfileReviewState');

            // Show modal
            console.log('[DEBUG] About to show modal, modal element:', modal);
            console.log('[DEBUG] modal.style before:', modal.style.display);
            modal.style.display = 'flex';
            modal.classList.add('active');
            console.log('[DEBUG] modal.style after:', modal.style.display, 'classes:', modal.className);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // Beende Ladeindikator nach kurzer VerzÃ¶gerung fÃ¼r visuelles Feedback
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            setTimeout(function() {
                if (typeof ResonanzProfileHeaderCard !== 'undefined' && ResonanzProfileHeaderCard.setLoading) {
                    ResonanzProfileHeaderCard.setLoading(false);
                }
                // Auch Modal-Card Ladezustand beenden
                var modalValuesContainer = document.getElementById('resonanzProfileModalValues');
                if (modalValuesContainer) {
                    modalValuesContainer.classList.remove('loading');
                }
                // Aktualisiere auch die Resonanz-Karte mit den richtigen Werten
                if (typeof ResonanzProfileHeaderCard !== 'undefined' && ResonanzProfileHeaderCard.update) {
                    ResonanzProfileHeaderCard.update();
                }
            }, 150);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // CLICK HANDLER FÃœR RA-PROFIL PERSPEKTIVEN
            // Beim Klicken auf eine Perspektive wird der entsprechende Resonanzfaktor in die Suche eingegeben
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            setTimeout(function() {
                var resonanzProfileCards = document.querySelectorAll('#resonanzProfileModalValues .resonanz-profile-value-item');
                if (resonanzProfileCards && resonanzProfileCards.length > 0) {
                    resonanzProfileCards.forEach(function(card) {
                        // Entferne alte Event-Listener falls vorhanden
                        var oldCard = card.cloneNode(true);
                        card.parentNode.replaceChild(oldCard, card);

                        // FÃ¼ge neuen Click-Handler hinzu
                        oldCard.addEventListener('click', function() {
                            // Extrahiere den Resonanzfaktor (R1, R2, R3, R4) aus dem Element
                            var resonanzIdElement = oldCard.querySelector('.resonanz-profile-value-id');
                            if (resonanzIdElement) {
                                var resonanzFaktor = resonanzIdElement.textContent.trim();

                                // PrÃ¼fe ob diese Karte bereits aktiv ist (Toggle-Verhalten)
                                var wasActive = oldCard.classList.contains('active');

                                // Entferne aktiven State von allen Perspektive-Karten
                                var allCards = document.querySelectorAll('#resonanzProfileModalValues .resonanz-profile-value-item');
                                allCards.forEach(function(c) {
                                    c.classList.remove('active');
                                });

                                // Finde das Suchfeld
                                var searchInput = document.getElementById('profileReviewSearchInput');

                                if (wasActive) {
                                    // Toggle: Wenn bereits aktiv, deaktiviere und leere die Suche
                                    if (searchInput) {
                                        searchInput.value = '';
                                        if (typeof clearProfileReviewSearch === 'function') {
                                            clearProfileReviewSearch();
                                        }
                                    }
                                    console.log('[ResonanzProfile] Perspektive deaktiviert:', resonanzFaktor);
                                } else {
                                    // Setze aktiven State auf diese Karte
                                    oldCard.classList.add('active');

                                    if (searchInput && typeof handleIntelligentSearch === 'function') {
                                        // Setze den Resonanzfaktor in das Suchfeld
                                        searchInput.value = resonanzFaktor;

                                        // Trigger die Suchfunktion
                                        handleIntelligentSearch(resonanzFaktor);

                                        // Fokussiere das Suchfeld fÃ¼r bessere UX
                                        searchInput.focus();

                                        console.log('[ResonanzProfile] Suche nach Resonanzfaktor:', resonanzFaktor);
                                    }
                                }
                            }
                        });

                        // FÃ¼ge hover-Stil hinzu um Klickbarkeit zu signalisieren
                        oldCard.style.cursor = 'pointer';
                    });
                    console.log('[ResonanzProfile] Click-Handler fÃ¼r', resonanzProfileCards.length, 'Perspektiven hinzugefÃ¼gt');
                }

                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                // FIX: Suchfeld Event-Listener direkt hinzufÃ¼gen
                // Das oninput-Attribut wird Ã¼berschrieben, daher expliziter Listener
                // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
                var searchInput = document.getElementById('profileReviewSearchInput');
                if (searchInput) {
                    console.log('[Search FIX] Adding input event listener to search field');

                    // Entferne alte Listener durch Klonen
                    var newSearchInput = searchInput.cloneNode(true);
                    searchInput.parentNode.replaceChild(newSearchInput, searchInput);

                    // Input Event
                    newSearchInput.addEventListener('input', function(e) {
                        var query = e.target.value;
                        console.log('[Search FIX] Input event, query:', query);
                        if (typeof handleIntelligentSearch === 'function') {
                            handleIntelligentSearch(query);
                        }
                    });

                    // Focus Event
                    newSearchInput.addEventListener('focus', function() {
                        if (typeof showSearchSuggestions === 'function') {
                            showSearchSuggestions();
                        }
                    });

                    // Keydown Event
                    newSearchInput.addEventListener('keydown', function(e) {
                        if (typeof handleSearchKeydown === 'function') {
                            handleSearchKeydown(e);
                        }
                    });

                    console.log('[Search FIX] Event listeners attached');
                }
            }, 100); // Kurzes Timeout um sicherzustellen dass DOM vollstÃ¤ndig gerendert ist
        }
        // DEPRECATED: Modal wurde durch needs-editor.html Seite ersetzt
        // window.openProfileReviewModal = openProfileReviewModal;

        // Close Profile Review Modal (DEPRECATED)
        function closeProfileReviewModal(event) {
            // PrÃ¼fe ob das Klick-Event auf dem Overlay selbst stattfand (nicht auf Kind-Elementen)
            if (event && event.target !== event.currentTarget) return;

            // ZusÃ¤tzliche PrÃ¼fung: Wenn innerhalb des Modal-Contents geklickt wurde, nicht schlieÃŸen
            if (event) {
                var modalContent = document.querySelector('.profile-review-modal');
                if (modalContent && modalContent.contains(event.target)) {
                    // Klick war innerhalb des Modal-Contents - nur Such-Dropdown schlieÃŸen
                    if (typeof hideSearchSuggestions === 'function') {
                        hideSearchSuggestions();
                    }
                    return;
                }
            }

            // FIX v1.8.687: CRITICAL - Speichere alle Ã„nderungen VOR dem SchlieÃŸen des Modals
            // Ohne diesen Code gehen Resonanzfaktoren und BedÃ¼rfniswerte verloren!
            if (typeof TiageState !== 'undefined' && TiageState.saveToStorage) {
                TiageState.saveToStorage();
                console.log('[closeProfileReviewModal] TiageState gespeichert vor Modal-Close');
            }

            var modal = document.getElementById('profileReviewModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('active');
            }
            // Clear search filter when closing modal
            if (typeof clearProfileReviewSearch === 'function') {
                clearProfileReviewSearch();
            }
        }
        // DEPRECATED: window.closeProfileReviewModal = closeProfileReviewModal;

        // Toggle Source Explanation Section (DEPRECATED)
        function toggleSourceExplanation() {
            var content = document.getElementById('sourceExplanationContent');
            var toggle = document.getElementById('sourceExplanationToggle');
            if (content && toggle) {
                content.classList.toggle('collapsed');
                toggle.classList.toggle('collapsed');
            }
        }
        // DEPRECATED: window.toggleSourceExplanation = toggleSourceExplanation;

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BEDÃœRFNIS SEARCH/FILTER FUNCTIONALITY
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Convert wildcard pattern to regex (* = any characters)
         * @param {string} pattern - Search pattern with * wildcards
         * @returns {RegExp} Regular expression for matching
         */
        function needWildcardToRegex(pattern) {
            // Escape special regex characters except *
            var escaped = pattern.replace(/[.+?^${}()|[\]\\]/g, '\\$&');
            // Convert * to .* for wildcard matching
            var regex = escaped.replace(/\*/g, '.*');
            return new RegExp(regex, 'i'); // Case insensitive
        }

        /**
         * Check if text matches all comma-separated criteria (AND logic)
         * @param {string} searchableText - Text to search in
         * @param {string} query - Comma-separated search criteria
         * @returns {boolean} True if ALL criteria match
         */
        function matchesAllCriteria(searchableText, query) {
            var criteria = query.split(',').map(function(c) { return c.trim(); }).filter(function(c) { return c.length > 0; });

            if (criteria.length === 0) return false;

            for (var i = 0; i < criteria.length; i++) {
                var pattern = needWildcardToRegex(criteria[i]);
                if (!pattern.test(searchableText)) {
                    return false;
                }
            }
            return true;
        }

        /**
         * Filter profile review modal by need name
         * @param {string} query - Search query (supports * wildcard)
         */
        function filterProfileReviewByNeed(query) {
            console.log('[Filter] filterProfileReviewByNeed called with query:', query);

            var searchWrapper = document.querySelector('.profile-review-search-wrapper');
            var hint = document.getElementById('profileReviewSearchHint');
            // SSOT: Suche zuerst im Modal-Container, dann Fallback auf flat-needs-container (needs-editor.html)
            var contentContainer = document.getElementById('profileReviewContent')
                || document.querySelector('.flat-needs-container')?.parentElement;

            console.log('[Filter] contentContainer found:', !!contentContainer);

            if (!contentContainer) return;

            // Toggle clear button visibility
            if (searchWrapper) {
                searchWrapper.classList.toggle('has-value', query && query.trim().length > 0);
            }

            // Reset hint classes
            if (hint) {
                hint.classList.remove('has-results', 'no-results');
            }

            // If empty query, show all and reset
            if (!query || query.trim() === '') {
                resetProfileReviewFilter();
                if (hint) hint.textContent = '';
                return;
            }

            var totalMatches = 0;
            var matchedAttributes = 0;

            // Check if we're in flat view mode (flat-needs-container present)
            var flatContainer = contentContainer.querySelector('.flat-needs-container');
            var isFlatView = !!flatContainer;

            console.log('[Filter] isFlatView:', isFlatView);

            if (isFlatView) {
                // FLAT VIEW: Search in flat-need-item elements
                var flatNeedItems = contentContainer.querySelectorAll('.flat-need-item');

                console.log('[Filter] Found flat need items:', flatNeedItems.length);

                flatNeedItems.forEach(function(needItem) {
                    var needLabel = needItem.querySelector('.flat-need-label');
                    if (!needLabel) return;

                    var labelText = needLabel.textContent || '';
                    var needId = needItem.getAttribute('data-need') || '';

                    // Collect all searchable text for this need
                    var searchableTexts = [labelText, needId];

                    if (typeof GfkBeduerfnisse !== 'undefined') {
                        var needDef = GfkBeduerfnisse.getDefinition
                            ? GfkBeduerfnisse.getDefinition(needId)
                            : GfkBeduerfnisse.definitionen[needId];
                        if (needDef) {
                            if (needDef.description) searchableTexts.push(needDef.description);
                            var kategorie = needDef.kategorie || '';
                            if (kategorie) searchableTexts.push(kategorie);

                            if (typeof TiageTaxonomie !== 'undefined') {
                                var katData = TiageTaxonomie.getKategorie
                                    ? TiageTaxonomie.getKategorie(kategorie)
                                    : null;
                                if (katData) {
                                    if (katData.label) searchableTexts.push(katData.label);
                                    if (katData.beschreibung) searchableTexts.push(katData.beschreibung);
                                    if (katData.id) searchableTexts.push(katData.id);
                                    if (katData.dimension) {
                                        var dimData = TiageTaxonomie.getDimension
                                            ? TiageTaxonomie.getDimension(katData.dimension)
                                            : null;
                                        if (dimData) {
                                            if (dimData.label) searchableTexts.push(dimData.label);
                                            if (dimData.beschreibung) searchableTexts.push(dimData.beschreibung);
                                            if (dimData.id) searchableTexts.push(dimData.id);
                                        }
                                    }
                                }
                            }
                        }
                    }

                    // Check if ALL comma-separated criteria match (AND logic)
                    var matches = matchesAllCriteria(searchableTexts.join(' '), query.trim());

                    // Toggle visibility and match class for flat view
                    needItem.classList.toggle('filter-hidden', !matches);
                    needItem.classList.toggle('filter-match', matches);

                    if (matches) {
                        totalMatches++;
                    }
                });

                console.log('[Filter] Total matches found:', totalMatches);

                // HAUPTFRAGEN-FILTER: Behandle hauptfrage-items separat
                // Unterscheide zwischen: Hauptfrage selbst matcht vs. nur Nuancen matchen
                var hauptfrageItems = contentContainer.querySelectorAll('.hauptfrage-item');
                hauptfrageItems.forEach(function(hauptfrageItem) {
                    var hauptfrageId = hauptfrageItem.getAttribute('data-hauptfrage-id') || '';
                    var hauptfrageLabel = hauptfrageItem.querySelector('.hauptfrage-label');
                    var hauptfrageLabelText = hauptfrageLabel ? hauptfrageLabel.textContent : '';

                    // Sammle searchable text fÃ¼r die Hauptfrage selbst
                    var hauptfrageSearchable = [hauptfrageLabelText, hauptfrageId];
                    if (typeof GfkBeduerfnisse !== 'undefined') {
                        var hfDef = GfkBeduerfnisse.getDefinition
                            ? GfkBeduerfnisse.getDefinition(hauptfrageId)
                            : GfkBeduerfnisse.definitionen[hauptfrageId];
                        if (hfDef) {
                            if (hfDef.description) hauptfrageSearchable.push(hfDef.description);
                            var kategorie = hfDef.kategorie || '';
                            if (kategorie) hauptfrageSearchable.push(kategorie);
                        }
                    }

                    // PrÃ¼fe ob Hauptfrage selbst matcht
                    var hauptfrageMatches = matchesAllCriteria(hauptfrageSearchable.join(' '), query.trim());

                    // PrÃ¼fe ob mindestens eine Nuance matcht (durch filter-match Klasse)
                    var nuancenList = hauptfrageItem.querySelector('.nuancen-list');
                    var hasMatchingNuancen = false;
                    if (nuancenList) {
                        hasMatchingNuancen = nuancenList.querySelectorAll('.flat-need-item.filter-match').length > 0;
                    } else {
                        // Nuancen-Liste nicht expandiert - prÃ¼fe via HauptfrageAggregation
                        if (typeof HauptfrageAggregation !== 'undefined') {
                            var hfData = HauptfrageAggregation.getHauptfragen()[hauptfrageId];
                            if (hfData && hfData.nuancen && hfData.nuancen.length > 0) {
                                for (var i = 0; i < hfData.nuancen.length; i++) {
                                    var nuanceId = hfData.nuancen[i];
                                    var nuanceSearchable = [nuanceId];
                                    // Hole Nuance-Label
                                    if (window.BeduerfnisIds && window.BeduerfnisIds.beduerfnisse) {
                                        var nuanceData = window.BeduerfnisIds.beduerfnisse[nuanceId];
                                        if (nuanceData && nuanceData.label) {
                                            nuanceSearchable.push(nuanceData.label);
                                        }
                                    }
                                    if (matchesAllCriteria(nuanceSearchable.join(' '), query.trim())) {
                                        hasMatchingNuancen = true;
                                        break;
                                    }
                                }
                            }
                        }
                    }

                    // Hauptfrage anzeigen wenn: sie selbst matcht ODER mindestens eine Nuance matcht
                    var showHauptfrage = hauptfrageMatches || hasMatchingNuancen;

                    hauptfrageItem.classList.toggle('filter-hidden', !showHauptfrage);
                    hauptfrageItem.classList.toggle('filter-match', hauptfrageMatches);
                    hauptfrageItem.classList.toggle('has-matching-nuancen', hasMatchingNuancen && !hauptfrageMatches);
                });

                // In flat view, count visible items as "matched attributes"
                matchedAttributes = totalMatches > 0 ? 1 : 0;

            } else {
                // CARD VIEW: Original behavior with attribute-summary-card
                var cards = contentContainer.querySelectorAll('.attribute-summary-card');
                var categories = contentContainer.querySelectorAll('.profile-review-category');

                // First pass: check each card for matching needs
                cards.forEach(function(card) {
                    var needItems = card.querySelectorAll('.attribute-need-item');
                    var cardHasMatch = false;

                    needItems.forEach(function(needItem) {
                        var needLabel = needItem.querySelector('.attribute-need-label');
                        if (!needLabel) return;

                        var labelText = needLabel.textContent || '';
                        var needId = needItem.getAttribute('data-need') || '';

                        // Collect all searchable text for this need
                        var searchableTexts = [labelText, needId];

                        if (typeof GfkBeduerfnisse !== 'undefined') {
                            var needDef = GfkBeduerfnisse.getDefinition
                                ? GfkBeduerfnisse.getDefinition(needId)
                                : GfkBeduerfnisse.definitionen[needId];
                            if (needDef) {
                                if (needDef.description) searchableTexts.push(needDef.description);
                                var kategorie = needDef.kategorie || '';
                                if (kategorie) searchableTexts.push(kategorie);

                                if (typeof TiageTaxonomie !== 'undefined') {
                                    var katData = TiageTaxonomie.getKategorie
                                        ? TiageTaxonomie.getKategorie(kategorie)
                                        : null;
                                    if (katData) {
                                        if (katData.label) searchableTexts.push(katData.label);
                                        if (katData.beschreibung) searchableTexts.push(katData.beschreibung);
                                        if (katData.id) searchableTexts.push(katData.id);
                                        if (katData.dimension) {
                                            var dimData = TiageTaxonomie.getDimension
                                                ? TiageTaxonomie.getDimension(katData.dimension)
                                                : null;
                                            if (dimData) {
                                                if (dimData.label) searchableTexts.push(dimData.label);
                                                if (dimData.beschreibung) searchableTexts.push(dimData.beschreibung);
                                                if (dimData.id) searchableTexts.push(dimData.id);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        // Check if ALL comma-separated criteria match (AND logic)
                        var matches = matchesAllCriteria(searchableTexts.join(' '), query.trim());

                        // Toggle match class
                        needItem.classList.toggle('filter-match', matches);

                        if (matches) {
                            cardHasMatch = true;
                            totalMatches++;
                        }
                    });

                    // Show/hide card and auto-expand if has matches
                    card.classList.toggle('filter-hidden', !cardHasMatch);
                    card.classList.toggle('has-filter-match', cardHasMatch);

                    if (cardHasMatch) {
                        matchedAttributes++;
                        // Expand the needs list to show matches
                        var needsList = card.querySelector('.attribute-summary-needs-list');
                        if (needsList) {
                            needsList.classList.remove('collapsed');
                        }
                    }
                });

                // Second pass: hide categories with no visible cards
                categories.forEach(function(category) {
                    var visibleCards = category.querySelectorAll('.attribute-summary-card:not(.filter-hidden)');
                    category.classList.toggle('filter-hidden', visibleCards.length === 0);

                    // Update item count badge if present
                    var badge = category.querySelector('.category-item-count');
                    if (badge && visibleCards.length > 0) {
                        badge.textContent = '(' + visibleCards.length + ')';
                    }
                });
            }

            // Update hint
            if (hint) {
                if (totalMatches > 0) {
                    if (isFlatView) {
                        hint.textContent = totalMatches + ' BedÃ¼rfnis' + (totalMatches !== 1 ? 'se' : '') + ' gefunden';
                    } else {
                        hint.textContent = totalMatches + ' BedÃ¼rfnis' + (totalMatches !== 1 ? 'se' : '') +
                                          ' in ' + matchedAttributes + ' Attribut' + (matchedAttributes !== 1 ? 'en' : '') +
                                          ' gefunden';
                    }
                    hint.classList.add('has-results');
                } else {
                    hint.textContent = 'Keine BedÃ¼rfnisse gefunden. Tipp: Verwende * als Platzhalter (z.B. *kind*) - sucht in #B, #K, #D, #P';
                    hint.classList.add('no-results');
                }
            }

            // Update subtitle with filtered count (FIX: #859)
            if (isFlatView) {
                var subtitle = contentContainer.querySelector('.flat-needs-subtitle');
                if (subtitle) {
                    var allFlatItems = contentContainer.querySelectorAll('.flat-need-item');
                    var totalNeeds = allFlatItems.length;
                    var visibleNeeds = contentContainer.querySelectorAll('.flat-need-item:not(.filter-hidden)').length;

                    // Get archetype label from AttributeSummaryCard or extract from subtitle
                    var archetypLabel = (typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.getCurrentArchetypLabel)
                        ? AttributeSummaryCard.getCurrentArchetypLabel()
                        : null;
                    if (!archetypLabel) {
                        var currentText = subtitle.textContent || '';
                        var archetypMatch = currentText.match(/Dein\s+(\S+)-Profil/);
                        archetypLabel = archetypMatch ? archetypMatch[1] : 'Profil';
                    }

                    if (query && query.trim() !== '' && visibleNeeds < totalNeeds) {
                        subtitle.textContent = 'Dein ' + archetypLabel + '-Profil (' + visibleNeeds + ' von ' + totalNeeds + ' BedÃ¼rfnissen)';
                    } else {
                        subtitle.textContent = 'Dein ' + archetypLabel + '-Profil (' + totalNeeds + ' BedÃ¼rfnisse)';
                    }
                }
            }
        }
        window.filterProfileReviewByNeed = filterProfileReviewByNeed;

        /**
         * Reset all filter states
         */
        function resetProfileReviewFilter() {
            // SSOT: Suche zuerst im Modal-Container, dann Fallback auf flat-needs-container (needs-editor.html)
            var contentContainer = document.getElementById('profileReviewContent')
                || document.querySelector('.flat-needs-container')?.parentElement;
            if (!contentContainer) return;

            // Remove all filter classes
            var hiddenElements = contentContainer.querySelectorAll('.filter-hidden');
            hiddenElements.forEach(function(el) {
                el.classList.remove('filter-hidden');
            });

            var matchedCards = contentContainer.querySelectorAll('.has-filter-match');
            matchedCards.forEach(function(el) {
                el.classList.remove('has-filter-match');
            });

            var matchedNeeds = contentContainer.querySelectorAll('.filter-match');
            matchedNeeds.forEach(function(el) {
                el.classList.remove('filter-match');
            });

            // Remove has-matching-nuancen class from hauptfrage-items
            var nuancenMatchItems = contentContainer.querySelectorAll('.has-matching-nuancen');
            nuancenMatchItems.forEach(function(el) {
                el.classList.remove('has-matching-nuancen');
            });

            // Collapse all expanded needs lists (restore original state)
            var expandedLists = contentContainer.querySelectorAll('.attribute-summary-needs-list:not(.collapsed)');
            expandedLists.forEach(function(list) {
                // Only collapse if it was auto-expanded by filter
                var card = list.closest('.attribute-summary-card');
                if (card && !card.classList.contains('user-expanded')) {
                    list.classList.add('collapsed');
                }
            });

            // Restore original category counts
            var categories = contentContainer.querySelectorAll('.profile-review-category');
            categories.forEach(function(category) {
                var totalCards = category.querySelectorAll('.attribute-summary-card').length;
                var badge = category.querySelector('.category-item-count');
                if (badge) {
                    badge.textContent = '(' + totalCards + ')';
                }
            });

            // Reset subtitle to show total count (FIX: #859)
            var subtitle = contentContainer.querySelector('.flat-needs-subtitle');
            if (subtitle) {
                var allFlatItems = contentContainer.querySelectorAll('.flat-need-item');
                var totalNeeds = allFlatItems.length;

                // Get archetype label from AttributeSummaryCard or extract from subtitle
                var archetypLabel = (typeof AttributeSummaryCard !== 'undefined' && AttributeSummaryCard.getCurrentArchetypLabel)
                    ? AttributeSummaryCard.getCurrentArchetypLabel()
                    : null;
                if (!archetypLabel) {
                    var currentText = subtitle.textContent || '';
                    var archetypMatch = currentText.match(/Dein\s+(\S+)-Profil/);
                    archetypLabel = archetypMatch ? archetypMatch[1] : 'Profil';
                }

                subtitle.textContent = 'Dein ' + archetypLabel + '-Profil (' + totalNeeds + ' BedÃ¼rfnisse)';
            }
        }
        window.resetProfileReviewFilter = resetProfileReviewFilter;

        /**
         * Clear search input and reset filter
         */
        function clearProfileReviewSearch() {
            var input = document.getElementById('profileReviewSearchInput');
            if (input) {
                input.value = '';
                input.focus();
            }
            resetProfileReviewFilter();

            // LÃ¶sche auch die aktive Suggestion
            if (typeof suggestionState !== 'undefined') {
                suggestionState.activeSuggestion = null;
            }

            var hint = document.getElementById('profileReviewSearchHint');
            if (hint) {
                hint.innerHTML = '';
                hint.classList.remove('has-results', 'no-results', 'has-active-selection');
            }

            var searchWrapper = document.querySelector('.profile-review-search-wrapper');
            if (searchWrapper) {
                searchWrapper.classList.remove('has-value');
            }

            // Entferne aktiven State von allen Perspektive-Karten
            var resonanzProfileCards = document.querySelectorAll('#resonanzProfileModalValues .resonanz-profile-value-item');
            resonanzProfileCards.forEach(function(card) {
                card.classList.remove('active');
            });
        }
        window.clearProfileReviewSearch = clearProfileReviewSearch;

        /**
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         * INTELLIGENT SEARCH SUGGESTIONS
         * â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
         */

        // Global state for suggestions
        var suggestionState = {
            selectedIndex: -1,
            suggestions: [],
            activeSuggestion: null  // Speichert die ausgewÃ¤hlte Suggestion
        };

        /**
         * Get perspective information for a category
         */
        function getPerspectiveForCategory(categoryKey) {
            // Check if PerspektivenModal component exists
            if (window.PerspektivenModal && window.PerspektivenModal.kategoriePerspektiven) {
                var perspId = window.PerspektivenModal.kategoriePerspektiven[categoryKey];
                if (perspId && window.PerspektivenModal.perspektiven[perspId]) {
                    return window.PerspektivenModal.perspektiven[perspId];
                }
            }
            return null;
        }

        /**
         * Get perspective information for a need
         */
        function getPerspectiveForNeed(needId) {
            if (!window.BeduerfnisKatalog || !window.BeduerfnisKatalog.beduerfnisse) return null;

            var need = window.BeduerfnisKatalog.beduerfnisse[needId];
            if (!need || !need.kategorie) return null;

            // Get category from need
            var categoryId = need.kategorie;
            if (!window.TiageTaxonomie || !window.TiageTaxonomie.kategorien) return null;

            var category = window.TiageTaxonomie.kategorien[categoryId];
            if (!category || !category.key) return null;

            return getPerspectiveForCategory(category.key);
        }

        /**
         * Check if a string starts with the query (case-insensitive)
         * @param {string} text - Text to check
         * @param {string} query - Query to match against
         * @returns {boolean} True if text starts with query
         */
        function startsWithQuery(text, query) {
            if (!text || !query) return false;
            return text.toLowerCase().startsWith(query.toLowerCase());
        }

        /**
         * Calculate simple Levenshtein distance for fuzzy matching
         * @param {string} a - First string
         * @param {string} b - Second string
         * @returns {number} Edit distance between strings
         */
        function levenshteinDistance(a, b) {
            if (!a || !b) return Math.max((a || '').length, (b || '').length);
            a = a.toLowerCase();
            b = b.toLowerCase();

            if (a.length === 0) return b.length;
            if (b.length === 0) return a.length;

            var matrix = [];
            for (var i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            for (var j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }

            for (i = 1; i <= b.length; i++) {
                for (j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }

        /**
         * Check if query fuzzy-matches text (allows for typos)
         * @param {string} text - Text to check
         * @param {string} query - Query to match against
         * @param {number} maxDistance - Maximum allowed edit distance (default: 2)
         * @returns {number} Match score (0 = no match, higher = better match)
         */
        function fuzzyMatchScore(text, query, maxDistance) {
            if (!text || !query) return 0;
            maxDistance = maxDistance || 2;

            var lowerText = text.toLowerCase();
            var lowerQuery = query.toLowerCase();

            // Exact match = highest score
            if (lowerText === lowerQuery) return 100;

            // Starts with = very high score
            if (lowerText.startsWith(lowerQuery)) return 90;

            // Contains = high score
            if (lowerText.includes(lowerQuery)) return 80;

            // For short queries (< 3 chars), only do prefix matching
            if (query.length < 3) return 0;

            // Check fuzzy match on each word
            var words = lowerText.split(/\s+/);
            for (var i = 0; i < words.length; i++) {
                var word = words[i];
                // Check if the query is close to the start of any word
                var compareLength = Math.min(query.length, word.length);
                var wordPrefix = word.substring(0, compareLength);
                var distance = levenshteinDistance(lowerQuery, wordPrefix);

                if (distance <= maxDistance) {
                    return 70 - (distance * 10); // 70 for distance 0, 60 for 1, 50 for 2
                }
            }

            return 0;
        }

        /**
         * Generate search suggestions based on query
         * For comma-separated queries, only suggest for the last criterion
         */
        function generateSearchSuggestions(query) {
            var suggestions = [];

            // For comma-separated queries, only use the last criterion for suggestions
            var parts = query.split(',');
            var lastPart = parts[parts.length - 1].trim();
            var lowerQuery = lastPart.toLowerCase();

            // If last part is empty, show all items for browsing
            // But only if this is the FIRST part (no previous criteria exist)
            // If there are previous criteria (trailing comma), return empty suggestions instead
            if (!lowerQuery) {
                // Trailing comma with existing criteria - don't show all items, just return empty
                if (parts.length > 1) {
                    return suggestions;
                }
                // Show all categories (18 total)
                if (window.TiageTaxonomie && window.TiageTaxonomie.kategorien) {
                    Object.values(window.TiageTaxonomie.kategorien).forEach(function(kat) {
                        var persp = getPerspectiveForCategory(kat.key);
                        suggestions.push({
                            type: 'category',
                            id: kat.id,
                            label: kat.label,
                            description: kat.beschreibung,
                            perspective: persp
                        });
                    });
                }

                // Show all dimensions (6 total)
                if (window.TiageTaxonomie && window.TiageTaxonomie.dimensionen) {
                    Object.values(window.TiageTaxonomie.dimensionen).forEach(function(dim) {
                        suggestions.push({
                            type: 'dimension',
                            id: dim.id,
                            label: dim.label,
                            description: dim.beschreibung,
                            perspective: null
                        });
                    });
                }

                // Show all resonance factors (4 total)
                var resonanzfaktoren = {
                    'R1': { id: 'R1', label: 'Leben', icon: 'ğŸ”¥', beschreibung: 'Orientierung - Existenz, Zuneigung, MuÃŸe, IntimitÃ¤t' },
                    'R2': { id: 'R2', label: 'Philosophie', icon: 'ğŸ§ ', beschreibung: 'Archetyp - Lebensplanung, Werte, Finanzen' },
                    'R3': { id: 'R3', label: 'Dynamik', icon: 'âš¡', beschreibung: 'Dominanz - Machtdynamik, BDSM, Sicherheit' },
                    'R4': { id: 'R4', label: 'IdentitÃ¤t', icon: 'ğŸ’š', beschreibung: 'Geschlecht - AuthentizitÃ¤t, Kommunikation, Selbstausdruck' }
                };
                Object.values(resonanzfaktoren).forEach(function(resonanz) {
                    suggestions.push({
                        type: 'resonanz',
                        id: resonanz.id,
                        label: resonanz.label,
                        icon: resonanz.icon,
                        description: resonanz.beschreibung,
                        perspective: null
                    });
                });

                // Show all perspectives (4 total)
                if (window.TiageTaxonomie && window.TiageTaxonomie.perspektiven) {
                    Object.values(window.TiageTaxonomie.perspektiven).forEach(function(persp) {
                        suggestions.push({
                            type: 'perspective',
                            id: persp.id,
                            label: persp.label,
                            description: persp.beschreibung,
                            source: persp.quelle,
                            perspective: null
                        });
                    });
                }

                return suggestions; // Return all (18+6+4+4 = 32 items)
            }

            // Search in needs (BedÃ¼rfnisse)
            // Try BeduerfnisKatalog first, fallback to BeduerfnisIds
            var needsSource = null;
            if (window.BeduerfnisKatalog && window.BeduerfnisKatalog.beduerfnisse) {
                needsSource = window.BeduerfnisKatalog.beduerfnisse;
            } else if (typeof BeduerfnisIds !== 'undefined' && BeduerfnisIds.beduerfnisse) {
                needsSource = BeduerfnisIds.beduerfnisse;
            }

            if (needsSource) {
                // FIX #878: Object.entries statt Object.values um die ID (SchlÃ¼ssel) zu erhalten
                Object.entries(needsSource).forEach(function(entry) {
                    var needId = entry[0];  // '#B21' etc.
                    var need = entry[1];    // { key, kategorie, label, frage? }
                    var matchScore = 0;

                    // Check label with fuzzy matching
                    if (need.label) {
                        var labelScore = fuzzyMatchScore(need.label, lastPart, 2);
                        if (labelScore > 0) {
                            // Scale fuzzy score to our scoring system (max 10 for needs label)
                            matchScore = Math.round(labelScore / 10);
                        }
                    }

                    // Check ID (exact match only for IDs)
                    if (needId && needId.toLowerCase().includes(lowerQuery)) {
                        matchScore = Math.max(matchScore, 8);
                    }

                    // Check description/frage with fuzzy matching
                    if (need.frage) {
                        var frageScore = fuzzyMatchScore(need.frage, lastPart, 2);
                        if (frageScore > 0) {
                            matchScore = Math.max(matchScore, Math.round(frageScore / 15));
                        }
                    }

                    if (matchScore > 0) {
                        var persp = getPerspectiveForNeed(needId);
                        suggestions.push({
                            type: 'need',
                            id: needId,
                            label: need.label,
                            description: need.frage || '',
                            perspective: persp,
                            score: matchScore
                        });
                    }
                });
            }

            // Search in categories (Kategorien)
            if (window.TiageTaxonomie && window.TiageTaxonomie.kategorien) {
                Object.values(window.TiageTaxonomie.kategorien).forEach(function(kat) {
                    var matchScore = 0;

                    // Check label with fuzzy matching
                    if (kat.label) {
                        var labelScore = fuzzyMatchScore(kat.label, lastPart, 2);
                        if (labelScore > 0) {
                            matchScore = Math.round(labelScore / 11); // Scale to max 9
                        }
                    }

                    // Check description with fuzzy matching
                    if (kat.beschreibung) {
                        var descScore = fuzzyMatchScore(kat.beschreibung, lastPart, 2);
                        if (descScore > 0) {
                            matchScore = Math.max(matchScore, Math.round(descScore / 14)); // Scale to max 7
                        }
                    }

                    // Check ID (exact match only)
                    if (kat.id && kat.id.toLowerCase().includes(lowerQuery)) {
                        matchScore = Math.max(matchScore, 8);
                    }

                    if (matchScore > 0) {
                        var persp = getPerspectiveForCategory(kat.key);
                        suggestions.push({
                            type: 'category',
                            id: kat.id,
                            label: kat.label,
                            description: kat.beschreibung,
                            perspective: persp,
                            score: matchScore
                        });
                    }
                });
            }

            // Search in dimensions (Dimensionen)
            if (window.TiageTaxonomie && window.TiageTaxonomie.dimensionen) {
                Object.values(window.TiageTaxonomie.dimensionen).forEach(function(dim) {
                    var matchScore = 0;

                    // Check label with fuzzy matching
                    if (dim.label) {
                        var labelScore = fuzzyMatchScore(dim.label, lastPart, 2);
                        if (labelScore > 0) {
                            matchScore = Math.round(labelScore / 12); // Scale to max 8
                        }
                    }

                    // Check description with fuzzy matching
                    if (dim.beschreibung) {
                        var descScore = fuzzyMatchScore(dim.beschreibung, lastPart, 2);
                        if (descScore > 0) {
                            matchScore = Math.max(matchScore, Math.round(descScore / 16)); // Scale to max 6
                        }
                    }

                    // Check ID (exact match only)
                    if (dim.id && dim.id.toLowerCase().includes(lowerQuery)) {
                        matchScore = Math.max(matchScore, 7);
                    }

                    if (matchScore > 0) {
                        suggestions.push({
                            type: 'dimension',
                            id: dim.id,
                            label: dim.label,
                            description: dim.beschreibung,
                            perspective: null,
                            score: matchScore
                        });
                    }
                });
            }

            // Search in perspectives (Perspektiven)
            if (window.TiageTaxonomie && window.TiageTaxonomie.perspektiven) {
                Object.values(window.TiageTaxonomie.perspektiven).forEach(function(persp) {
                    var matchScore = 0;

                    // Check label with fuzzy matching
                    if (persp.label) {
                        var labelScore = fuzzyMatchScore(persp.label, lastPart, 2);
                        if (labelScore > 0) {
                            matchScore = Math.round(labelScore / 14); // Scale to max 7
                        }
                    }

                    // Check description with fuzzy matching
                    if (persp.beschreibung) {
                        var descScore = fuzzyMatchScore(persp.beschreibung, lastPart, 2);
                        if (descScore > 0) {
                            matchScore = Math.max(matchScore, Math.round(descScore / 20)); // Scale to max 5
                        }
                    }

                    // Check ID
                    if (persp.id && persp.id.toLowerCase().includes(lowerQuery)) {
                        matchScore = Math.max(matchScore, 6);
                    }

                    if (matchScore > 0) {
                        suggestions.push({
                            type: 'perspective',
                            id: persp.id,
                            label: persp.label,
                            description: persp.beschreibung,
                            source: persp.quelle,
                            perspective: null,
                            score: matchScore
                        });
                    }
                });
            }

            // Search in resonance factors (Resonanzfaktoren R1-R4)
            var resonanzfaktoren = {
                'R1': { id: 'R1', label: 'Leben', icon: 'ğŸ”¥', beschreibung: 'Orientierung - Existenz, Zuneigung, MuÃŸe, IntimitÃ¤t' },
                'R2': { id: 'R2', label: 'Philosophie', icon: 'ğŸ§ ', beschreibung: 'Archetyp - Lebensplanung, Werte, Finanzen' },
                'R3': { id: 'R3', label: 'Dynamik', icon: 'âš¡', beschreibung: 'Dominanz - Machtdynamik, BDSM, Sicherheit' },
                'R4': { id: 'R4', label: 'IdentitÃ¤t', icon: 'ğŸ’š', beschreibung: 'Geschlecht - AuthentizitÃ¤t, Kommunikation, Selbstausdruck' }
            };

            Object.values(resonanzfaktoren).forEach(function(resonanz) {
                var matchScore = 0;

                // Check label with fuzzy matching
                if (resonanz.label) {
                    var labelScore = fuzzyMatchScore(resonanz.label, lastPart, 2);
                    if (labelScore > 0) {
                        matchScore = Math.round(labelScore / 12); // Scale to max 8
                    }
                }

                // Check description with fuzzy matching
                if (resonanz.beschreibung) {
                    var descScore = fuzzyMatchScore(resonanz.beschreibung, lastPart, 2);
                    if (descScore > 0) {
                        matchScore = Math.max(matchScore, Math.round(descScore / 16)); // Scale to max 6
                    }
                }

                // Check ID (exact match only)
                if (resonanz.id && resonanz.id.toLowerCase().includes(lowerQuery)) {
                    matchScore = Math.max(matchScore, 7);
                }

                if (matchScore > 0) {
                    suggestions.push({
                        type: 'resonanz',
                        id: resonanz.id,
                        label: resonanz.label,
                        icon: resonanz.icon,
                        description: resonanz.beschreibung,
                        perspective: null,
                        score: matchScore
                        });
                }
            });

            // Sort by score and limit results
            suggestions.sort(function(a, b) {
                return (b.score || 0) - (a.score || 0);
            });

            return suggestions.slice(0, 15);
        }

        /**
         * Render suggestion item HTML
         */
        function renderSuggestionItem(suggestion, index) {
            var typeLabel = {
                'need': 'BedÃ¼rfnis',
                'category': 'Kategorie',
                'dimension': 'Dimension',
                'resonanz': 'Resonanzfaktor',
                'perspective': 'Perspektive'
            }[suggestion.type] || suggestion.type;

            var perspectiveHTML = '';
            if (suggestion.perspective) {
                var icon = suggestion.perspective.icon || 'ğŸ“Š';
                var label = suggestion.perspective.label || '';
                perspectiveHTML = '<div class="suggestion-item-perspective">' +
                    '<span class="suggestion-item-perspective-icon">' + icon + '</span>' +
                    '<span>Perspektive: ' + label + '</span>' +
                    '</div>';
            }

            var descriptionHTML = '';
            if (suggestion.description) {
                var desc = suggestion.description;
                if (desc.length > 120) {
                    desc = desc.substring(0, 120) + '...';
                }
                descriptionHTML = '<div class="suggestion-item-description">' + desc + '</div>';
            }

            // Add icon for resonanz type
            var iconPrefix = suggestion.icon ? suggestion.icon + ' ' : '';

            return '<div class="suggestion-item' + (index === suggestionState.selectedIndex ? ' active' : '') + '" ' +
                   'data-index="' + index + '" ' +
                   'data-value="' + suggestion.label + '">' +
                   '<div class="suggestion-item-header">' +
                   '<span class="suggestion-item-type type-' + suggestion.type + '">' + typeLabel + '</span>' +
                   '<span class="suggestion-item-label">' + iconPrefix + suggestion.label + '</span>' +
                   '<span class="suggestion-item-id">' + suggestion.id + '</span>' +
                   '</div>' +
                   descriptionHTML +
                   perspectiveHTML +
                   '</div>';
        }

        /**
         * Display search suggestions
         */
        function displaySearchSuggestions(suggestions) {
            var dropdown = document.getElementById('searchSuggestionsDropdown');
            var content = dropdown ? dropdown.querySelector('.search-suggestions-content') : null;

            if (!dropdown || !content) {
                return;
            }

            suggestionState.suggestions = suggestions;
            suggestionState.selectedIndex = -1;

            if (suggestions.length === 0) {
                var searchInput = document.getElementById('profileReviewSearchInput');
                var currentQuery = searchInput ? searchInput.value : '';
                var parts = currentQuery.split(',');
                var lastPart = parts[parts.length - 1].trim();

                var helpMessage = '<div class="search-suggestions-empty">' +
                    '<div style="font-weight: bold; margin-bottom: 8px;">Keine VorschlÃ¤ge fÃ¼r "' + lastPart + '"</div>' +
                    '<div style="font-size: 0.85em; color: #888;">' +
                    'Tipps:' +
                    '<ul style="margin: 4px 0; padding-left: 16px;">' +
                    '<li>Verwende lÃ¤ngere Suchbegriffe (mind. 3 Zeichen)</li>' +
                    '<li>PrÃ¼fe die Schreibweise</li>' +
                    '<li>Nutze * als Wildcard (z.B. "lieb*")</li>' +
                    '</ul></div></div>';
                content.innerHTML = helpMessage;
                dropdown.style.display = 'block';
                return;
            }

            // Group suggestions by type
            var grouped = {
                'need': [],
                'category': [],
                'dimension': [],
                'resonanz': [],
                'perspective': []
            };

            suggestions.forEach(function(suggestion, index) {
                if (grouped[suggestion.type]) {
                    grouped[suggestion.type].push({suggestion: suggestion, index: index});
                }
            });

            var html = '';
            var currentIndex = 0;

            // Render in order: needs, categories, dimensions, resonanz, perspectives
            var order = ['need', 'category', 'dimension', 'resonanz', 'perspective'];
            var headers = {
                'need': 'BedÃ¼rfnisse',
                'category': 'Kategorien',
                'dimension': 'Dimensionen',
                'resonanz': 'Resonanzfaktoren',
                'perspective': 'Perspektiven'
            };

            order.forEach(function(type) {
                if (grouped[type].length > 0) {
                    html += '<div class="suggestion-section-header">' + headers[type] + '</div>';
                    grouped[type].forEach(function(item) {
                        html += renderSuggestionItem(item.suggestion, item.index);
                    });
                }
            });

            content.innerHTML = html;
            dropdown.style.display = 'block';

            // Add click handlers
            content.querySelectorAll('.suggestion-item').forEach(function(item) {
                item.addEventListener('click', function() {
                    selectSuggestion(parseInt(item.getAttribute('data-index')));
                });
            });
        }

        /**
         * Hide search suggestions
         */
        function hideSearchSuggestions() {
            var dropdown = document.getElementById('searchSuggestionsDropdown');
            if (dropdown) {
                dropdown.style.display = 'none';
            }
            suggestionState.selectedIndex = -1;
        }
        window.hideSearchSuggestions = hideSearchSuggestions;

        /**
         * Handle intelligent search input
         */
        function handleIntelligentSearch(query) {
            // Call original filter function
            filterProfileReviewByNeed(query);

            // Generate and display suggestions
            var suggestions = generateSearchSuggestions(query);
            displaySearchSuggestions(suggestions);
        }
        window.handleIntelligentSearch = handleIntelligentSearch;

        /**
         * Show search suggestions on focus
         */
        function showSearchSuggestions() {
            var input = document.getElementById('profileReviewSearchInput');
            if (!input) return;

            var query = input.value || '';
            var suggestions = generateSearchSuggestions(query);
            displaySearchSuggestions(suggestions);
        }
        window.showSearchSuggestions = showSearchSuggestions;

        /**
         * Select a suggestion
         */
        function selectSuggestion(index) {
            if (index < 0 || index >= suggestionState.suggestions.length) return;

            var suggestion = suggestionState.suggestions[index];
            var input = document.getElementById('profileReviewSearchInput');

            // Speichere die ausgewÃ¤hlte Suggestion
            suggestionState.activeSuggestion = suggestion;

            // Entferne aktiven State von allen Perspektive-Karten
            var resonanzProfileCards = document.querySelectorAll('#resonanzProfileModalValues .resonanz-profile-value-item');
            resonanzProfileCards.forEach(function(card) {
                card.classList.remove('active');
            });

            // Wenn die Suggestion ein Resonanzfaktor ist, setze den entsprechenden aktiven State
            if (suggestion.type === 'resonanz' && suggestion.id) {
                resonanzProfileCards.forEach(function(card) {
                    var idElement = card.querySelector('.resonanz-profile-value-id');
                    if (idElement && idElement.textContent.trim() === suggestion.id) {
                        card.classList.add('active');
                    }
                });
            }

            // FIX #865: Aktiviere die entsprechenden Kategorien im DimensionKategorieFilter
            // FIX #879: Bei BedÃ¼rfnis-Auswahl NUR Textfilter verwenden (nicht Kategorie-Filter)
            if (typeof DimensionKategorieFilter !== 'undefined') {
                // Erst alle bestehenden Filter zurÃ¼cksetzen
                DimensionKategorieFilter.reset();

                if (suggestion.type === 'dimension' && suggestion.id) {
                    // Bei Dimension: Aktiviere alle Kategorien, die zu dieser Dimension gehÃ¶ren
                    if (typeof TiageTaxonomie !== 'undefined') {
                        var kategorien = TiageTaxonomie.getKategorienFuerDimension
                            ? TiageTaxonomie.getKategorienFuerDimension(suggestion.id)
                            : [];
                        kategorien.forEach(function(kat) {
                            DimensionKategorieFilter.toggleKategorie(kat.id);
                        });
                        console.log('[selectSuggestion] Dimension aktiviert:', suggestion.id, '- Kategorien:', kategorien.map(function(k) { return k.id; }));
                    }
                } else if (suggestion.type === 'category' && suggestion.id) {
                    // Bei Kategorie: Aktiviere diese Kategorie
                    DimensionKategorieFilter.toggleKategorie(suggestion.id);
                    console.log('[selectSuggestion] Kategorie aktiviert:', suggestion.id);
                } else if (suggestion.type === 'resonanz' && suggestion.id) {
                    // Bei Resonanzfaktor: Aktiviere alle zugehÃ¶rigen Kategorien
                    var resonanzKategorien = DimensionKategorieFilter.KATEGORIEN_PRO_DIMENSION[suggestion.id];
                    if (resonanzKategorien && resonanzKategorien.length > 0) {
                        resonanzKategorien.forEach(function(kat) {
                            DimensionKategorieFilter.toggleKategorie(kat.id);
                        });
                        console.log('[selectSuggestion] Resonanzfaktor aktiviert:', suggestion.id, '- Kategorien:', resonanzKategorien.map(function(k) { return k.id; }));
                    }
                } else if (suggestion.type === 'need' && suggestion.id) {
                    // FIX #879: Bei BedÃ¼rfnis-Auswahl NUR Textfilter verwenden
                    // Der Textfilter zeigt alle BedÃ¼rfnisse mit dem Suchbegriff im Namen
                    // (z.B. "Liebe" zeigt "Liebe" und "Liebesbekundungen")
                    console.log('[selectSuggestion] BedÃ¼rfnis als Textsuche:', suggestion.label);
                }
            }

            if (input) {
                // Preserve previous criteria (before last comma) and replace last part
                var currentValue = input.value;
                var parts = currentValue.split(',');
                parts[parts.length - 1] = suggestion.label;
                var newValue = parts.join(',');

                input.value = newValue;
                // Rufe nur filterProfileReviewByNeed auf, nicht handleIntelligentSearch
                // um das erneute Ã–ffnen des Dropdowns zu vermeiden
                filterProfileReviewByNeed(newValue);
            }

            hideSearchSuggestions();

            // Zeige die ausgewÃ¤hlte Suggestion an
            displayActiveSuggestion();
        }

        /**
         * Display the active/selected suggestion as a tag
         */
        function displayActiveSuggestion() {
            var hint = document.getElementById('profileReviewSearchHint');
            if (!hint) return;

            var suggestion = suggestionState.activeSuggestion;
            if (!suggestion) {
                return;
            }

            // FIX #879: Bei BedÃ¼rfnis-Auswahl Textsuche-Tag anzeigen
            if (suggestion.type === 'need') {
                // Textsuche-Modus: Zeige Suchbegriff mit Lupe-Icon
                hint.innerHTML = '<span class="search-active-selection">' +
                    '<span class="search-active-type type-textsearch">ğŸ” Textsuche</span>' +
                    '<span class="search-active-label">"' + suggestion.label + '"</span>' +
                    '<button class="search-active-clear" onclick="clearActiveSuggestion()" title="Suche entfernen">Ã—</button>' +
                    '</span>';
                hint.classList.add('has-active-selection');
                hint.classList.remove('has-results', 'no-results');
                return;
            }

            var typeLabel = {
                'category': 'Kategorie',
                'dimension': 'Dimension',
                'resonanz': 'Resonanzfaktor',
                'perspective': 'Perspektive'
            }[suggestion.type] || suggestion.type;

            var iconPrefix = suggestion.icon ? suggestion.icon + ' ' : '';

            // Zeige die Auswahl als Tag
            hint.innerHTML = '<span class="search-active-selection">' +
                '<span class="search-active-type type-' + suggestion.type + '">' + typeLabel + '</span>' +
                '<span class="search-active-label">' + iconPrefix + suggestion.label + '</span>' +
                '<span class="search-active-id">' + suggestion.id + '</span>' +
                '<button class="search-active-clear" onclick="clearActiveSuggestion()" title="Auswahl entfernen">Ã—</button>' +
                '</span>';
            hint.classList.add('has-active-selection');
            hint.classList.remove('has-results', 'no-results');
        }
        window.displayActiveSuggestion = displayActiveSuggestion;

        /**
         * Clear the active suggestion and reset search filter
         */
        function clearActiveSuggestion() {
            suggestionState.activeSuggestion = null;
            var hint = document.getElementById('profileReviewSearchHint');
            if (hint) {
                hint.innerHTML = '';
                hint.classList.remove('has-active-selection');
            }
            // Clear the search input and reset filter
            var input = document.getElementById('profileReviewSearchInput');
            if (input) {
                input.value = '';
            }
            // Reset filter to show all items
            filterProfileReviewByNeed('');
            // FIX #865: Setze auch den DimensionKategorieFilter zurÃ¼ck
            if (typeof DimensionKategorieFilter !== 'undefined') {
                DimensionKategorieFilter.reset();
            }
            // Hide suggestions dropdown
            hideSearchSuggestions();
        }
        window.clearActiveSuggestion = clearActiveSuggestion;

        /**
         * Handle keyboard navigation in search
         */
        function handleSearchKeydown(event) {
            var dropdown = document.getElementById('searchSuggestionsDropdown');
            var dropdownVisible = dropdown && dropdown.style.display !== 'none';
            var suggestions = suggestionState.suggestions || [];

            // Enter funktioniert auch ohne sichtbares Dropdown (fÃ¼r Textsuche)
            if (event.key === 'Enter') {
                event.preventDefault();
                if (dropdownVisible && suggestionState.selectedIndex >= 0) {
                    selectSuggestion(suggestionState.selectedIndex);
                } else {
                    // FIX: Bei Enter ohne Vorschlagsauswahl -> Textsuche aktivieren
                    var input = document.getElementById('profileReviewSearchInput');
                    var query = input ? input.value.trim() : '';
                    if (query.length > 0) {
                        // Erstelle eine manuelle Textsuche-Suggestion
                        suggestionState.activeSuggestion = {
                            type: 'need',
                            id: null,
                            label: query
                        };
                        // Zeige den Textsuche-Tag an
                        displayActiveSuggestion();
                        // SchlieÃŸe das Dropdown
                        hideSearchSuggestions();
                        console.log('[handleSearchKeydown] Textsuche aktiviert fÃ¼r:', query);
                    }
                }
                return;
            }

            // FÃ¼r andere Tasten: Dropdown muss sichtbar sein
            if (!dropdownVisible) return;
            if (suggestions.length === 0) return;

            switch (event.key) {
                case 'ArrowDown':
                    event.preventDefault();
                    suggestionState.selectedIndex = Math.min(
                        suggestionState.selectedIndex + 1,
                        suggestions.length - 1
                    );
                    updateSuggestionSelection();
                    break;

                case 'ArrowUp':
                    event.preventDefault();
                    suggestionState.selectedIndex = Math.max(
                        suggestionState.selectedIndex - 1,
                        -1
                    );
                    updateSuggestionSelection();
                    break;

                case 'Escape':
                    event.preventDefault();
                    hideSearchSuggestions();
                    break;
            }
        }
        window.handleSearchKeydown = handleSearchKeydown;

        /**
         * Update suggestion selection visual state
         */
        function updateSuggestionSelection() {
            var content = document.querySelector('.search-suggestions-content');
            if (!content) return;

            var items = content.querySelectorAll('.suggestion-item');
            items.forEach(function(item, index) {
                if (index === suggestionState.selectedIndex) {
                    item.classList.add('active');
                    item.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
                } else {
                    item.classList.remove('active');
                }
            });
        }

        /**
         * Close suggestions when clicking outside
         */
        document.addEventListener('click', function(event) {
            var searchWrapper = document.querySelector('.profile-review-search-wrapper');
            var dropdown = document.getElementById('searchSuggestionsDropdown');
            var searchInput = document.getElementById('profileReviewSearchInput');

            if (searchWrapper && dropdown &&
                !searchWrapper.contains(event.target) &&
                !dropdown.contains(event.target)) {
                hideSearchSuggestions();
                // Blur search input to close virtual keyboard and remove focus
                if (searchInput && document.activeElement === searchInput) {
                    searchInput.blur();
                }
            }
        });

        /**
         * Update clearProfileReviewSearch to also hide suggestions
         */
        var originalClear = window.clearProfileReviewSearch;
        window.clearProfileReviewSearch = function() {
            originalClear();
            hideSearchSuggestions();
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Update Source Explanation with current factors
        function updateSourceExplanation(archetypeKey, personData, dominanz, orientierung) {
            var locale = typeof TiageI18n !== 'undefined' ? TiageI18n.getLocale() : null;

            // Archetyp
            var archetypeEl = document.getElementById('srcFactor-archetype');
            if (archetypeEl) {
                archetypeEl.textContent = archetypeKey ? archetypeKey.charAt(0).toUpperCase() + archetypeKey.slice(1) : 'Duo';
            }

            // Gender
            var genderEl = document.getElementById('srcFactor-gender');
            if (genderEl && personData && personData.geschlecht) {
                var p = personData.geschlecht.primary;
                var s = personData.geschlecht.secondary;
                if (p && s) {
                    var pLabel = (locale && locale.geschlecht && locale.geschlecht.primary && locale.geschlecht.primary[p]) ? locale.geschlecht.primary[p] : p;
                    var sLabel = (locale && locale.geschlecht && locale.geschlecht.secondary && locale.geschlecht.secondary[s]) ? locale.geschlecht.secondary[s] : s;
                    genderEl.textContent = pLabel + ' / ' + sLabel;
                } else if (p) {
                    genderEl.textContent = (locale && locale.geschlecht && locale.geschlecht.primary && locale.geschlecht.primary[p]) ? locale.geschlecht.primary[p] : p;
                }
            }

            // Dominanz
            var domEl = document.getElementById('srcFactor-dominance');
            if (domEl && dominanz) {
                var domLabel = (locale && locale.dominanz && locale.dominanz.types && locale.dominanz.types[dominanz]) ? locale.dominanz.types[dominanz] : dominanz.charAt(0).toUpperCase() + dominanz.slice(1);
                domEl.textContent = domLabel;
            }

            // Orientierung
            var oriEl = document.getElementById('srcFactor-orientation');
            if (oriEl && orientierung) {
                var oriLabel = (locale && locale.orientierung && locale.orientierung.types && locale.orientierung.types[orientierung]) ? locale.orientierung.types[orientierung] : orientierung.charAt(0).toUpperCase() + orientierung.slice(1);
                oriEl.textContent = oriLabel;
            }
        }
        window.updateSourceExplanation = updateSourceExplanation;

        // Update Slider Value Display - Zeigt Zahl 1-10
        function updateProfileReviewSlider(slider, valueId) {
            var value = parseInt(slider.value);
            var valueSpan = document.getElementById(valueId);
            if (!valueSpan) return;

            // Map 0-100 to 1-10
            var displayValue = Math.round(value / 10);
            if (displayValue < 1) displayValue = 1;
            if (displayValue > 10) displayValue = 10;

            valueSpan.textContent = displayValue;
        }
        window.updateProfileReviewSlider = updateProfileReviewSlider;

        // Track Changes
        function trackProfileReviewChange() {
            profileReviewChangesCount++;
            var badge = document.getElementById('profileReviewChangesBadge');
            if (badge) {
                badge.textContent = profileReviewChangesCount;
                badge.style.display = 'inline-block';
            }
        }
        window.trackProfileReviewChange = trackProfileReviewChange;

        // Toggle button active state
        function toggleProfileBtn(btn) {
            btn.classList.toggle('active');
            trackProfileReviewChange();
        }
        window.toggleProfileBtn = toggleProfileBtn;

        // Set button state (for loading from archetype)
        function setProfileBtnState(btnId, active) {
            var btn = document.getElementById(btnId);
            if (btn) {
                if (active) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            }
        }
        window.setProfileBtnState = setProfileBtnState;

        // Select Triple Button (fÃ¼r 3er-Gruppen)
        function selectTripleBtn(btn) {
            console.log('[TIAGE] selectTripleBtn called', btn);
            var group = btn.parentElement;
            var attrId = group.getAttribute('data-attr');
            console.log('[TIAGE] attrId:', attrId, 'group:', group);
            var wasActive = btn.classList.contains('active');

            // Alle Buttons in der Gruppe deaktivieren
            group.querySelectorAll('.profile-review-triple-btn').forEach(function(b) {
                b.classList.remove('active');
            });

            // Toggle: Wenn bereits aktiv war, nicht wieder aktivieren (Abwahl ermÃ¶glichen)
            if (!wasActive) {
                btn.classList.add('active');
            }
            trackProfileReviewChange();

            // Live-Synchronisierung fÃ¼r GeschlechtsidentitÃ¤t
            if (attrId === 'pr-geschlecht-sekundaer' && typeof TiageState !== 'undefined') {
                var primaryGeschlecht = TiageState.getPrimaryGeschlecht('ich');
                if (primaryGeschlecht) {
                    var secondaryValue = null;

                    // Nur wenn ein Button aktiv ist, setze den Wert
                    if (!wasActive) {
                        var value = parseInt(btn.getAttribute('data-value'), 10);
                        secondaryValue = mapGeschlechtsidentitaetToSecondary(value, primaryGeschlecht);
                    }

                    // Use the new sync function that updates both personDimensions and UI
                    if (typeof setSecondaryGeschlechtAndSync === 'function') {
                        setSecondaryGeschlechtAndSync('ich', secondaryValue);
                    } else {
                        // Fallback to TiageState only
                        TiageState.setSecondaryGeschlecht('ich', secondaryValue);
                    }
                    console.log('[ProfileReview] GeschlechtsidentitÃ¤t live-sync:', wasActive ? 'abgewÃ¤hlt' : secondaryValue);

                    // Profil-Attribute und Anzeige aktualisieren
                    if (!wasActive) {
                        reloadProfileAttributesAfterGenderChange();
                    } else {
                        // Bei Abwahl: Source-Explanation aktualisieren (zeigt nur noch primary)
                        var person = currentProfileReviewContext.person || 'ich';
                        var personData = personDimensions[person];
                        var dominanz = (personData && personData.dominanz && personData.dominanz.primary) ? personData.dominanz.primary : 'ausgeglichen';
                        var orientierung = (personData && personData.orientierung && personData.orientierung.primary) ? personData.orientierung.primary : 'heterosexuell';
                        updateSourceExplanation(currentProfileReviewContext.archetypeKey, personData, dominanz, orientierung);
                    }
                }
            }
        }
        window.selectTripleBtn = selectTripleBtn;

        // Lade Profil-Attribute neu nach Ã„nderung der GeschlechtsidentitÃ¤t
        function reloadProfileAttributesAfterGenderChange() {
            var archetypeKey = currentProfileReviewContext.archetypeKey;
            var person = currentProfileReviewContext.person;

            if (!archetypeKey || !person) {
                console.log('[ProfileReview] Kein Kontext fÃ¼r Reload verfÃ¼gbar');
                return;
            }

            var personData = personDimensions[person];
            if (!personData || !personData.geschlecht ||
                !personData.geschlecht.primary || !personData.geschlecht.secondary) {
                console.log('[ProfileReview] UnvollstÃ¤ndige Gender-Daten fÃ¼r Reload');
                return;
            }

            if (typeof TiageProfileStore === 'undefined') {
                console.log('[ProfileReview] TiageProfileStore nicht verfÃ¼gbar');
                return;
            }

            // Hole Dominanz und Orientierung
            var dominanz = 'ausgeglichen';
            if (personData.dominanz && personData.dominanz.primary) {
                dominanz = personData.dominanz.primary;
            }

            var orientierung = 'heterosexuell';
            if (personData.orientierung && personData.orientierung.primary) {
                orientierung = personData.orientierung.primary;
            }

            // Komponiertes Profil mit neuen Gender-Modifikatoren laden
            var composedProfile = TiageProfileStore.getProfileSync(
                archetypeKey,
                personData.geschlecht.primary,
                personData.geschlecht.secondary,
                dominanz,
                orientierung
            );

            if (!composedProfile || !composedProfile.attributes) {
                console.log('[ProfileReview] Kein komponiertes Profil gefunden');
                return;
            }

            var inferences = composedProfile.attributes;
            console.log('[ProfileReview] Profil neu geladen nach Gender-Ã„nderung:',
                personData.geschlecht.primary + '-' + personData.geschlecht.secondary);

            // Hilfsfunktion: Numerischen Wert (0-1) auf Triple-Button-Wert (25/50/75) mappen
            function mapToTripleValue(numValue) {
                if (numValue === undefined || numValue === null) return 50;
                if (numValue <= 0.33) return 25;
                if (numValue >= 0.67) return 75;
                return 50;
            }

            // Toggle-Buttons aktualisieren
            setProfileBtnState('pr-kinder', inferences.kinderWunsch === 'ja');
            setProfileBtnState('pr-ehe', inferences.eheWunsch === 'ja');
            setProfileBtnState('pr-zusammen', inferences.wohnform === 'zusammen');
            setProfileBtnState('pr-haustiere', inferences.haustiere === 'ja' || inferences.haustiere === 'ja-gemeinsam' || inferences.haustiere === 'ja-eigene');

            // Umzugsbereitschaft
            var umzugValue = 50;
            if (inferences.umzugsbereitschaft === 'sehr-flexibel') umzugValue = 75;
            else if (inferences.umzugsbereitschaft === 'flexibel') umzugValue = 75;
            else if (inferences.umzugsbereitschaft === 'verhandelbar') umzugValue = 50;
            else if (inferences.umzugsbereitschaft === 'nur-gemeinsam') umzugValue = 25;
            else if (inferences.umzugsbereitschaft === 'sesshaft') umzugValue = 25;
            setTripleBtnValue('pr-umzug', umzugValue);

            // Familie-Wichtigkeit
            setTripleBtnValue('pr-familie', mapToTripleValue(inferences.familieWichtigkeit));

            // Finanzen
            var finanzenValue = 50;
            if (inferences.finanzen === 'getrennt') finanzenValue = 25;
            else if (inferences.finanzen === 'hybrid') finanzenValue = 50;
            else if (inferences.finanzen === 'gemeinsam') finanzenValue = 75;
            setTripleBtnValue('pr-finanzen', finanzenValue);

            // Karriere-PrioritÃ¤t
            setTripleBtnValue('pr-karriere', mapToTripleValue(inferences.karrierePrioritaet));

            // KOMMUNIKATION
            setTripleBtnValue('pr-gespraech', mapToTripleValue(inferences.gespraechsBeduernis));
            setTripleBtnValue('pr-emotional', mapToTripleValue(inferences.emotionaleOffenheit));
            setTripleBtnValue('pr-konflikt', mapToTripleValue(inferences.konfliktverhalten));

            // SOZIALES
            var introExtroValue = 50;
            if (typeof inferences.introExtro === 'number') {
                if (inferences.introExtro <= -0.33) introExtroValue = 25;
                else if (inferences.introExtro >= 0.33) introExtroValue = 75;
            } else if (inferences.introExtro === 'introvertiert') introExtroValue = 25;
            else if (inferences.introExtro === 'extrovertiert') introExtroValue = 75;
            setTripleBtnValue('pr-introextro', introExtroValue);

            setTripleBtnValue('pr-alleinzeit', mapToTripleValue(inferences.alleinZeitBeduernis));
            setTripleBtnValue('pr-freunde', mapToTripleValue(inferences.freundeskreis));

            // INTIMITÃ„T
            setTripleBtnValue('pr-naehe', mapToTripleValue(inferences.koerperlicheNaehe));
            setTripleBtnValue('pr-romantik', mapToTripleValue(inferences.romantikBeduernis));
            setTripleBtnValue('pr-sex', mapToTripleValue(inferences.sexFrequenz));

            // WERTE
            setTripleBtnValue('pr-religion', mapToTripleValue(inferences.religiositaet));
            var traditionValue = 50;
            if (typeof inferences.traditionenWichtigkeit === 'number') {
                if (inferences.traditionenWichtigkeit >= 0.67) traditionValue = 25;
                else if (inferences.traditionenWichtigkeit <= 0.33) traditionValue = 75;
            }
            setTripleBtnValue('pr-tradition', traditionValue);

            setTripleBtnValue('pr-umwelt', mapToTripleValue(inferences.umweltbewusstsein));
            setTripleBtnValue('pr-politik', mapToTripleValue(inferences.politischesInteresse));

            // NEU: Source-Explanation aktualisieren um sekundÃ¤res Geschlecht oben anzuzeigen
            updateSourceExplanation(archetypeKey, personData, dominanz, orientierung);

            console.log('[ProfileReview] Alle 30 Attribute wurden mit neuen Gender-Modifikatoren aktualisiert');
        }
        window.reloadProfileAttributesAfterGenderChange = reloadProfileAttributesAfterGenderChange;

        // Select Toggle Button (fÃ¼r 2er-Gruppen: Egal/Wichtig)
        function selectToggleBtn(btn) {
            // Alle Buttons in der Gruppe deaktivieren
            var group = btn.parentElement;
            group.querySelectorAll('.profile-review-toggle-option').forEach(function(b) {
                b.classList.remove('active');
            });
            // Geklickten Button aktivieren
            btn.classList.add('active');
            trackProfileReviewChange();
        }
        window.selectToggleBtn = selectToggleBtn;

        // Toggle Button Wert auslesen
        function getToggleBtnValue(attrId) {
            var group = document.querySelector('[data-attr="' + attrId + '"]');
            if (!group) return '1';
            var activeBtn = group.querySelector('.profile-review-toggle-option.active');
            return activeBtn ? activeBtn.getAttribute('data-value') : '1';
        }
        window.getToggleBtnValue = getToggleBtnValue;

        // Toggle Button setzen (fÃ¼r Reset)
        function setToggleBtnValue(attrId, value) {
            var group = document.querySelector('[data-attr="' + attrId + '"]');
            if (!group) return;
            group.querySelectorAll('.profile-review-toggle-option').forEach(function(btn) {
                if (btn.getAttribute('data-value') === String(value)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        window.setToggleBtnValue = setToggleBtnValue;

        // Triple Button Wert auslesen
        function getTripleBtnValue(attrId) {
            var group = document.querySelector('[data-attr="' + attrId + '"]');
            if (!group) return '50';
            var activeBtn = group.querySelector('.profile-review-triple-btn.active');
            return activeBtn ? activeBtn.getAttribute('data-value') : '50';
        }
        window.getTripleBtnValue = getTripleBtnValue;

        // Triple Button setzen (fÃ¼r Reset)
        function setTripleBtnValue(attrId, value) {
            var group = document.querySelector('[data-attr="' + attrId + '"]');
            if (!group) return;
            group.querySelectorAll('.profile-review-triple-btn').forEach(function(btn) {
                if (btn.getAttribute('data-value') === String(value)) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
        }
        window.setTripleBtnValue = setTripleBtnValue;

        // Filter Attributes by Search
        function filterProfileReviewAttributes(query) {
            var attributes = document.querySelectorAll('.profile-review-checkbox-grid, .profile-review-triple-attribute');
            var categories = document.querySelectorAll('.profile-review-category');
            var searchLower = query.toLowerCase();

            if (!query) {
                attributes.forEach(function(attr) { attr.style.display = ''; });
                categories.forEach(function(cat) { cat.style.display = ''; });
                return;
            }

            categories.forEach(function(category) {
                var hasVisibleAttribute = false;
                var categoryAttributes = category.querySelectorAll('.profile-review-checkbox-grid, .profile-review-triple-attribute');

                categoryAttributes.forEach(function(attr) {
                    var text = attr.textContent.toLowerCase();
                    if (text.includes(searchLower)) {
                        attr.style.display = '';
                        hasVisibleAttribute = true;
                    } else {
                        attr.style.display = 'none';
                    }
                });

                category.style.display = hasVisibleAttribute ? '' : 'none';
            });
        }
        window.filterProfileReviewAttributes = filterProfileReviewAttributes;

        // Show Info Modal
        function showProfileReviewInfo(attribute) {
            var data = profileReviewInfoData[attribute] || profileReviewInfoData['pr-kinder'];
            var modal = document.getElementById('profileReviewInfoModal');
            if (!modal) return;

            document.getElementById('profileReviewInfoTitle').textContent = 'â„¹ï¸ ' + data.title;
            document.getElementById('profileReviewInfoStats').textContent = data.stats;
            document.getElementById('profileReviewInfoResearch').innerHTML = data.research;
            document.getElementById('profileReviewInfoPirsig').textContent = data.pirsig;
            document.getElementById('profileReviewInfoOsho').textContent = data.osho;

            modal.style.display = 'flex';
            modal.classList.add('active');
        }
        window.showProfileReviewInfo = showProfileReviewInfo;

        // Close Info Modal
        function closeProfileReviewInfoModal(event) {
            if (event && event.target !== event.currentTarget) return;
            var modal = document.getElementById('profileReviewInfoModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('active');
            }
        }
        window.closeProfileReviewInfoModal = closeProfileReviewInfoModal;

        // Get Current State (Toggle-Buttons + 3er-Gruppen)
        // Nur die 16 wichtigsten Attribute werden gespeichert
        function getProfileReviewState() {
            return {
                // GESCHLECHTSIDENTITÃ„T
                geschlechtsidentitaet: getTripleBtnValue('pr-geschlecht-sekundaer'),
                // LEBENSPLANUNG (ohne: zusammen, haustiere, umzug)
                kinder: document.getElementById('pr-kinder')?.classList.contains('active'),
                ehe: document.getElementById('pr-ehe')?.classList.contains('active'),
                familie: getTripleBtnValue('pr-familie'),
                // FINANZEN & KARRIERE
                finanzen: getTripleBtnValue('pr-finanzen'),
                karriere: getTripleBtnValue('pr-karriere'),
                // KOMMUNIKATION (ohne: gespraech)
                emotional: getTripleBtnValue('pr-emotional'),
                konflikt: getTripleBtnValue('pr-konflikt'),
                // SOZIALES
                introextro: getTripleBtnValue('pr-introextro'),
                alleinzeit: getTripleBtnValue('pr-alleinzeit'),
                freunde: getTripleBtnValue('pr-freunde'),
                // INTIMITÃ„T
                naehe: getTripleBtnValue('pr-naehe'),
                romantik: getTripleBtnValue('pr-romantik'),
                sex: getTripleBtnValue('pr-sex'),
                // WERTE
                religion: getTripleBtnValue('pr-religion'),
                tradition: getTripleBtnValue('pr-tradition'),
                umwelt: getTripleBtnValue('pr-umwelt')
                // PRAKTISCHES - nicht verdrahtet (ordnung, reise)
            };
        }

        // Reset Profile Review - alle Attribute auf Config-Defaults zurÃ¼cksetzen
        function resetProfileReview() {
            if (confirm('Alle Ã„nderungen zurÃ¼cksetzen und Standard-Werte wiederherstellen?')) {
                // Nutze ProfileReviewRenderer fÃ¼r vollstÃ¤ndigen Reset auf Config-Defaults
                if (typeof ProfileReviewRenderer !== 'undefined') {
                    ProfileReviewRenderer.resetAllValues();
                } else {
                    // Fallback: Manuelles Reset auf Default 50
                    var tripleAttrs = [
                        'pr-geschlecht-sekundaer', // GeschlechtsidentitÃ¤t (default 0 = Cis)
                        'pr-kinder', 'pr-ehe', 'pr-zusammen', 'pr-haustiere',
                        'pr-umzug', 'pr-familie', 'pr-finanzen', 'pr-karriere',
                        'pr-gespraech', 'pr-emotional', 'pr-konflikt',
                        'pr-introextro', 'pr-alleinzeit', 'pr-freunde',
                        'pr-naehe', 'pr-romantik', 'pr-sex',
                        'pr-religion', 'pr-tradition', 'pr-umwelt',
                        'pr-ordnung', 'pr-reise'
                    ];
                    tripleAttrs.forEach(function(attrId) {
                        setTripleBtnValue(attrId, 50);
                    });
                }

                // v3.6: AUCH BedÃ¼rfnisse/Needs zurÃ¼cksetzen
                if (typeof AttributeSummaryCard !== 'undefined' &&
                    typeof AttributeSummaryCard.resetSelectedNeedsValues === 'function') {
                    // Zuerst alle Markierungen entfernen, damit ALLE Needs zurÃ¼ckgesetzt werden
                    if (typeof AttributeSummaryCard.clearNeedSelection === 'function') {
                        AttributeSummaryCard.clearNeedSelection();
                    }
                    AttributeSummaryCard.resetSelectedNeedsValues();
                    // Markierung erneut clearen und Button-Status aktualisieren
                    if (typeof AttributeSummaryCard.clearNeedSelection === 'function') {
                        AttributeSummaryCard.clearNeedSelection();
                    }
                    if (typeof AttributeSummaryCard.updateSelectedLockButtonState === 'function') {
                        AttributeSummaryCard.updateSelectedLockButtonState();
                    }
                    console.log('[resetProfileReview] BedÃ¼rfnisse wurden zurÃ¼ckgesetzt');
                }

                // Reset counter
                profileReviewChangesCount = 0;
                var badge = document.getElementById('profileReviewChangesBadge');
                if (badge) badge.style.display = 'none';

                // Update initial state nach Reset
                profileReviewInitialState = getProfileReviewState();

                // Clear search filter
                if (typeof clearProfileReviewSearch === 'function') {
                    clearProfileReviewSearch();
                }
            }
        }
        // DEPRECATED: window.resetProfileReview = resetProfileReview;

        /**
         * Updates the geschlechtsidentitÃ¤t card options based on primary geschlecht
         * KONTEXTABHÃ„NGIG:
         * - Mann/Frau (binÃ¤r): Cis, Trans, NonbinÃ¤r (3 options)
         * - Inter (divers): NonbinÃ¤r, Fluid (2 options)
         * @param {string} primaryGeschlecht - 'mann', 'frau', 'inter', or null
         */
        function updateGeschlechtsidentitaetOptions(primaryGeschlecht, secondaryGeschlecht) {
            var card = document.getElementById('pr-geschlecht-sekundaer-card');
            if (!card) return;

            var buttonsContainer = card.querySelector('[data-attr="pr-geschlecht-sekundaer"]');
            if (!buttonsContainer) return;

            var options, values;
            if (primaryGeschlecht === 'inter') {
                // Inter (divers): NonbinÃ¤r, Fluid (2 options)
                options = ['NonbinÃ¤r', 'Fluid'];
                values = [0, 100];
            } else {
                // Mann/Frau (binÃ¤r): Cis, Trans, NonbinÃ¤r (3 options - matches profile-config.js)
                options = ['Cis', 'Trans', 'NonbinÃ¤r'];
                values = [0, 50, 100];
            }
            buttonsContainer.classList.remove('five-options');

            // Bestimme welche Option aktiv sein soll basierend auf Hauptseiten-Auswahl
            var activeIndex = -1; // -1 = keine Auswahl wenn nichts auf Hauptseite ausgewÃ¤hlt
            if (primaryGeschlecht && secondaryGeschlecht) {
                // Synchronisiere mit Hauptseiten-Auswahl
                var mappedValue = mapSecondaryToGeschlechtsidentitaet(secondaryGeschlecht, primaryGeschlecht);
                activeIndex = values.indexOf(mappedValue);
                if (activeIndex === -1) activeIndex = 0; // Fallback
            }

            // Regenerate buttons
            var buttonsHtml = options.map(function(label, i) {
                var isActive = (i === activeIndex) ? ' active' : '';
                return '<button class="profile-review-triple-btn' + isActive + '" data-value="' + values[i] + '" onclick="selectTripleBtn(this)">' + label + '</button>';
            }).join('');

            buttonsContainer.innerHTML = buttonsHtml;
        }

        /**
         * Maps secondary geschlecht back to profile review value
         * KONTEXTABHÃ„NGIG:
         * - Mann/Frau (binÃ¤r): Cis=0, Trans=50, NonbinÃ¤r=100
         * - Inter (divers): NonbinÃ¤r=0, Fluid=100 (2 options)
         * @param {string} secondary - 'cis', 'trans', 'nonbinaer', 'fluid'
         * @param {string} primary - Body: 'mann', 'frau', 'inter'
         * @returns {number} Profile review value
         */
        function mapSecondaryToGeschlechtsidentitaet(secondary, primary) {
            // For Inter (divers): NonbinÃ¤r=0, Fluid=100 (2 options)
            if (primary === 'inter') {
                if (secondary === 'nonbinaer') return 0;
                if (secondary === 'fluid') return 100;
                return 0; // Default to NonbinÃ¤r for Inter
            }

            // For Mann/Frau (binÃ¤r): Cis=0, Trans=50, NonbinÃ¤r=100
            if (secondary === 'nonbinaer') return 100;

            // Cis: identity matches body
            if (secondary === 'cis' || secondary === primary) return 0;

            // Trans: identity differs from body
            if (secondary === 'trans' ||
                (primary === 'mann' && secondary === 'frau') ||
                (primary === 'frau' && secondary === 'mann')) {
                return 50; // Trans
            }

            // Legacy: suchend/fluid â†’ map to NonbinÃ¤r for Mann/Frau
            if (secondary === 'suchend' || secondary === 'unsicher' || secondary === 'fluid') return 100;

            // Default: Cis
            return 0;
        }

        /**
         * Maps profile review geschlechtsidentitÃ¤t value to secondary geschlecht
         * KONTEXTABHÃ„NGIG:
         * - Mann/Frau (binÃ¤r): 0=Cis, 50=Trans, 100=NonbinÃ¤r
         * - Inter (divers): 0=NonbinÃ¤r, 100=Fluid (2 options)
         * @param {number} value - Profile review button value
         * @param {string} primaryGeschlecht - Body: 'mann', 'frau', 'inter'
         * @returns {string} Secondary value for TiageState
         */
        function mapGeschlechtsidentitaetToSecondary(value, primaryGeschlecht) {
            // For Inter (divers): 0=NonbinÃ¤r, 100=Fluid (2 options)
            if (primaryGeschlecht === 'inter') {
                if (value <= 50) return 'nonbinaer';  // 0
                return 'fluid';                       // 100
            }

            // For Mann/Frau (binÃ¤r): 0=Cis, 50=Trans, 100=NonbinÃ¤r
            if (value <= 25) return 'cis';       // 0
            if (value <= 75) return 'trans';     // 50
            return 'nonbinaer';                  // 100
        }

        // Save Profile Review
        function saveProfileReview() {
            var state = getProfileReviewState();
            console.log('Profil gespeichert:', state);

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEU: Speichere Gewichtungen
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof saveGewichtungen === 'function') {
                saveGewichtungen();
                console.log('[ProfileReview] Gewichtungen gespeichert');
            }

            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // NEU (v1.8.128): Speichere Array-BedÃ¼rfnisstruktur
            // Format: [{ id, key, stringKey, label, value, locked }, ...]
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            if (typeof AttributeSummaryCard !== 'undefined') {
                try {
                    if (AttributeSummaryCard.getFlatNeeds) {
                        // Neue API (v1.8.128): Array-Struktur
                        var flatNeeds = AttributeSummaryCard.getFlatNeeds();
                        localStorage.setItem('tiage_flat_needs', JSON.stringify(flatNeeds));
                        var count = Array.isArray(flatNeeds) ? flatNeeds.length : Object.keys(flatNeeds).length;
                        console.log('[ProfileReview] BedÃ¼rfnisse gespeichert (Array-Format):', count, 'EintrÃ¤ge');
                    } else {
                        // Fallback: Alte API (sollte nicht mehr vorkommen)
                        var flatNeedsValues = AttributeSummaryCard.getFlatNeedsValues();
                        var flatLockedNeeds = AttributeSummaryCard.getFlatLockedNeeds();
                        localStorage.setItem('tiage_flat_needs_values', JSON.stringify(flatNeedsValues));
                        localStorage.setItem('tiage_flat_needs_locks', JSON.stringify(flatLockedNeeds));
                        console.log('[ProfileReview] BedÃ¼rfnisse gespeichert (Legacy):', Object.keys(flatNeedsValues).length, 'Werte');
                    }
                } catch (e) {
                    console.warn('[ProfileReview] Fehler beim Speichern der BedÃ¼rfnisse:', e);
                }
            }

            // Store in TiageState if available
            if (typeof TiageState !== 'undefined') {
                // FIX: Preserve existing lockedNeeds when saving profileReview UI state
                // profileReview has two data types:
                // 1. UI state (geschlechtsidentitaet, kinder, etc.) - flat structure
                // 2. Lock state (ich.lockedNeeds, partner.lockedNeeds) - nested structure
                var existingProfileReview = TiageState.get('profileReview') || {};
                var mergedState = Object.assign({}, state, {
                    ich: existingProfileReview.ich || { lockedNeeds: {} },
                    partner: existingProfileReview.partner || { lockedNeeds: {} }
                });
                TiageState.set('profileReview', mergedState);
                TiageState.saveToStorage(); // Persist merged state including lockedNeeds

                // Apply geschlechtsidentitÃ¤t to main gender selection for 'ich'
                if (state.geschlechtsidentitaet !== undefined) {
                    var primaryGeschlecht = TiageState.getPrimaryGeschlecht('ich');
                    if (primaryGeschlecht) {
                        var secondaryValue = mapGeschlechtsidentitaetToSecondary(
                            parseInt(state.geschlechtsidentitaet, 10),
                            primaryGeschlecht
                        );
                        TiageState.setSecondaryGeschlecht('ich', secondaryValue);
                        console.log('GeschlechtsidentitÃ¤t angewendet:', primaryGeschlecht, 'â†’', secondaryValue);

                        // Update UI: trigger geschlecht grid update
                        if (typeof updateGeschlechtGrid === 'function') {
                            updateGeschlechtGrid('ich');
                        }
                    }
                }
            }

            // Close modal
            closeProfileReviewModal();

            // Update score display after profile changes
            if (typeof updateComparisonView === 'function') {
                updateComparisonView();
            }

            // Optional: Show success message
            // alert('Profil gespeichert! ' + profileReviewChangesCount + ' Ã„nderungen Ã¼bernommen.');
        }
        // DEPRECATED: window.saveProfileReview = saveProfileReview;

        // Close modal on ESC
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                closeProfileReviewInfoModal();
                closeProfileReviewModal();
            }
        });

        console.log('All modal functions are now globally available');

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // DEBUG: Element Inspector - Click to log element path & styles
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        (function initDebugger() {
            function getElementPath(el) {
                const path = [];
                while (el && el.nodeType === 1) {
                    let selector = el.tagName.toLowerCase();
                    if (el.id) {
                        selector += '#' + el.id;
                    } else if (el.className && typeof el.className === 'string') {
                        const classes = el.className.trim().split(/\s+/).filter(c => c);
                        if (classes.length) selector += '.' + classes.join('.');
                    }
                    path.unshift(selector);
                    el = el.parentElement;
                }
                return path.join(' > ');
            }

            function getAppliedStyles(el) {
                const computed = window.getComputedStyle(el);
                return {
                    display: computed.display,
                    flexDirection: computed.flexDirection,
                    gridTemplateColumns: computed.gridTemplateColumns,
                    padding: computed.padding,
                    background: computed.background,
                    borderLeft: computed.borderLeft
                };
            }

            document.addEventListener('click', function(e) {
                const el = e.target;
                const path = getElementPath(el);
                const styles = getAppliedStyles(el);

                console.group('%cğŸ” DEBUG: Element clicked', 'color: #8B5CF6; font-weight: bold;');
                console.log('%cğŸ“ Path:', 'color: #22c55e;', path);
                console.log('%cğŸ·ï¸ Tag:', 'color: #3b82f6;', el.tagName);
                console.log('%cğŸ†” ID:', 'color: #f59e0b;', el.id || '(none)');
                console.log('%cğŸ“‹ Classes:', 'color: #ec4899;', el.className || '(none)');
                console.log('%cğŸ¨ Styles:', 'color: #14b8a6;', styles);
                console.log('%cğŸ“¦ Element:', 'color: #6366f1;', el);
                console.groupEnd();
            }, true);

            console.log('%cğŸ› DEBUG MODE ACTIVE - Click any element to inspect', 'background: #8B5CF6; color: white; padding: 4px 8px; border-radius: 4px;');
        })();

